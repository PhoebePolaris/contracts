[FILE] KyberNetworkProxy.sol
Processing contract: KyberNetworkProxy.sol:ERC20
Processing contract: KyberNetworkProxy.sol:KyberNetworkInterface
Processing contract: KyberNetworkProxy.sol:KyberNetworkProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: KyberNetworkProxy.sol:KyberNetworkProxyInterface
Processing contract: KyberNetworkProxy.sol:PermissionGroups
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: KyberNetworkProxy.sol:SimpleNetworkInterface
Processing contract: KyberNetworkProxy.sol:Utils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: KyberNetworkProxy.sol:Utils2
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: KyberNetworkProxy.sol:Withdrawable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'KyberNetworkProxy':
  > |pragma solidity 0.4.18;
    |
    |// File: contracts/ERC20Interface.sol
  at KyberNetworkProxy.sol(1)

[31mViolation[0m for RepeatedCall in contract 'KyberNetworkProxy':
  > |pragma solidity 0.4.18;
    |
    |// File: contracts/ERC20Interface.sol
  at KyberNetworkProxy.sol(1)

[31mViolation[0m for RepeatedCall in contract 'KyberNetworkProxy':
    |            return user.balance;
    |        else
  > |            return token.balanceOf(user);
    |    }
    |
  at KyberNetworkProxy.sol(133)

[31mViolation[0m for RepeatedCall in contract 'KyberNetworkProxy':
    |            decimal = ETH_DECIMALS;
    |        } else {
  > |            if (!address(token).call(bytes4(keccak256("decimals()")))) {/* solhint-disable-line avoid-low-level-calls */
    |                //above code can only be performed with low level call. otherwise all operation will revert.
    |                // call failed
  at KyberNetworkProxy.sol(152)

[31mViolation[0m for RepeatedCall in contract 'KyberNetworkProxy':
    |                decimal = 18;
    |            } else {
  > |                decimal = token.decimals();
    |            }
    |        }
  at KyberNetworkProxy.sol(157)

[31mViolation[0m for RepeatedCall in contract 'KyberNetworkProxy':
    |            userBalanceBefore.srcBalance += msg.value;
    |        } else {
  > |            require(src.transferFrom(msg.sender, kyberNetworkContract, srcAmount));
    |        }
    |
  at KyberNetworkProxy.sol(505)

[33mWarning[0m for TODAmount in contract 'KyberNetworkProxy':
  > |pragma solidity 0.4.18;
    |
    |// File: contracts/ERC20Interface.sol
  at KyberNetworkProxy.sol(1)

[33mWarning[0m for TODReceiver in contract 'KyberNetworkProxy':
  > |pragma solidity 0.4.18;
    |
    |// File: contracts/ERC20Interface.sol
  at KyberNetworkProxy.sol(1)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'KyberNetworkProxy':
  > |pragma solidity 0.4.18;
    |
    |// File: contracts/ERC20Interface.sol
  at KyberNetworkProxy.sol(1)

[33mWarning[0m for UnrestrictedWrite in contract 'KyberNetworkProxy':
    |        for (uint i = 0; i < alertersGroup.length; ++i) {
    |            if (alertersGroup[i] == alerter) {
  > |                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];
    |                alertersGroup.length--;
    |                AlerterAdded(alerter, false);
  at KyberNetworkProxy.sol(279)

[33mWarning[0m for UnrestrictedWrite in contract 'KyberNetworkProxy':
    |        for (uint i = 0; i < operatorsGroup.length; ++i) {
    |            if (operatorsGroup[i] == operator) {
  > |                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];
    |                operatorsGroup.length -= 1;
    |                OperatorAdded(operator, false);
  at KyberNetworkProxy.sol(304)

[33mWarning[0m for UnrestrictedWrite in contract 'KyberNetworkProxy':
    |////////////////////////////////////////////////////////////////////////////////////////////////////////
    |/// @title Kyber Network proxy for main contract
  > |contract KyberNetworkProxy is KyberNetworkProxyInterface, SimpleNetworkInterface, Withdrawable, Utils2 {
    |
    |    KyberNetworkInterface public kyberNetworkContract;
  at KyberNetworkProxy.sol(349)

[31mViolation[0m for LockedEther in contract 'PermissionGroups':
    |// File: contracts/PermissionGroups.sol
    |
  > |contract PermissionGroups {
    |
    |    address public admin;
  at KyberNetworkProxy.sol(190)

[31mViolation[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |// File: contracts/PermissionGroups.sol
    |
  > |contract PermissionGroups {
    |
    |    address public admin;
  at KyberNetworkProxy.sol(190)

[31mViolation[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        for (uint i = 0; i < alertersGroup.length; ++i) {
    |            if (alertersGroup[i] == alerter) {
  > |                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];
    |                alertersGroup.length--;
    |                AlerterAdded(alerter, false);
  at KyberNetworkProxy.sol(279)

[31mViolation[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        for (uint i = 0; i < operatorsGroup.length; ++i) {
    |            if (operatorsGroup[i] == operator) {
  > |                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];
    |                operatorsGroup.length -= 1;
    |                OperatorAdded(operator, false);
  at KyberNetworkProxy.sol(304)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |// File: contracts/PermissionGroups.sol
    |
  > |contract PermissionGroups {
    |
    |    address public admin;
  at KyberNetworkProxy.sol(190)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        require(newAdmin != address(0));
    |        TransferAdminPending(pendingAdmin);
  > |        pendingAdmin = newAdmin;
    |    }
    |
  at KyberNetworkProxy.sol(236)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        TransferAdminPending(newAdmin);
    |        AdminClaimed(newAdmin, admin);
  > |        admin = newAdmin;
    |    }
    |
  at KyberNetworkProxy.sol(247)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        require(pendingAdmin == msg.sender);
    |        AdminClaimed(pendingAdmin, admin);
  > |        admin = pendingAdmin;
    |        pendingAdmin = address(0);
    |    }
  at KyberNetworkProxy.sol(258)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        AdminClaimed(pendingAdmin, admin);
    |        admin = pendingAdmin;
  > |        pendingAdmin = address(0);
    |    }
    |
  at KyberNetworkProxy.sol(259)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |
    |        AlerterAdded(newAlerter, true);
  > |        alerters[newAlerter] = true;
    |        alertersGroup.push(newAlerter);
    |    }
  at KyberNetworkProxy.sol(269)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        AlerterAdded(newAlerter, true);
    |        alerters[newAlerter] = true;
  > |        alertersGroup.push(newAlerter);
    |    }
    |
  at KyberNetworkProxy.sol(270)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |    function removeAlerter (address alerter) public onlyAdmin {
    |        require(alerters[alerter]);
  > |        alerters[alerter] = false;
    |
    |        for (uint i = 0; i < alertersGroup.length; ++i) {
  at KyberNetworkProxy.sol(275)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |
    |        OperatorAdded(newOperator, true);
  > |        operators[newOperator] = true;
    |        operatorsGroup.push(newOperator);
    |    }
  at KyberNetworkProxy.sol(294)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |        OperatorAdded(newOperator, true);
    |        operators[newOperator] = true;
  > |        operatorsGroup.push(newOperator);
    |    }
    |
  at KyberNetworkProxy.sol(295)

[33mWarning[0m for UnrestrictedWrite in contract 'PermissionGroups':
    |    function removeOperator (address operator) public onlyAdmin {
    |        require(operators[operator]);
  > |        operators[operator] = false;
    |
    |        for (uint i = 0; i < operatorsGroup.length; ++i) {
  at KyberNetworkProxy.sol(300)

[31mViolation[0m for MissingInputValidation in contract 'Utils2':
    |    /// @param token The token type
    |    /// @return The balance
  > |    function getBalance(ERC20 token, address user) public view returns(uint) {
    |        if (token == ETH_TOKEN_ADDRESS)
    |            return user.balance;
  at KyberNetworkProxy.sol(129)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Withdrawable':
    |     */
    |    function withdrawEther(uint amount, address sendTo) external onlyAdmin {
  > |        sendTo.transfer(amount);
    |        EtherWithdraw(amount, sendTo);
    |    }
  at KyberNetworkProxy.sol(340)

[31mViolation[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        for (uint i = 0; i < alertersGroup.length; ++i) {
    |            if (alertersGroup[i] == alerter) {
  > |                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];
    |                alertersGroup.length--;
    |                AlerterAdded(alerter, false);
  at KyberNetworkProxy.sol(279)

[31mViolation[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        for (uint i = 0; i < operatorsGroup.length; ++i) {
    |            if (operatorsGroup[i] == operator) {
  > |                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];
    |                operatorsGroup.length -= 1;
    |                OperatorAdded(operator, false);
  at KyberNetworkProxy.sol(304)

[31mViolation[0m for UnrestrictedWrite in contract 'Withdrawable':
    | * This will prevent any accidental loss of tokens.
    | */
  > |contract Withdrawable is PermissionGroups {
    |
    |    event TokenWithdraw(ERC20 token, uint amount, address sendTo);
  at KyberNetworkProxy.sol(321)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        require(newAdmin != address(0));
    |        TransferAdminPending(pendingAdmin);
  > |        pendingAdmin = newAdmin;
    |    }
    |
  at KyberNetworkProxy.sol(236)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        TransferAdminPending(newAdmin);
    |        AdminClaimed(newAdmin, admin);
  > |        admin = newAdmin;
    |    }
    |
  at KyberNetworkProxy.sol(247)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        require(pendingAdmin == msg.sender);
    |        AdminClaimed(pendingAdmin, admin);
  > |        admin = pendingAdmin;
    |        pendingAdmin = address(0);
    |    }
  at KyberNetworkProxy.sol(258)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        AdminClaimed(pendingAdmin, admin);
    |        admin = pendingAdmin;
  > |        pendingAdmin = address(0);
    |    }
    |
  at KyberNetworkProxy.sol(259)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |
    |        AlerterAdded(newAlerter, true);
  > |        alerters[newAlerter] = true;
    |        alertersGroup.push(newAlerter);
    |    }
  at KyberNetworkProxy.sol(269)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        AlerterAdded(newAlerter, true);
    |        alerters[newAlerter] = true;
  > |        alertersGroup.push(newAlerter);
    |    }
    |
  at KyberNetworkProxy.sol(270)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |    function removeAlerter (address alerter) public onlyAdmin {
    |        require(alerters[alerter]);
  > |        alerters[alerter] = false;
    |
    |        for (uint i = 0; i < alertersGroup.length; ++i) {
  at KyberNetworkProxy.sol(275)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |
    |        OperatorAdded(newOperator, true);
  > |        operators[newOperator] = true;
    |        operatorsGroup.push(newOperator);
    |    }
  at KyberNetworkProxy.sol(294)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |        OperatorAdded(newOperator, true);
    |        operators[newOperator] = true;
  > |        operatorsGroup.push(newOperator);
    |    }
    |
  at KyberNetworkProxy.sol(295)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    |    function removeOperator (address operator) public onlyAdmin {
    |        require(operators[operator]);
  > |        operators[operator] = false;
    |
    |        for (uint i = 0; i < operatorsGroup.length; ++i) {
  at KyberNetworkProxy.sol(300)

[33mWarning[0m for UnrestrictedWrite in contract 'Withdrawable':
    | * This will prevent any accidental loss of tokens.
    | */
  > |contract Withdrawable is PermissionGroups {
    |
    |    event TokenWithdraw(ERC20 token, uint amount, address sendTo);
  at KyberNetworkProxy.sol(321)

[FILE] AuctusTokenSale.sol
Processing contract: AuctusTokenSale.sol:AuctusToken
Processing contract: AuctusTokenSale.sol:AuctusTokenSale
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AuctusTokenSale.sol:AuctusWhitelist
Processing contract: AuctusTokenSale.sol:ContractReceiver
Processing contract: AuctusTokenSale.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'AuctusTokenSale':
    |
    |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
  > |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
    |		AuctusToken token = AuctusToken(auctusTokenAddress);
  at AuctusTokenSale.sol(166)

[31mViolation[0m for DAOConstantGas in contract 'AuctusTokenSale':
    |		uint256 vestedEthers = address(this).balance - freeEthers;
    |
  > |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
    |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
  at AuctusTokenSale.sol(165)

[31mViolation[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
  > |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
    |		assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales));
    |	}
  at AuctusTokenSale.sol(236)

[31mViolation[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
  > |		assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales));
    |	}
    |}
  at AuctusTokenSale.sol(237)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		bytes memory empty;
    |		assert(token.transfer(0x6bc58c572d0973cF0EfA1Fe1D7D6c9d7Eea2cd23, auctusCoreTeam, empty)); //AuctusTokenVesting SC
  > |		assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC
    |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
  at AuctusTokenSale.sol(232)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x6bc58c572d0973cF0EfA1Fe1D7D6c9d7Eea2cd23, auctusCoreTeam, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC
  > |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
  at AuctusTokenSale.sol(233)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC
    |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
  > |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
  at AuctusTokenSale.sol(234)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
  > |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
    |		assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales));
  at AuctusTokenSale.sol(235)

[31mViolation[0m for TODAmount in contract 'AuctusTokenSale':
    |
    |		if (weiRemaining > 0) {
  > |			msg.sender.transfer(weiRemaining);
    |		}
    |		assert(AuctusToken(auctusTokenAddress).transfer(msg.sender, tokensToReceive));
  at AuctusTokenSale.sol(139)

[31mViolation[0m for TODAmount in contract 'AuctusTokenSale':
    |		uint256 vestedEthers = address(this).balance - freeEthers;
    |
  > |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
    |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
  at AuctusTokenSale.sol(165)

[31mViolation[0m for TODAmount in contract 'AuctusTokenSale':
    |
    |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
  > |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
    |		AuctusToken token = AuctusToken(auctusTokenAddress);
  at AuctusTokenSale.sol(166)

[33mWarning[0m for TODAmount in contract 'AuctusTokenSale':
    |
    |		invested[msg.sender] = 0;
  > |		msg.sender.transfer(investedValue);
    |
    |		emit Revoke(msg.sender, investedValue);
  at AuctusTokenSale.sol(151)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AuctusTokenSale':
    |
    |		if (weiRemaining > 0) {
  > |			msg.sender.transfer(weiRemaining);
    |		}
    |		assert(AuctusToken(auctusTokenAddress).transfer(msg.sender, tokensToReceive));
  at AuctusTokenSale.sol(139)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AuctusTokenSale':
    |
    |		invested[msg.sender] = 0;
  > |		msg.sender.transfer(investedValue);
    |
    |		emit Revoke(msg.sender, investedValue);
  at AuctusTokenSale.sol(151)

[31mViolation[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		transferTokens(auctusCoreTeam, bounty, reserveForFuture, preSale, partnershipsAdvisoryVested, partnershipsAdvisoryFree, privateSales);
    |		
  > |		remainingTokens = totalAmount - auctusCoreTeam - bounty - reserveForFuture - preSale - partnershipsAdvisoryVested - partnershipsAdvisoryFree - privateSales;
    |		saleWasSet = true;
    |	}
  at AuctusTokenSale.sol(216)

[31mViolation[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		
    |		remainingTokens = totalAmount - auctusCoreTeam - bounty - reserveForFuture - preSale - partnershipsAdvisoryVested - partnershipsAdvisoryFree - privateSales;
  > |		saleWasSet = true;
    |	}
    |	
  at AuctusTokenSale.sol(217)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |
    |		uint256 tokensToReceive = weiToInvest.mul(basicPricePerEth);
  > |		remainingTokens = remainingTokens.sub(tokensToReceive);
    |		weiRaised = weiRaised.add(weiToInvest);
    |		invested[msg.sender] = invested[msg.sender].add(weiToInvest);
  at AuctusTokenSale.sol(134)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		uint256 tokensToReceive = weiToInvest.mul(basicPricePerEth);
    |		remainingTokens = remainingTokens.sub(tokensToReceive);
  > |		weiRaised = weiRaised.add(weiToInvest);
    |		invested[msg.sender] = invested[msg.sender].add(weiToInvest);
    |
  at AuctusTokenSale.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |	function transferOwnership(address newOwner) onlyOwner public {
    |		require(newOwner != address(0));
  > |		owner = newOwner;
    |	}
    |
  at AuctusTokenSale.sol(99)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |
    |	function setTokenSaleHalt(bool halted) onlyOwner public {
  > |		tokenSaleHalted = halted;
    |	}
    |
  at AuctusTokenSale.sol(103)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |	function setSoftCap(uint256 minimumCap) onlyOwner public {
    |		require(now < startTime);
  > |		softCap = minimumCap;
    |	}
    |
  at AuctusTokenSale.sol(108)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |	function setEndSaleTime(uint256 endSaleTime) onlyOwner public {
    |		require(now < endTime);
  > |		endTime = endSaleTime;
    |	}
    |
  at AuctusTokenSale.sol(113)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		if (remainingTokens > 0) {
    |			token.burn(remainingTokens);
  > |			remainingTokens = 0;
    |		}
    |	}
  at AuctusTokenSale.sol(172)

[FILE] ICOStartReservation.sol
Processing contract: ICOStartReservation.sol:ERC20
Processing contract: ICOStartReservation.sol:ERC20Basic
Processing contract: ICOStartReservation.sol:ICOStartReservation
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ICOStartReservation.sol:ICOStartSaleInterface
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ICOStartReservation.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ICOStartReservation.sol:Pausable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ICOStartReservation.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'ICOStartReservation':
    |    (fee, netAmount) = _getFeeAndNetAmount(weiCollected);
    |
  > |    require(address(sale).call.value(netAmount)(this));
    |    tokensReceived = getToken().balanceOf(this);
    |
  at ICOStartReservation.sol(328)

[33mWarning[0m for DAOConstantGas in contract 'ICOStartReservation':
    |
    |    if (fee != 0) {
  > |      manager.transfer(fee);
    |    }
    |
  at ICOStartReservation.sol(332)

[31mViolation[0m for RepeatedCall in contract 'ICOStartReservation':
    |   */
    |  function getToken() public view returns (ERC20) {
  > |    return sale.token();
    |  }
    |
  at ICOStartReservation.sol(274)

[33mWarning[0m for TODAmount in contract 'ICOStartReservation':
    |    (fee, netAmount) = _getFeeAndNetAmount(weiCollected);
    |
  > |    require(address(sale).call.value(netAmount)(this));
    |    tokensReceived = getToken().balanceOf(this);
    |
  at ICOStartReservation.sol(328)

[33mWarning[0m for TODAmount in contract 'ICOStartReservation':
    |
    |    if (fee != 0) {
  > |      manager.transfer(fee);
    |    }
    |
  at ICOStartReservation.sol(332)

[33mWarning[0m for TODAmount in contract 'ICOStartReservation':
    |    deposits[msg.sender] = 0;
    |    weiCollected = weiCollected.sub(depositAmount);
  > |    msg.sender.transfer(depositAmount);
    |    emit Withdrawn(msg.sender, depositAmount);
    |  }
  at ICOStartReservation.sol(347)

[33mWarning[0m for TODReceiver in contract 'ICOStartReservation':
    |    (fee, netAmount) = _getFeeAndNetAmount(weiCollected);
    |
  > |    require(address(sale).call.value(netAmount)(this));
    |    tokensReceived = getToken().balanceOf(this);
    |
  at ICOStartReservation.sol(328)

[33mWarning[0m for TODReceiver in contract 'ICOStartReservation':
    |
    |    if (fee != 0) {
  > |      manager.transfer(fee);
    |    }
    |
  at ICOStartReservation.sol(332)

[33mWarning[0m for UnrestrictedWrite in contract 'ICOStartReservation':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ICOStartReservation.sol(56)

[33mWarning[0m for UnrestrictedWrite in contract 'ICOStartReservation':
    |   */
    |  function pause() onlyOwner whenNotPaused public {
  > |    paused = true;
    |    emit Pause();
    |  }
  at ICOStartReservation.sol(94)

[33mWarning[0m for UnrestrictedWrite in contract 'ICOStartReservation':
    |   */
    |  function unpause() onlyOwner whenPaused public {
  > |    paused = false;
    |    emit Unpause();
    |  }
  at ICOStartReservation.sol(102)

[33mWarning[0m for UnrestrictedWrite in contract 'ICOStartReservation':
    |   */
    |  function cancel() public onlyOwner whenPaused whenNotPaid {
  > |    canceled = true;
    |  }
    |
  at ICOStartReservation.sol(314)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ICOStartReservation.sol(56)

[33mWarning[0m for UnrestrictedWrite in contract 'Pausable':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ICOStartReservation.sol(56)

[33mWarning[0m for UnrestrictedWrite in contract 'Pausable':
    |   */
    |  function pause() onlyOwner whenNotPaused public {
  > |    paused = true;
    |    emit Pause();
    |  }
  at ICOStartReservation.sol(94)

[33mWarning[0m for UnrestrictedWrite in contract 'Pausable':
    |   */
    |  function unpause() onlyOwner whenPaused public {
  > |    paused = false;
    |    emit Unpause();
    |  }
  at ICOStartReservation.sol(102)

[FILE] RegistryExec.sol
Processing contract: RegistryExec.sol:RegistryExec
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RegistryExec.sol:RegistryInterface
Processing contract: RegistryExec.sol:ScriptExec
Processing contract: RegistryExec.sol:StorageInterface
[31mViolation[0m for DAO in contract 'RegistryExec':
    |
    |    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -
  > |    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(
    |      EXEC_SEL, msg.sender, _exec_id, _calldata
    |    )) == false) {
  at RegistryExec.sol(279)

[31mViolation[0m for RepeatedCall in contract 'RegistryExec':
    |      checkErrors(_exec_id);
    |      // Return unspent wei to sender
  > |      address(msg.sender).transfer(address(this).balance);
    |      return false;
    |    }
  at RegistryExec.sol(285)

[31mViolation[0m for RepeatedCall in contract 'RegistryExec':
    |
    |    // Transfer any returned wei back to the sender
  > |    address(msg.sender).transfer(address(this).balance);
    |  }
    |
  at RegistryExec.sol(295)

[31mViolation[0m for RepeatedCall in contract 'RegistryExec':
    |    // If execution was successful, the version was updated. Get the latest version
    |    // and set the exec id instance info -
  > |    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);
    |    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(
    |      app_storage,
  at RegistryExec.sol(431)

[31mViolation[0m for RepeatedCall in contract 'RegistryExec':
    |    // and set the exec id instance info -
    |    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);
  > |    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(
    |      app_storage,
    |      inst.current_registry_exec_id,
  at RegistryExec.sol(432)

[31mViolation[0m for TODAmount in contract 'RegistryExec':
    |      checkErrors(_exec_id);
    |      // Return unspent wei to sender
  > |      address(msg.sender).transfer(address(this).balance);
    |      return false;
    |    }
  at RegistryExec.sol(285)

[31mViolation[0m for TODAmount in contract 'RegistryExec':
    |
    |    // Transfer any returned wei back to the sender
  > |    address(msg.sender).transfer(address(this).balance);
    |  }
    |
  at RegistryExec.sol(295)

[33mWarning[0m for TODAmount in contract 'RegistryExec':
    |
    |    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -
  > |    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(
    |      EXEC_SEL, msg.sender, _exec_id, _calldata
    |    )) == false) {
  at RegistryExec.sol(279)

[33mWarning[0m for TODReceiver in contract 'RegistryExec':
    |
    |    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -
  > |    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(
    |      EXEC_SEL, msg.sender, _exec_id, _calldata
    |    )) == false) {
  at RegistryExec.sol(279)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'RegistryExec':
    |
    |    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -
  > |    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(
    |      EXEC_SEL, msg.sender, _exec_id, _calldata
    |    )) == false) {
  at RegistryExec.sol(279)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'RegistryExec':
    |      checkErrors(_exec_id);
    |      // Return unspent wei to sender
  > |      address(msg.sender).transfer(address(this).balance);
    |      return false;
    |    }
  at RegistryExec.sol(285)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'RegistryExec':
    |
    |    // Transfer any returned wei back to the sender
  > |    address(msg.sender).transfer(address(this).balance);
    |  }
    |
  at RegistryExec.sol(295)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |pragma solidity ^0.4.23;
    |
  > |interface StorageInterface {
    |  function getTarget(bytes32 exec_id, bytes4 selector)
    |      external view returns (address implementation);
  at RegistryExec.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    require(app_storage == 0, "ScriptExec already configured");
    |    require(_app_storage != 0, 'Invalid input');
  > |    exec_admin = _exec_admin;
    |    app_storage = _app_storage;
    |    provider = _provider;
  at RegistryExec.sol(72)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    require(_app_storage != 0, 'Invalid input');
    |    exec_admin = _exec_admin;
  > |    app_storage = _app_storage;
    |    provider = _provider;
    |
  at RegistryExec.sol(73)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    exec_admin = _exec_admin;
    |    app_storage = _app_storage;
  > |    provider = _provider;
    |
    |    if (exec_admin == 0)
  at RegistryExec.sol(74)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |
    |    if (exec_admin == 0)
  > |      exec_admin = msg.sender;
    |  }
    |
  at RegistryExec.sol(77)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    );
    |    // Set various app metadata values -
  > |    deployed_by[exec_id] = msg.sender;
    |    app_instances[_app_name].push(exec_id);
    |    Instance memory inst = Instance(
  at RegistryExec.sol(159)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |      provider, registry_exec_id, exec_id, _app_name, version
    |    );
  > |    instance_info[exec_id] = inst;
    |    deployed_instances[msg.sender].push(inst);
    |    // Emit event -
  at RegistryExec.sol(164)

[31mViolation[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    require(latest_version != 0, 'invalid latest version');
    |    // Set current version -
  > |    instance_info[_exec_id].version_name = latest_version;
    |  }
    |
  at RegistryExec.sol(441)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    // Set various app metadata values -
    |    deployed_by[exec_id] = msg.sender;
  > |    app_instances[_app_name].push(exec_id);
    |    Instance memory inst = Instance(
    |      provider, registry_exec_id, exec_id, _app_name, version
  at RegistryExec.sol(160)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |  */
    |  function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {
  > |    registry_exec_id = _exec_id;
    |  }
    |
  at RegistryExec.sol(177)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |  */
    |  function setProvider(address _provider) public onlyAdmin() {
  > |    provider = _provider;
    |  }
    |
  at RegistryExec.sol(185)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |  function setAdmin(address _admin) public onlyAdmin() {
    |    require(_admin != 0);
  > |    exec_admin = _admin;
    |  }
    |
  at RegistryExec.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    // If there is not already a default registry exec id set, set it
    |    if (registry_exec_id == 0)
  > |      registry_exec_id = exec_id;
    |
    |    // Create Registry struct in memory -
  at RegistryExec.sol(328)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |
    |    // Set various app metadata values -
  > |    deployed_by[exec_id] = msg.sender;
    |    registry_instance_info[exec_id] = reg;
    |    deployed_registry_instances[msg.sender].push(reg);
  at RegistryExec.sol(334)

[33mWarning[0m for UnrestrictedWrite in contract 'RegistryExec':
    |    // Set various app metadata values -
    |    deployed_by[exec_id] = msg.sender;
  > |    registry_instance_info[exec_id] = reg;
    |    deployed_registry_instances[msg.sender].push(reg);
    |    // Emit event -
  at RegistryExec.sol(335)

[FILE] BBFarm.sol
Processing contract: BBFarm.sol:BBFarm
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BBFarmEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BBFarmIface
Processing contract: BBFarm.sol:BBLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BPackedUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BytesLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:CommAuctionIface
Processing contract: BBFarm.sol:CommunityAuctionSimple
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:ENSIface
Processing contract: BBFarm.sol:ERC20Interface
Processing contract: BBFarm.sol:EnsOwnerProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:IxBackendIface
Processing contract: BBFarm.sol:IxIface
Processing contract: BBFarm.sol:IxLib
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:IxPaymentsIface
Processing contract: BBFarm.sol:PublicResolver
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVBallotConsts
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVIndex
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVIndexBackend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVPayments
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SvEnsIface
Processing contract: BBFarm.sol:controlledIface
Processing contract: BBFarm.sol:hasAdmins
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:hasVersion
Processing contract: BBFarm.sol:ixBackendEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:ixEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:ixPaymentEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:payoutAllC
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:payoutAllCSettable
Processing contract: BBFarm.sol:permissioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:safeSend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:upgradePtr
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function logSponsorship(DB storage db, uint value) internal {
  > |        db.sponsors.push(Sponsor(msg.sender, value));
    |    }
    |
  at BBFarm.sol(181)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // we need to call the init functions on our libraries
    |        getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));
  > |        nBallots += 1;
    |
    |        emit BallotCreatedWithID(ballotId);
  at BBFarm.sol(1025)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function revealSeckey(DB storage db, bytes32 sk) internal {
  > |        db.ballotEncryptionSeckey = sk;
    |        emit SeckeyRevealed(sk);
    |    }
  at BBFarm.sol(284)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLib.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.deprecated = true;
    |    }
    |
  at BBFarm.sol(1131)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLib.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.ballotOwner = newOwner;
    |    }
    |}
  at BBFarm.sol(1137)

[31mViolation[0m for LockedEther in contract 'BBLib':
    |}
    |
  > |library BBLib {
    |    using BytesLib for bytes;
    |
  at BBFarm.sol(10)

[31mViolation[0m for UnrestrictedWrite in contract 'BBLib':
    |        // any future votes.
    |        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");
  > |        db.sequenceNumber[voter] = sequence;
    |    }
    |
  at BBFarm.sol(271)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |}
    |
  > |library BBLib {
    |    using BytesLib for bytes;
    |
  at BBFarm.sol(10)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        require(db.specHash == bytes32(0), "b-exists");
    |
  > |        db.index = ix;
    |        db.ballotOwner = ballotOwner;
    |
  at BBFarm.sol(137)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        db.index = ix;
  > |        db.ballotOwner = ballotOwner;
    |
    |        uint64 startTs;
  at BBFarm.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        }
    |        require(_specHash != bytes32(0), "null-specHash");
  > |        db.specHash = _specHash;
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  at BBFarm.sol(166)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        db.specHash = _specHash;
    |
  > |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
    |        db.creationTs = now;
    |
  at BBFarm.sol(168)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  > |        db.creationTs = now;
    |
    |        if (extraData != bytes16(0)) {
  at BBFarm.sol(169)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        if (extraData != bytes16(0)) {
  > |            db.extraData = extraData;
    |        }
    |
  at BBFarm.sol(172)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        id = db.nVotesCast;
  > |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
    |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
  at BBFarm.sol(256)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
  > |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
    |        if (extra.length > 0) {
    |            db.votes[id].extra = extra;
  at BBFarm.sol(258)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |            db.votes[id].extra = extra;
    |        }
  > |        db.nVotesCast += 1;
    |        emit SuccessfulVote(sender, id);
    |    }
  at BBFarm.sol(262)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        uint64 sTs;
    |        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);
  > |        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);
    |    }
    |
  at BBFarm.sol(280)

[31mViolation[0m for MissingInputValidation in contract 'CanReclaimToken':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setPriceWei(uint newPrice) only_owner() external {
  > |        commBallotPriceWei = newPrice;
    |    }
    |}
  at BBFarm.sol(616)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAddr(address addr) only_admin() external {
    |        _setAddr(addr);
    |    }
  at BBFarm.sol(711)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToENS(bytes data) only_owner() external {
    |        require(address(ens).call(data), "fwding to ens failed");
    |    }
  at BBFarm.sol(723)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToResolver(bytes data) only_owner() external {
    |        require(address(resolver).call(data), "fwding to resolver failed");
    |    }
  at BBFarm.sol(727)

[33mWarning[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[33mWarning[0m for TODAmount in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBFarm.sol(716)

[33mWarning[0m for TODReceiver in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBFarm.sol(716)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBFarm.sol(716)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[31mViolation[0m for LockedEther in contract 'IxLib':
    |}
    |
  > |library IxLib {
    |    /**
    |     * Usage: `using IxLib for IxIface`
  at BBFarm.sol(379)

[31mViolation[0m for MissingInputValidation in contract 'IxLib':
    |    }
    |
  > |    function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {
    |        return ix.getBackend().getDArbitraryData(democHash, key);
    |    }
  at BBFarm.sol(472)

[31mViolation[0m for LockedEther in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBFarm.sol(2287)

[31mViolation[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBFarm.sol(2287)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBFarm.sol(2287)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setAddr(bytes32 node, address addr) public only_owner(node) {
  > |        records[node].addr = addr;
    |        emit AddrChanged(node, addr);
    |    }
  at BBFarm.sol(2342)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {
  > |        records[node].content = hash;
    |        emit ContentChanged(node, hash);
    |    }
  at BBFarm.sol(2355)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
  > |        records[node].pubkey = PublicKey(x, y);
    |        emit PubkeyChanged(node, x, y);
    |    }
  at BBFarm.sol(2393)

[31mViolation[0m for DAO in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        ensOwnerPx.setAddr(nextSC);
    |        ensOwnerPx.upgradeMeAdmin(nextSC);
  > |        commAuction.upgradeMe(nextSC);
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  at BBFarm.sol(1251)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  > |            bbFarms[i].upgradeMe(nextSC);
    |        }
    |    }
  at BBFarm.sol(1254)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        require(bbNamespace != bytes4(0), "bb-farm-namespace");
  > |        require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), "bb-namespace-used");
    |
    |        bbFarmId = _addBBFarm(bbNamespace, bbFarm);
  at BBFarm.sol(1273)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        }
    |
  > |        ballotId = _bbFarm.initBallot(
    |            specHash,
    |            packed,
  at BBFarm.sol(1451)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        doSafeSend(msg.sender, msg.value - price);
    |
  > |        bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);
    |        require(canProceed, "!cb-enabled");
    |
  at BBFarm.sol(1472)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);
  > |        commAuction.noteBallotDeployed(democHash);
    |
    |        emit CommunityBallot(democHash, ballotId);
  at BBFarm.sol(1478)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |    function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {
    |        // backend handles events
  > |        backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);
    |    }
    |
  at BBFarm.sol(1494)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if the ballot is marked as official require the democracy is paid up to
    |        // some relative amount - exclude NFP accounts from this check
  > |        uint secsLeft = payments.getSecondsRemaining(democHash);
    |        // must be positive due to ending in future check
    |        uint256 secsToEndTime = endTime - now;
  at BBFarm.sol(1501)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if we're an official ballot and the democ is basic, ensure the democ
    |        // isn't over the ballots/mo limit
  > |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
  at BBFarm.sol(1511)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // isn't over the ballots/mo limit
    |        if (payments.getPremiumStatus(democHash) == false) {
  > |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
  at BBFarm.sol(1512)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
  > |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
    |            // if the democ has less than nBallotsAllowed then it's guarenteed to be okay
  at BBFarm.sol(1513)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // nBallotsBasicCounted-X. There would thus be (X-1) ballots that are _more_
    |            // recent than the one we're looking for.
  > |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
    |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
  at BBFarm.sol(1528)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // recent than the one we're looking for.
    |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
  > |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
    |            // if the earlyBallot was created more than 30 days in the past we should
  at BBFarm.sol(1529)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // where the Nth most recent ballot was created within the last 30 days.)
    |            // We should now check for payment
  > |            uint extraBallotFee = payments.getBasicExtraBallotFeeWei();
    |            require(msg.value >= extraBallotFee, "!extra-b-fee");
    |
  at BBFarm.sol(1541)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBFarm.sol(1331)

[31mViolation[0m for TODReceiver in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBFarm.sol(1331)

[33mWarning[0m for TODReceiver in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBFarm.sol(1331)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for DAO in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for LockedEther in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at BBFarm.sol(1605)

[33mWarning[0m for TODAmount in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODReceiver in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at BBFarm.sol(1605)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");
    |        // set owner and editor
  > |        d.owner = newOwner;
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  at BBFarm.sol(1739)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // set owner and editor
    |        d.owner = newOwner;
  > |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
    |        d.erc20OwnerClaimDisabled = true;
  at BBFarm.sol(1740)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  > |        d.erc20OwnerClaimDisabled = true;
    |        emit DemocOwnerSet(democHash, newOwner);
    |        emit DemocClaimed(democHash);
  at BBFarm.sol(1742)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {
    |        Democ storage d = democs[democHash];
  > |        d.editors[d.editorEpoch][editor] = canEdit;
    |        emit DemocEditorSet(democHash, editor, canEdit);
    |    }
  at BBFarm.sol(1749)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDNoEditors(bytes32 democHash) only_editors() external {
  > |        democs[democHash].editorEpoch += 1;
    |        emit DemocEditorsWiped(democHash);
    |    }
  at BBFarm.sol(1754)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
  > |        democs[democHash].erc20 = newErc20;
    |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
  at BBFarm.sol(1759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
    |        democs[democHash].erc20 = newErc20;
  > |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
    |    }
  at BBFarm.sol(1760)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {
    |        uint catId = democCategories[democHash].nCategories;
  > |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  at BBFarm.sol(1778)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
  > |            democCategories[democHash].categories[catId].hasParent = true;
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  at BBFarm.sol(1780)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  > |            democCategories[democHash].categories[catId].parent = parent;
    |        }
    |        democCategories[democHash].nCategories += 1;
  at BBFarm.sol(1781)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  > |        democCategories[democHash].nCategories += 1;
    |        emit DemocCatAdded(democHash, catId);
    |    }
  at BBFarm.sol(1783)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {
  > |        democCategories[democHash].categories[catId].deprecated = true;
    |        emit DemocCatDeprecated(democHash, catId);
    |    }
  at BBFarm.sol(1788)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {
  > |        democs[democHash].communityBallotsDisabled = !enabled;
    |        emit DemocCommunityBallotsEnabled(democHash, enabled);
    |    }
  at BBFarm.sol(1793)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {
  > |        democs[democHash].erc20OwnerClaimDisabled = true;
    |        emit DemocErc20OwnerClaimDisabled(democHash);
    |    }
  at BBFarm.sol(1798)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |        uint localBallotId = democs[democHash].allBallots.length;
  > |        democs[democHash].allBallots.push(ballotId);
    |
    |        // do this for anything that doesn't qualify as a community ballot
  at BBFarm.sol(1809)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // do this for anything that doesn't qualify as a community ballot
    |        if (countTowardsLimit) {
  > |            democs[democHash].includedBasicBallots.push(ballotId);
    |        }
    |
  at BBFarm.sol(1813)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {
  > |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
    |        d.erc20 = erc20;
  at BBFarm.sol(1682)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
  > |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
    |            d.erc20OwnerClaimDisabled = true;
  at BBFarm.sol(1684)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
  > |            d.erc20OwnerClaimDisabled = true;
    |        }
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
  at BBFarm.sol(1686)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
  > |        democPrefixToHash[bytes13(democHash)] = democHash;
    |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
  at BBFarm.sol(1690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
    |        democPrefixToHash[bytes13(democHash)] = democHash;
  > |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
    |        emit NewDemoc(democHash);
  at BBFarm.sol(1691)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        Democ storage d = democs[democHash];
    |        uint epoch = d.editorEpoch;
  > |        d.owner = newOwner;
    |        // unset prev owner as editor - does little if one was not set
    |        d.editors[epoch][d.owner] = false;
  at BBFarm.sol(1722)

[33mWarning[0m for DAO in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at BBFarm.sol(758)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(766)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(773)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at BBFarm.sol(779)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    // contracts are compromised? (e.g. by a leaked privkey)
    |    address public emergencyAdmin;
  > |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
    |        owner = newOwner;
  at BBFarm.sol(1993)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function doFreeExtension(bytes32 democHash) external {
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  at BBFarm.sol(2064)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
    |        accounts[democHash].isPremium = false;
  at BBFarm.sol(2071)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeToPremium(bytes32 democHash) only_editors() external {
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  at BBFarm.sol(2088)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account status - getters */
    |
  > |    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].paidUpTill >= now;
    |    }
  at BBFarm.sol(2106)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {
    |        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);
    |    }
  at BBFarm.sol(2110)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getPremiumStatus(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].isPremium;
    |    }
  at BBFarm.sol(2114)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getFreeExtension(bytes32 democHash) external view returns (bool) {
    |        return freeExtension[democHash];
    |    }
  at BBFarm.sol(2118)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {
    |        isPremium = accounts[democHash].isPremium;
    |        lastPaymentTs = accounts[democHash].lastPaymentTs;
  at BBFarm.sol(2122)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getDenyPremium(bytes32 democHash) external view returns (bool) {
    |        return denyPremium[democHash];
    |    }
  at BBFarm.sol(2129)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin utils for accounts */
    |
  > |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
    |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
  at BBFarm.sol(2135)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin setters global */
    |
  > |    function setPayTo(address newPayTo) only_owner() external {
    |        _setPayTo(newPayTo);
    |        emit SetPayTo(newPayTo);
  at BBFarm.sol(2143)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinorEditsAddr(address a) only_owner() external {
    |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
  at BBFarm.sol(2148)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
    |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
  at BBFarm.sol(2153)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
    |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
  at BBFarm.sol(2158)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setPremiumMultiplier(uint8 m) only_owner() external {
    |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
  at BBFarm.sol(2163)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
    |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
  at BBFarm.sol(2168)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
    |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
  at BBFarm.sol(2173)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
    |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
  at BBFarm.sol(2178)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
    |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
  at BBFarm.sol(2183)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account management */
    |
  > |    function payForDemocracy(bytes32 democHash) external payable {
    |        require(msg.value > 0, "need to send some ether to make payment");
    |
  at BBFarm.sol(2046)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBFarm.sol(2061)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBFarm.sol(2061)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBFarm.sol(2061)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at BBFarm.sol(526)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        }
    |
  > |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
    |        accounts[democHash].lastPaymentTs = now;
    |    }
  at BBFarm.sol(2021)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
  > |        accounts[democHash].lastPaymentTs = now;
    |    }
    |
  at BBFarm.sol(2022)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            _modAccountBalance(democHash, additionalSeconds);
    |        }
  > |        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  at BBFarm.sol(2058)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  > |        accounts[democHash].paidUpTill = newPaidUpTill;
    |        emit FreeExtension(democHash);
    |    }
  at BBFarm.sol(2067)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
  > |        accounts[democHash].isPremium = false;
    |        // convert premium minutes to basic
    |        uint paidTill = accounts[democHash].paidUpTill;
  at BBFarm.sol(2073)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");
    |            timeRemaining *= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        emit DowngradeToBasic(democHash);
  at BBFarm.sol(2083)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  > |        accounts[democHash].isPremium = true;
    |        // convert basic minutes to premium minutes
    |        uint paidTill = accounts[democHash].paidUpTill;
  at BBFarm.sol(2091)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (timeRemaining > 0) {
    |            timeRemaining /= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        accounts[democHash].lastUpgradeTs = now;
  at BBFarm.sol(2098)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
  > |        accounts[democHash].lastUpgradeTs = now;
    |        emit UpgradedToPremium(democHash);
    |    }
  at BBFarm.sol(2100)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
  > |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
    |        emit GrantedAccountTime(democHash, additionalSeconds, ref);
    |    }
  at BBFarm.sol(2137)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at BBFarm.sol(526)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
  > |        owner = newOwner;
    |    }
    |    /* END BREAK GLASS */
  at BBFarm.sol(1995)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinorEditsAddr(address a) only_owner() external {
  > |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
    |    }
  at BBFarm.sol(2149)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
  > |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
    |    }
  at BBFarm.sol(2154)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
  > |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
    |    }
  at BBFarm.sol(2159)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPremiumMultiplier(uint8 m) only_owner() external {
  > |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
    |    }
  at BBFarm.sol(2164)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
  > |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
    |    }
  at BBFarm.sol(2169)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
  > |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
    |    }
  at BBFarm.sol(2174)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
  > |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
    |    }
  at BBFarm.sol(2179)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
  > |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
    |    }
  at BBFarm.sol(2184)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[33mWarning[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[31mViolation[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODReceiver in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at BBFarm.sol(758)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(766)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(773)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at BBFarm.sol(779)

[33mWarning[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[FILE] BBLibV7.sol
Processing contract: BBLibV7.sol:BBFarm
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:BBFarmEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:BBFarmIface
Processing contract: BBLibV7.sol:BBLibV7
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:BPackedUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:BytesLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:CommAuctionIface
Processing contract: BBLibV7.sol:CommunityAuctionSimple
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:ENSIface
Processing contract: BBLibV7.sol:ERC20Interface
Processing contract: BBLibV7.sol:EnsOwnerProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:IxBackendIface
Processing contract: BBLibV7.sol:IxIface
Processing contract: BBLibV7.sol:IxLib
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:IxPaymentsIface
Processing contract: BBLibV7.sol:PublicResolver
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:SVBallotConsts
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:SVIndex
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:SVIndexBackend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:SVPayments
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:SvEnsIface
Processing contract: BBLibV7.sol:controlledIface
Processing contract: BBLibV7.sol:hasAdmins
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:hasVersion
Processing contract: BBLibV7.sol:ixBackendEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:ixEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:ixPaymentEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:payoutAllC
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:payoutAllCSettable
Processing contract: BBLibV7.sol:permissioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:safeSend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBLibV7.sol:upgradePtr
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for TODAmount in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function logSponsorship(DB storage db, uint value) internal {
  > |        db.sponsors.push(Sponsor(msg.sender, value));
    |    }
    |
  at BBLibV7.sol(186)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBLibV7.sol(531)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBLibV7.sol(536)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBLibV7.sol(789)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBLibV7.sol(797)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBLibV7.sol(798)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBLibV7.sol(805)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // we need to call the init functions on our libraries
    |        getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));
  > |        nBallots += 1;
    |
    |        emit BallotCreatedWithID(ballotId);
  at BBLibV7.sol(1069)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function revealSeckey(DB storage db, bytes32 sk) internal {
  > |        db.ballotEncryptionSeckey = sk;
    |        emit SeckeyRevealed(sk);
    |    }
  at BBLibV7.sol(314)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBLibV7.sol(711)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBLibV7.sol(719)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBLibV7.sol(720)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBLibV7.sol(815)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLibV7.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.deprecated = true;
    |    }
    |
  at BBLibV7.sol(1184)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLibV7.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.ballotOwner = newOwner;
    |    }
    |}
  at BBLibV7.sol(1190)

[31mViolation[0m for LockedEther in contract 'BBLibV7':
    |}
    |
  > |library BBLibV7 {
    |    using BytesLib for bytes;
    |
  at BBLibV7.sol(13)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |}
    |
  > |library BBLibV7 {
    |    using BytesLib for bytes;
    |
  at BBLibV7.sol(13)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |        require(db.specHash == bytes32(0), "b-exists");
    |
  > |        db.index = ix;
    |        db.ballotOwner = ballotOwner;
    |
  at BBLibV7.sol(142)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |
    |        db.index = ix;
  > |        db.ballotOwner = ballotOwner;
    |
    |        uint64 startTs;
  at BBLibV7.sol(143)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |        }
    |        require(_specHash != bytes32(0), "null-specHash");
  > |        db.specHash = _specHash;
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  at BBLibV7.sol(171)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |        db.specHash = _specHash;
    |
  > |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
    |        db.creationTs = now;
    |
  at BBLibV7.sol(173)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  > |        db.creationTs = now;
    |
    |        if (extraData != bytes16(0)) {
  at BBLibV7.sol(174)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |
    |        if (extraData != bytes16(0)) {
  > |            db.extraData = extraData;
    |        }
    |
  at BBLibV7.sol(177)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |    function _addVoteAlways(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {
    |        id = db.nVotesCast;
  > |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
    |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
  at BBLibV7.sol(286)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
  > |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
    |        if (extra.length > 0) {
    |            db.votes[id].extra = extra;
  at BBLibV7.sol(288)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |            db.votes[id].extra = extra;
    |        }
  > |        db.nVotesCast += 1;
    |        emit SuccessfulVote(sender, id);
    |    }
  at BBLibV7.sol(292)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |        // any future votes.
    |        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");
  > |        db.sequenceNumber[voter] = sequence;
    |    }
    |
  at BBLibV7.sol(301)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLibV7':
    |        uint64 sTs;
    |        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);
  > |        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);
    |    }
    |
  at BBLibV7.sol(310)

[31mViolation[0m for MissingInputValidation in contract 'CanReclaimToken':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBLibV7.sol(596)

[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setPriceWei(uint newPrice) only_owner() external {
  > |        commBallotPriceWei = newPrice;
    |    }
    |}
  at BBLibV7.sol(646)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBLibV7.sol(596)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBLibV7.sol(675)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBLibV7.sol(694)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAddr(address addr) only_admin() external {
    |        _setAddr(addr);
    |    }
  at BBLibV7.sol(741)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToENS(bytes data) only_owner() external {
    |        require(address(ens).call(data), "fwding to ens failed");
    |    }
  at BBLibV7.sol(753)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToResolver(bytes data) only_owner() external {
    |        require(address(resolver).call(data), "fwding to resolver failed");
    |    }
  at BBLibV7.sol(757)

[33mWarning[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBLibV7.sol(687)

[33mWarning[0m for TODAmount in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBLibV7.sol(746)

[33mWarning[0m for TODReceiver in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBLibV7.sol(746)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBLibV7.sol(746)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBLibV7.sol(711)

[31mViolation[0m for LockedEther in contract 'IxLib':
    |}
    |
  > |library IxLib {
    |    /**
    |     * Usage: `using IxLib for IxIface`
  at BBLibV7.sol(409)

[31mViolation[0m for MissingInputValidation in contract 'IxLib':
    |    }
    |
  > |    function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {
    |        return ix.getBackend().getDArbitraryData(democHash, key);
    |    }
  at BBLibV7.sol(502)

[31mViolation[0m for LockedEther in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBLibV7.sol(2340)

[31mViolation[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBLibV7.sol(2340)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBLibV7.sol(2340)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setAddr(bytes32 node, address addr) public only_owner(node) {
  > |        records[node].addr = addr;
    |        emit AddrChanged(node, addr);
    |    }
  at BBLibV7.sol(2395)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {
  > |        records[node].content = hash;
    |        emit ContentChanged(node, hash);
    |    }
  at BBLibV7.sol(2408)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
  > |        records[node].pubkey = PublicKey(x, y);
    |        emit PubkeyChanged(node, x, y);
    |    }
  at BBLibV7.sol(2446)

[31mViolation[0m for DAO in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        doUpgradeInternal(nextSC);
    |        backend.upgradeMe(nextSC);
  > |        payments.upgradeMe(nextSC);
    |        ensOwnerPx.setAddr(nextSC);
    |        ensOwnerPx.upgradeMeAdmin(nextSC);
  at BBLibV7.sol(1301)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        ensOwnerPx.setAddr(nextSC);
    |        ensOwnerPx.upgradeMeAdmin(nextSC);
  > |        commAuction.upgradeMe(nextSC);
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  at BBLibV7.sol(1304)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  > |            bbFarms[i].upgradeMe(nextSC);
    |        }
    |    }
  at BBLibV7.sol(1307)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        require(bbNamespace != bytes4(0), "bb-farm-namespace");
  > |        require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), "bb-namespace-used");
    |
    |        bbFarmId = _addBBFarm(bbNamespace, bbFarm);
  at BBLibV7.sol(1326)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        }
    |
  > |        ballotId = _bbFarm.initBallot(
    |            specHash,
    |            packed,
  at BBLibV7.sol(1504)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        doSafeSend(msg.sender, msg.value - price);
    |
  > |        bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);
    |        require(canProceed, "!cb-enabled");
    |
  at BBLibV7.sol(1525)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);
  > |        commAuction.noteBallotDeployed(democHash);
    |
    |        emit CommunityBallot(democHash, ballotId);
  at BBLibV7.sol(1531)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |    function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {
    |        // backend handles events
  > |        backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);
    |    }
    |
  at BBLibV7.sol(1547)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if the ballot is marked as official require the democracy is paid up to
    |        // some relative amount - exclude NFP accounts from this check
  > |        uint secsLeft = payments.getSecondsRemaining(democHash);
    |        // must be positive due to ending in future check
    |        uint256 secsToEndTime = endTime - now;
  at BBLibV7.sol(1554)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if we're an official ballot and the democ is basic, ensure the democ
    |        // isn't over the ballots/mo limit
  > |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
  at BBLibV7.sol(1564)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // isn't over the ballots/mo limit
    |        if (payments.getPremiumStatus(democHash) == false) {
  > |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
  at BBLibV7.sol(1565)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
  > |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
    |            // if the democ has less than nBallotsAllowed then it's guarenteed to be okay
  at BBLibV7.sol(1566)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // nBallotsBasicCounted-X. There would thus be (X-1) ballots that are _more_
    |            // recent than the one we're looking for.
  > |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
    |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
  at BBLibV7.sol(1581)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // recent than the one we're looking for.
    |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
  > |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
    |            // if the earlyBallot was created more than 30 days in the past we should
  at BBLibV7.sol(1582)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // where the Nth most recent ballot was created within the last 30 days.)
    |            // We should now check for payment
  > |            uint extraBallotFee = payments.getBasicExtraBallotFeeWei();
    |            require(msg.value >= extraBallotFee, "!extra-b-fee");
    |
  at BBLibV7.sol(1594)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBLibV7.sol(1384)

[31mViolation[0m for TODReceiver in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBLibV7.sol(1384)

[33mWarning[0m for TODReceiver in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBLibV7.sol(1384)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBLibV7.sol(531)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBLibV7.sol(536)

[31mViolation[0m for DAO in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for LockedEther in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at BBLibV7.sol(1658)

[33mWarning[0m for TODAmount in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for TODReceiver in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBLibV7.sol(531)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBLibV7.sol(536)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBLibV7.sol(789)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBLibV7.sol(797)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBLibV7.sol(798)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBLibV7.sol(805)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at BBLibV7.sol(1658)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");
    |        // set owner and editor
  > |        d.owner = newOwner;
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  at BBLibV7.sol(1792)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // set owner and editor
    |        d.owner = newOwner;
  > |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
    |        d.erc20OwnerClaimDisabled = true;
  at BBLibV7.sol(1793)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  > |        d.erc20OwnerClaimDisabled = true;
    |        emit DemocOwnerSet(democHash, newOwner);
    |        emit DemocClaimed(democHash);
  at BBLibV7.sol(1795)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {
    |        Democ storage d = democs[democHash];
  > |        d.editors[d.editorEpoch][editor] = canEdit;
    |        emit DemocEditorSet(democHash, editor, canEdit);
    |    }
  at BBLibV7.sol(1802)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDNoEditors(bytes32 democHash) only_editors() external {
  > |        democs[democHash].editorEpoch += 1;
    |        emit DemocEditorsWiped(democHash);
    |    }
  at BBLibV7.sol(1807)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
  > |        democs[democHash].erc20 = newErc20;
    |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
  at BBLibV7.sol(1812)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
    |        democs[democHash].erc20 = newErc20;
  > |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
    |    }
  at BBLibV7.sol(1813)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {
    |        uint catId = democCategories[democHash].nCategories;
  > |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  at BBLibV7.sol(1831)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
  > |            democCategories[democHash].categories[catId].hasParent = true;
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  at BBLibV7.sol(1833)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  > |            democCategories[democHash].categories[catId].parent = parent;
    |        }
    |        democCategories[democHash].nCategories += 1;
  at BBLibV7.sol(1834)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  > |        democCategories[democHash].nCategories += 1;
    |        emit DemocCatAdded(democHash, catId);
    |    }
  at BBLibV7.sol(1836)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {
  > |        democCategories[democHash].categories[catId].deprecated = true;
    |        emit DemocCatDeprecated(democHash, catId);
    |    }
  at BBLibV7.sol(1841)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {
  > |        democs[democHash].communityBallotsDisabled = !enabled;
    |        emit DemocCommunityBallotsEnabled(democHash, enabled);
    |    }
  at BBLibV7.sol(1846)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {
  > |        democs[democHash].erc20OwnerClaimDisabled = true;
    |        emit DemocErc20OwnerClaimDisabled(democHash);
    |    }
  at BBLibV7.sol(1851)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |        uint localBallotId = democs[democHash].allBallots.length;
  > |        democs[democHash].allBallots.push(ballotId);
    |
    |        // do this for anything that doesn't qualify as a community ballot
  at BBLibV7.sol(1862)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // do this for anything that doesn't qualify as a community ballot
    |        if (countTowardsLimit) {
  > |            democs[democHash].includedBasicBallots.push(ballotId);
    |        }
    |
  at BBLibV7.sol(1866)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBLibV7.sol(711)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBLibV7.sol(719)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBLibV7.sol(720)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBLibV7.sol(815)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {
  > |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
    |        d.erc20 = erc20;
  at BBLibV7.sol(1735)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
  > |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
    |            d.erc20OwnerClaimDisabled = true;
  at BBLibV7.sol(1737)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
  > |            d.erc20OwnerClaimDisabled = true;
    |        }
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
  at BBLibV7.sol(1739)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
  > |        democPrefixToHash[bytes13(democHash)] = democHash;
    |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
  at BBLibV7.sol(1743)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
    |        democPrefixToHash[bytes13(democHash)] = democHash;
  > |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
    |        emit NewDemoc(democHash);
  at BBLibV7.sol(1744)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        Democ storage d = democs[democHash];
    |        uint epoch = d.editorEpoch;
  > |        d.owner = newOwner;
    |        // unset prev owner as editor - does little if one was not set
    |        d.editors[epoch][d.owner] = false;
  at BBLibV7.sol(1775)

[31mViolation[0m for DAO in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for DAO in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBLibV7.sol(596)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBLibV7.sol(675)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBLibV7.sol(694)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at BBLibV7.sol(788)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at BBLibV7.sol(796)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at BBLibV7.sol(803)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at BBLibV7.sol(809)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    // contracts are compromised? (e.g. by a leaked privkey)
    |    address public emergencyAdmin;
  > |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
    |        owner = newOwner;
  at BBLibV7.sol(2046)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account management */
    |
  > |    function payForDemocracy(bytes32 democHash) external payable {
    |        require(msg.value > 0, "need to send some ether to make payment");
    |
  at BBLibV7.sol(2099)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function doFreeExtension(bytes32 democHash) external {
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  at BBLibV7.sol(2117)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
    |        accounts[democHash].isPremium = false;
  at BBLibV7.sol(2124)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeToPremium(bytes32 democHash) only_editors() external {
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  at BBLibV7.sol(2141)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account status - getters */
    |
  > |    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].paidUpTill >= now;
    |    }
  at BBLibV7.sol(2159)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {
    |        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);
    |    }
  at BBLibV7.sol(2163)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getPremiumStatus(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].isPremium;
    |    }
  at BBLibV7.sol(2167)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getFreeExtension(bytes32 democHash) external view returns (bool) {
    |        return freeExtension[democHash];
    |    }
  at BBLibV7.sol(2171)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {
    |        isPremium = accounts[democHash].isPremium;
    |        lastPaymentTs = accounts[democHash].lastPaymentTs;
  at BBLibV7.sol(2175)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getDenyPremium(bytes32 democHash) external view returns (bool) {
    |        return denyPremium[democHash];
    |    }
  at BBLibV7.sol(2182)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin utils for accounts */
    |
  > |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
    |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
  at BBLibV7.sol(2188)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin setters global */
    |
  > |    function setPayTo(address newPayTo) only_owner() external {
    |        _setPayTo(newPayTo);
    |        emit SetPayTo(newPayTo);
  at BBLibV7.sol(2196)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinorEditsAddr(address a) only_owner() external {
    |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
  at BBLibV7.sol(2201)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
    |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
  at BBLibV7.sol(2206)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
    |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
  at BBLibV7.sol(2211)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setPremiumMultiplier(uint8 m) only_owner() external {
    |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
  at BBLibV7.sol(2216)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
    |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
  at BBLibV7.sol(2221)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
    |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
  at BBLibV7.sol(2226)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
    |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
  at BBLibV7.sol(2231)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
    |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
  at BBLibV7.sol(2236)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBLibV7.sol(687)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBLibV7.sol(2114)

[31mViolation[0m for TODReceiver in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBLibV7.sol(2114)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBLibV7.sol(2114)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBLibV7.sol(531)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBLibV7.sol(536)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at BBLibV7.sol(556)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBLibV7.sol(719)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBLibV7.sol(720)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBLibV7.sol(789)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBLibV7.sol(797)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBLibV7.sol(798)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBLibV7.sol(805)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        }
    |
  > |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
    |        accounts[democHash].lastPaymentTs = now;
    |    }
  at BBLibV7.sol(2074)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
  > |        accounts[democHash].lastPaymentTs = now;
    |    }
    |
  at BBLibV7.sol(2075)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            _modAccountBalance(democHash, additionalSeconds);
    |        }
  > |        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  at BBLibV7.sol(2111)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  > |        accounts[democHash].paidUpTill = newPaidUpTill;
    |        emit FreeExtension(democHash);
    |    }
  at BBLibV7.sol(2120)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
  > |        accounts[democHash].isPremium = false;
    |        // convert premium minutes to basic
    |        uint paidTill = accounts[democHash].paidUpTill;
  at BBLibV7.sol(2126)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");
    |            timeRemaining *= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        emit DowngradeToBasic(democHash);
  at BBLibV7.sol(2136)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  > |        accounts[democHash].isPremium = true;
    |        // convert basic minutes to premium minutes
    |        uint paidTill = accounts[democHash].paidUpTill;
  at BBLibV7.sol(2144)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (timeRemaining > 0) {
    |            timeRemaining /= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        accounts[democHash].lastUpgradeTs = now;
  at BBLibV7.sol(2151)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
  > |        accounts[democHash].lastUpgradeTs = now;
    |        emit UpgradedToPremium(democHash);
    |    }
  at BBLibV7.sol(2153)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
  > |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
    |        emit GrantedAccountTime(democHash, additionalSeconds, ref);
    |    }
  at BBLibV7.sol(2190)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at BBLibV7.sol(556)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBLibV7.sol(711)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBLibV7.sol(719)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBLibV7.sol(720)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBLibV7.sol(815)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
  > |        owner = newOwner;
    |    }
    |    /* END BREAK GLASS */
  at BBLibV7.sol(2048)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinorEditsAddr(address a) only_owner() external {
  > |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
    |    }
  at BBLibV7.sol(2202)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
  > |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
    |    }
  at BBLibV7.sol(2207)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
  > |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
    |    }
  at BBLibV7.sol(2212)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPremiumMultiplier(uint8 m) only_owner() external {
  > |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
    |    }
  at BBLibV7.sol(2217)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
  > |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
    |    }
  at BBLibV7.sol(2222)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
  > |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
    |    }
  at BBLibV7.sol(2227)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
  > |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
    |    }
  at BBLibV7.sol(2232)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
  > |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
    |    }
  at BBLibV7.sol(2237)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBLibV7.sol(596)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBLibV7.sol(675)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBLibV7.sol(694)

[33mWarning[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBLibV7.sol(687)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBLibV7.sol(711)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBLibV7.sol(596)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[31mViolation[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for TODAmount in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for TODReceiver in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBLibV7.sol(535)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBLibV7.sol(531)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBLibV7.sol(536)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBLibV7.sol(596)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBLibV7.sol(675)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBLibV7.sol(694)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at BBLibV7.sol(788)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at BBLibV7.sol(796)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at BBLibV7.sol(803)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at BBLibV7.sol(809)

[33mWarning[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBLibV7.sol(687)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBLibV7.sol(719)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBLibV7.sol(720)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBLibV7.sol(789)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBLibV7.sol(797)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBLibV7.sol(798)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBLibV7.sol(805)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |// (c) 2018 SecureVote (Exo One Pty Ltd)
    |
    |contract BBFarmEvents {
  at BBLibV7.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBLibV7.sol(597)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBLibV7.sol(700)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBLibV7.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBLibV7.sol(711)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBLibV7.sol(719)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBLibV7.sol(720)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBLibV7.sol(815)

[FILE] BancorBuyer.sol
Processing contract: BancorBuyer.sol:BancorBuyer
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BancorBuyer.sol:ERC20
Processing contract: BancorBuyer.sol:ERC20Basic
Processing contract: BancorBuyer.sol:IMultiToken
Processing contract: BancorBuyer.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        uint256 tokenBalance = token.balanceOf(this);
  > |        require(_exchange.call.value(_value)(_data));
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
    |        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
  at BancorBuyer.sol(186)

[31mViolation[0m for DAOConstantGas in contract 'BancorBuyer':
    |    function withdraw(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) external {
    |        if (_value > 0) {
  > |            _to.transfer(_value);
    |            balances[msg.sender] = balances[msg.sender].sub(_value);
    |        }
  at BancorBuyer.sol(137)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |    function sumWeightOfMultiToken(IMultiToken mtkn) public view returns(uint256 sumWeight) {
    |        for (uint i = mtkn.changeableTokenCount(); i > 0; i--) {
  > |            sumWeight += mtkn.weights(mtkn.tokens(i - 1));
    |        }
    |    }
  at BancorBuyer.sol(115)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |            uint256 tokenValue = _tokenValues[i];
    |
  > |            uint256 balance = token.balanceOf(this);
    |            token.transferFrom(msg.sender, this, tokenValue);
    |            require(token.balanceOf(this) == balance.add(tokenValue));
  at BancorBuyer.sol(128)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |
    |            uint256 balance = token.balanceOf(this);
  > |            token.transferFrom(msg.sender, this, tokenValue);
    |            require(token.balanceOf(this) == balance.add(tokenValue));
    |            tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue);
  at BancorBuyer.sol(129)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |            uint256 balance = token.balanceOf(this);
    |            token.transferFrom(msg.sender, this, tokenValue);
  > |            require(token.balanceOf(this) == balance.add(tokenValue));
    |            tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue);
    |        }
  at BancorBuyer.sol(130)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |            uint256 tokenValue = _tokenValues[i];
    |
  > |            uint256 tokenBalance = token.balanceOf(this);
    |            token.transfer(_to, tokenValue);
    |            require(token.balanceOf(this) == tokenBalance.sub(tokenValue));
  at BancorBuyer.sol(145)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |
    |            uint256 tokenBalance = token.balanceOf(this);
  > |            token.transfer(_to, tokenValue);
    |            require(token.balanceOf(this) == tokenBalance.sub(tokenValue));
    |            tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenValue);
  at BancorBuyer.sol(146)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |            uint256 tokenBalance = token.balanceOf(this);
    |            token.transfer(_to, tokenValue);
  > |            require(token.balanceOf(this) == tokenBalance.sub(tokenValue));
    |            tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenValue);
    |        }
  at BancorBuyer.sol(147)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |    {
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
  > |        uint256 tokenBalance = token.balanceOf(this);
    |        require(_exchange.call.value(_value)(_data));
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
  at BancorBuyer.sol(185)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        uint256 tokenBalance = token.balanceOf(this);
  > |        require(_exchange.call.value(_value)(_data));
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
    |        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
  at BancorBuyer.sol(186)

[31mViolation[0m for RepeatedCall in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
    |        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
  > |            .add(token.balanceOf(this).sub(tokenBalance));
    |    }
    |    
  at BancorBuyer.sol(189)

[33mWarning[0m for RepeatedCall in contract 'BancorBuyer':
    |    {
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
  > |        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
    |    }
    |    
  at BancorBuyer.sol(202)

[33mWarning[0m for RepeatedCall in contract 'BancorBuyer':
    |    {
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
  > |        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
    |        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
    |    }
  at BancorBuyer.sol(216)

[33mWarning[0m for RepeatedCall in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
  > |        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
    |    }
    |    
  at BancorBuyer.sol(217)

[33mWarning[0m for RepeatedCall in contract 'BancorBuyer':
    |    {
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
  > |        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
    |        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
    |        this.buyOne(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);
  at BancorBuyer.sol(232)

[33mWarning[0m for RepeatedCall in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
  > |        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
    |        this.buyOne(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);
    |    }
  at BancorBuyer.sol(233)

[33mWarning[0m for RepeatedCall in contract 'BancorBuyer':
    |        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
    |        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
  > |        this.buyOne(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);
    |    }
    |    
  at BancorBuyer.sol(234)

[33mWarning[0m for TODAmount in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        uint256 tokenBalance = token.balanceOf(this);
  > |        require(_exchange.call.value(_value)(_data));
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
    |        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
  at BancorBuyer.sol(186)

[33mWarning[0m for TODReceiver in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        uint256 tokenBalance = token.balanceOf(this);
  > |        require(_exchange.call.value(_value)(_data));
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
    |        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
  at BancorBuyer.sol(186)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BancorBuyer':
    |    function withdraw(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) external {
    |        if (_value > 0) {
  > |            _to.transfer(_value);
    |            balances[msg.sender] = balances[msg.sender].sub(_value);
    |        }
  at BancorBuyer.sol(137)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BancorBuyer':
    |        balances[msg.sender] = balances[msg.sender].add(msg.value);
    |        uint256 tokenBalance = token.balanceOf(this);
  > |        require(_exchange.call.value(_value)(_data));
    |        balances[msg.sender] = balances[msg.sender].sub(_value);
    |        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
  at BancorBuyer.sol(186)

[33mWarning[0m for UnrestrictedWrite in contract 'BancorBuyer':
    |    function deposit(address _beneficiary, address[] _tokens, uint256[] _tokenValues) payable external {
    |        if (msg.value > 0) {
  > |            balances[_beneficiary] = balances[_beneficiary].add(msg.value);
    |        }
    |
  at BancorBuyer.sol(121)

[33mWarning[0m for UnrestrictedWrite in contract 'BancorBuyer':
    |            token.transferFrom(msg.sender, this, tokenValue);
    |            require(token.balanceOf(this) == balance.add(tokenValue));
  > |            tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue);
    |        }
    |    }
  at BancorBuyer.sol(131)

[FILE] EnsOwnerProxy.sol
Processing contract: EnsOwnerProxy.sol:ENSIface
Processing contract: EnsOwnerProxy.sol:ERC20Interface
Processing contract: EnsOwnerProxy.sol:EnsOwnerProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:PublicResolver
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:SvEnsIface
Processing contract: EnsOwnerProxy.sol:controlledIface
Processing contract: EnsOwnerProxy.sol:hasAdmins
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:payoutAllC
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:payoutAllCSettable
Processing contract: EnsOwnerProxy.sol:permissioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:safeSend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EnsOwnerProxy.sol:upgradePtr
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at EnsOwnerProxy.sol(79)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at EnsOwnerProxy.sol(110)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at EnsOwnerProxy.sol(129)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAddr(address addr) only_admin() external {
    |        _setAddr(addr);
    |    }
  at EnsOwnerProxy.sol(176)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToENS(bytes data) only_owner() external {
    |        require(address(ens).call(data), "fwding to ens failed");
    |    }
  at EnsOwnerProxy.sol(188)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToResolver(bytes data) only_owner() external {
    |        require(address(resolver).call(data), "fwding to resolver failed");
    |    }
  at EnsOwnerProxy.sol(192)

[33mWarning[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at EnsOwnerProxy.sol(122)

[33mWarning[0m for TODAmount in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at EnsOwnerProxy.sol(181)

[33mWarning[0m for TODReceiver in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at EnsOwnerProxy.sol(181)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at EnsOwnerProxy.sol(181)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract safeSend {
    |    bool private txMutex3847834;
    |
  at EnsOwnerProxy.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at EnsOwnerProxy.sol(135)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at EnsOwnerProxy.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract safeSend {
    |    bool private txMutex3847834;
    |
  at EnsOwnerProxy.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at EnsOwnerProxy.sol(80)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at EnsOwnerProxy.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at EnsOwnerProxy.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at EnsOwnerProxy.sol(146)

[31mViolation[0m for LockedEther in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at EnsOwnerProxy.sol(346)

[31mViolation[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at EnsOwnerProxy.sol(346)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at EnsOwnerProxy.sol(346)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setAddr(bytes32 node, address addr) public only_owner(node) {
  > |        records[node].addr = addr;
    |        emit AddrChanged(node, addr);
    |    }
  at EnsOwnerProxy.sol(401)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {
  > |        records[node].content = hash;
    |        emit ContentChanged(node, hash);
    |    }
  at EnsOwnerProxy.sol(414)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
  > |        records[node].pubkey = PublicKey(x, y);
    |        emit PubkeyChanged(node, x, y);
    |    }
  at EnsOwnerProxy.sol(452)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at EnsOwnerProxy.sol(79)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at EnsOwnerProxy.sol(110)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at EnsOwnerProxy.sol(129)

[33mWarning[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at EnsOwnerProxy.sol(122)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract safeSend {
    |    bool private txMutex3847834;
    |
  at EnsOwnerProxy.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at EnsOwnerProxy.sol(135)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at EnsOwnerProxy.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract safeSend {
    |    bool private txMutex3847834;
    |
  at EnsOwnerProxy.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at EnsOwnerProxy.sol(80)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at EnsOwnerProxy.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at EnsOwnerProxy.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at EnsOwnerProxy.sol(146)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at EnsOwnerProxy.sol(79)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at EnsOwnerProxy.sol(80)

[31mViolation[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at EnsOwnerProxy.sol(18)

[33mWarning[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at EnsOwnerProxy.sol(18)

[33mWarning[0m for TODAmount in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at EnsOwnerProxy.sol(18)

[33mWarning[0m for TODReceiver in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at EnsOwnerProxy.sol(18)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at EnsOwnerProxy.sol(18)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at EnsOwnerProxy.sol(14)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at EnsOwnerProxy.sol(19)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at EnsOwnerProxy.sol(79)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at EnsOwnerProxy.sol(110)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at EnsOwnerProxy.sol(129)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at EnsOwnerProxy.sol(223)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at EnsOwnerProxy.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at EnsOwnerProxy.sol(238)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at EnsOwnerProxy.sol(244)

[33mWarning[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at EnsOwnerProxy.sol(122)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract safeSend {
    |    bool private txMutex3847834;
    |
  at EnsOwnerProxy.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at EnsOwnerProxy.sol(135)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at EnsOwnerProxy.sol(138)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at EnsOwnerProxy.sol(154)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at EnsOwnerProxy.sol(155)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at EnsOwnerProxy.sol(224)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at EnsOwnerProxy.sol(232)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at EnsOwnerProxy.sol(233)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at EnsOwnerProxy.sol(240)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract safeSend {
    |    bool private txMutex3847834;
    |
  at EnsOwnerProxy.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at EnsOwnerProxy.sol(80)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at EnsOwnerProxy.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at EnsOwnerProxy.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at EnsOwnerProxy.sol(146)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at EnsOwnerProxy.sol(154)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at EnsOwnerProxy.sol(155)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at EnsOwnerProxy.sol(250)

[FILE] SVIndex.sol
Processing contract: SVIndex.sol:BBFarm
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:BBFarmEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:BBFarmIface
Processing contract: SVIndex.sol:BBLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:BPackedUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:BytesLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:CommAuctionIface
Processing contract: SVIndex.sol:CommunityAuctionSimple
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:ENSIface
Processing contract: SVIndex.sol:ERC20Interface
Processing contract: SVIndex.sol:EnsOwnerProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:IxBackendIface
Processing contract: SVIndex.sol:IxIface
Processing contract: SVIndex.sol:IxLib
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:IxPaymentsIface
Processing contract: SVIndex.sol:PublicResolver
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:SVBallotConsts
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:SVIndex
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:SVIndexBackend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:SVPayments
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:SvEnsIface
Processing contract: SVIndex.sol:controlledIface
Processing contract: SVIndex.sol:hasAdmins
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:hasVersion
Processing contract: SVIndex.sol:ixBackendEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:ixEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:ixPaymentEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:payoutAllC
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:payoutAllCSettable
Processing contract: SVIndex.sol:permissioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:safeSend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SVIndex.sol:upgradePtr
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODAmount in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function logSponsorship(DB storage db, uint value) internal {
  > |        db.sponsors.push(Sponsor(msg.sender, value));
    |    }
    |
  at SVIndex.sol(181)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at SVIndex.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at SVIndex.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at SVIndex.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at SVIndex.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at SVIndex.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at SVIndex.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // we need to call the init functions on our libraries
    |        getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));
  > |        nBallots += 1;
    |
    |        emit BallotCreatedWithID(ballotId);
  at SVIndex.sol(1025)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function revealSeckey(DB storage db, bytes32 sk) internal {
  > |        db.ballotEncryptionSeckey = sk;
    |        emit SeckeyRevealed(sk);
    |    }
  at SVIndex.sol(284)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at SVIndex.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at SVIndex.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at SVIndex.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at SVIndex.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLib.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.deprecated = true;
    |    }
    |
  at SVIndex.sol(1131)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLib.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.ballotOwner = newOwner;
    |    }
    |}
  at SVIndex.sol(1137)

[31mViolation[0m for LockedEther in contract 'BBLib':
    |}
    |
  > |library BBLib {
    |    using BytesLib for bytes;
    |
  at SVIndex.sol(10)

[31mViolation[0m for UnrestrictedWrite in contract 'BBLib':
    |        // any future votes.
    |        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");
  > |        db.sequenceNumber[voter] = sequence;
    |    }
    |
  at SVIndex.sol(271)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |}
    |
  > |library BBLib {
    |    using BytesLib for bytes;
    |
  at SVIndex.sol(10)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        require(db.specHash == bytes32(0), "b-exists");
    |
  > |        db.index = ix;
    |        db.ballotOwner = ballotOwner;
    |
  at SVIndex.sol(137)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        db.index = ix;
  > |        db.ballotOwner = ballotOwner;
    |
    |        uint64 startTs;
  at SVIndex.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        }
    |        require(_specHash != bytes32(0), "null-specHash");
  > |        db.specHash = _specHash;
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  at SVIndex.sol(166)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        db.specHash = _specHash;
    |
  > |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
    |        db.creationTs = now;
    |
  at SVIndex.sol(168)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  > |        db.creationTs = now;
    |
    |        if (extraData != bytes16(0)) {
  at SVIndex.sol(169)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        if (extraData != bytes16(0)) {
  > |            db.extraData = extraData;
    |        }
    |
  at SVIndex.sol(172)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        id = db.nVotesCast;
  > |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
    |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
  at SVIndex.sol(256)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
  > |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
    |        if (extra.length > 0) {
    |            db.votes[id].extra = extra;
  at SVIndex.sol(258)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |            db.votes[id].extra = extra;
    |        }
  > |        db.nVotesCast += 1;
    |        emit SuccessfulVote(sender, id);
    |    }
  at SVIndex.sol(262)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        uint64 sTs;
    |        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);
  > |        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);
    |    }
    |
  at SVIndex.sol(280)

[31mViolation[0m for MissingInputValidation in contract 'CanReclaimToken':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at SVIndex.sol(566)

[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setPriceWei(uint newPrice) only_owner() external {
  > |        commBallotPriceWei = newPrice;
    |    }
    |}
  at SVIndex.sol(616)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at SVIndex.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at SVIndex.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at SVIndex.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAddr(address addr) only_admin() external {
    |        _setAddr(addr);
    |    }
  at SVIndex.sol(711)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToENS(bytes data) only_owner() external {
    |        require(address(ens).call(data), "fwding to ens failed");
    |    }
  at SVIndex.sol(723)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToResolver(bytes data) only_owner() external {
    |        require(address(resolver).call(data), "fwding to resolver failed");
    |    }
  at SVIndex.sol(727)

[33mWarning[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at SVIndex.sol(657)

[33mWarning[0m for TODAmount in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at SVIndex.sol(716)

[33mWarning[0m for TODReceiver in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at SVIndex.sol(716)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at SVIndex.sol(716)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at SVIndex.sol(681)

[31mViolation[0m for LockedEther in contract 'IxLib':
    |}
    |
  > |library IxLib {
    |    /**
    |     * Usage: `using IxLib for IxIface`
  at SVIndex.sol(379)

[31mViolation[0m for MissingInputValidation in contract 'IxLib':
    |    }
    |
  > |    function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {
    |        return ix.getBackend().getDArbitraryData(democHash, key);
    |    }
  at SVIndex.sol(472)

[31mViolation[0m for LockedEther in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at SVIndex.sol(2287)

[31mViolation[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at SVIndex.sol(2287)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at SVIndex.sol(2287)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setAddr(bytes32 node, address addr) public only_owner(node) {
  > |        records[node].addr = addr;
    |        emit AddrChanged(node, addr);
    |    }
  at SVIndex.sol(2342)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {
  > |        records[node].content = hash;
    |        emit ContentChanged(node, hash);
    |    }
  at SVIndex.sol(2355)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
  > |        records[node].pubkey = PublicKey(x, y);
    |        emit PubkeyChanged(node, x, y);
    |    }
  at SVIndex.sol(2393)

[31mViolation[0m for DAO in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        ensOwnerPx.setAddr(nextSC);
    |        ensOwnerPx.upgradeMeAdmin(nextSC);
  > |        commAuction.upgradeMe(nextSC);
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  at SVIndex.sol(1251)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  > |            bbFarms[i].upgradeMe(nextSC);
    |        }
    |    }
  at SVIndex.sol(1254)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        require(bbNamespace != bytes4(0), "bb-farm-namespace");
  > |        require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), "bb-namespace-used");
    |
    |        bbFarmId = _addBBFarm(bbNamespace, bbFarm);
  at SVIndex.sol(1273)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        }
    |
  > |        ballotId = _bbFarm.initBallot(
    |            specHash,
    |            packed,
  at SVIndex.sol(1451)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        doSafeSend(msg.sender, msg.value - price);
    |
  > |        bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);
    |        require(canProceed, "!cb-enabled");
    |
  at SVIndex.sol(1472)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);
  > |        commAuction.noteBallotDeployed(democHash);
    |
    |        emit CommunityBallot(democHash, ballotId);
  at SVIndex.sol(1478)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |    function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {
    |        // backend handles events
  > |        backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);
    |    }
    |
  at SVIndex.sol(1494)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if the ballot is marked as official require the democracy is paid up to
    |        // some relative amount - exclude NFP accounts from this check
  > |        uint secsLeft = payments.getSecondsRemaining(democHash);
    |        // must be positive due to ending in future check
    |        uint256 secsToEndTime = endTime - now;
  at SVIndex.sol(1501)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if we're an official ballot and the democ is basic, ensure the democ
    |        // isn't over the ballots/mo limit
  > |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
  at SVIndex.sol(1511)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // isn't over the ballots/mo limit
    |        if (payments.getPremiumStatus(democHash) == false) {
  > |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
  at SVIndex.sol(1512)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
  > |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
    |            // if the democ has less than nBallotsAllowed then it's guarenteed to be okay
  at SVIndex.sol(1513)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // nBallotsBasicCounted-X. There would thus be (X-1) ballots that are _more_
    |            // recent than the one we're looking for.
  > |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
    |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
  at SVIndex.sol(1528)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // recent than the one we're looking for.
    |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
  > |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
    |            // if the earlyBallot was created more than 30 days in the past we should
  at SVIndex.sol(1529)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // where the Nth most recent ballot was created within the last 30 days.)
    |            // We should now check for payment
  > |            uint extraBallotFee = payments.getBasicExtraBallotFeeWei();
    |            require(msg.value >= extraBallotFee, "!extra-b-fee");
    |
  at SVIndex.sol(1541)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at SVIndex.sol(1331)

[31mViolation[0m for TODReceiver in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at SVIndex.sol(1331)

[33mWarning[0m for TODReceiver in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at SVIndex.sol(1331)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at SVIndex.sol(501)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at SVIndex.sol(506)

[31mViolation[0m for DAO in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for LockedEther in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at SVIndex.sol(1605)

[33mWarning[0m for TODAmount in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODReceiver in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at SVIndex.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at SVIndex.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at SVIndex.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at SVIndex.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at SVIndex.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at SVIndex.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at SVIndex.sol(1605)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");
    |        // set owner and editor
  > |        d.owner = newOwner;
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  at SVIndex.sol(1739)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // set owner and editor
    |        d.owner = newOwner;
  > |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
    |        d.erc20OwnerClaimDisabled = true;
  at SVIndex.sol(1740)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  > |        d.erc20OwnerClaimDisabled = true;
    |        emit DemocOwnerSet(democHash, newOwner);
    |        emit DemocClaimed(democHash);
  at SVIndex.sol(1742)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {
    |        Democ storage d = democs[democHash];
  > |        d.editors[d.editorEpoch][editor] = canEdit;
    |        emit DemocEditorSet(democHash, editor, canEdit);
    |    }
  at SVIndex.sol(1749)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDNoEditors(bytes32 democHash) only_editors() external {
  > |        democs[democHash].editorEpoch += 1;
    |        emit DemocEditorsWiped(democHash);
    |    }
  at SVIndex.sol(1754)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
  > |        democs[democHash].erc20 = newErc20;
    |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
  at SVIndex.sol(1759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
    |        democs[democHash].erc20 = newErc20;
  > |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
    |    }
  at SVIndex.sol(1760)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {
    |        uint catId = democCategories[democHash].nCategories;
  > |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  at SVIndex.sol(1778)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
  > |            democCategories[democHash].categories[catId].hasParent = true;
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  at SVIndex.sol(1780)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  > |            democCategories[democHash].categories[catId].parent = parent;
    |        }
    |        democCategories[democHash].nCategories += 1;
  at SVIndex.sol(1781)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  > |        democCategories[democHash].nCategories += 1;
    |        emit DemocCatAdded(democHash, catId);
    |    }
  at SVIndex.sol(1783)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {
  > |        democCategories[democHash].categories[catId].deprecated = true;
    |        emit DemocCatDeprecated(democHash, catId);
    |    }
  at SVIndex.sol(1788)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {
  > |        democs[democHash].communityBallotsDisabled = !enabled;
    |        emit DemocCommunityBallotsEnabled(democHash, enabled);
    |    }
  at SVIndex.sol(1793)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {
  > |        democs[democHash].erc20OwnerClaimDisabled = true;
    |        emit DemocErc20OwnerClaimDisabled(democHash);
    |    }
  at SVIndex.sol(1798)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |        uint localBallotId = democs[democHash].allBallots.length;
  > |        democs[democHash].allBallots.push(ballotId);
    |
    |        // do this for anything that doesn't qualify as a community ballot
  at SVIndex.sol(1809)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // do this for anything that doesn't qualify as a community ballot
    |        if (countTowardsLimit) {
  > |            democs[democHash].includedBasicBallots.push(ballotId);
    |        }
    |
  at SVIndex.sol(1813)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at SVIndex.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at SVIndex.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at SVIndex.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at SVIndex.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {
  > |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
    |        d.erc20 = erc20;
  at SVIndex.sol(1682)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
  > |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
    |            d.erc20OwnerClaimDisabled = true;
  at SVIndex.sol(1684)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
  > |            d.erc20OwnerClaimDisabled = true;
    |        }
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
  at SVIndex.sol(1686)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
  > |        democPrefixToHash[bytes13(democHash)] = democHash;
    |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
  at SVIndex.sol(1690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
    |        democPrefixToHash[bytes13(democHash)] = democHash;
  > |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
    |        emit NewDemoc(democHash);
  at SVIndex.sol(1691)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        Democ storage d = democs[democHash];
    |        uint epoch = d.editorEpoch;
  > |        d.owner = newOwner;
    |        // unset prev owner as editor - does little if one was not set
    |        d.editors[epoch][d.owner] = false;
  at SVIndex.sol(1722)

[33mWarning[0m for DAO in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at SVIndex.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at SVIndex.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at SVIndex.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at SVIndex.sol(758)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at SVIndex.sol(766)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at SVIndex.sol(773)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at SVIndex.sol(779)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    // contracts are compromised? (e.g. by a leaked privkey)
    |    address public emergencyAdmin;
  > |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
    |        owner = newOwner;
  at SVIndex.sol(1993)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function doFreeExtension(bytes32 democHash) external {
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  at SVIndex.sol(2064)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
    |        accounts[democHash].isPremium = false;
  at SVIndex.sol(2071)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeToPremium(bytes32 democHash) only_editors() external {
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  at SVIndex.sol(2088)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account status - getters */
    |
  > |    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].paidUpTill >= now;
    |    }
  at SVIndex.sol(2106)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {
    |        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);
    |    }
  at SVIndex.sol(2110)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getPremiumStatus(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].isPremium;
    |    }
  at SVIndex.sol(2114)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getFreeExtension(bytes32 democHash) external view returns (bool) {
    |        return freeExtension[democHash];
    |    }
  at SVIndex.sol(2118)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {
    |        isPremium = accounts[democHash].isPremium;
    |        lastPaymentTs = accounts[democHash].lastPaymentTs;
  at SVIndex.sol(2122)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getDenyPremium(bytes32 democHash) external view returns (bool) {
    |        return denyPremium[democHash];
    |    }
  at SVIndex.sol(2129)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin utils for accounts */
    |
  > |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
    |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
  at SVIndex.sol(2135)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin setters global */
    |
  > |    function setPayTo(address newPayTo) only_owner() external {
    |        _setPayTo(newPayTo);
    |        emit SetPayTo(newPayTo);
  at SVIndex.sol(2143)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinorEditsAddr(address a) only_owner() external {
    |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
  at SVIndex.sol(2148)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
    |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
  at SVIndex.sol(2153)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
    |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
  at SVIndex.sol(2158)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setPremiumMultiplier(uint8 m) only_owner() external {
    |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
  at SVIndex.sol(2163)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
    |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
  at SVIndex.sol(2168)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
    |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
  at SVIndex.sol(2173)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
    |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
  at SVIndex.sol(2178)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
    |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
  at SVIndex.sol(2183)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at SVIndex.sol(657)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account management */
    |
  > |    function payForDemocracy(bytes32 democHash) external payable {
    |        require(msg.value > 0, "need to send some ether to make payment");
    |
  at SVIndex.sol(2046)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at SVIndex.sol(2061)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at SVIndex.sol(2061)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at SVIndex.sol(2061)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at SVIndex.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at SVIndex.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at SVIndex.sol(526)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at SVIndex.sol(689)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at SVIndex.sol(690)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at SVIndex.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at SVIndex.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at SVIndex.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at SVIndex.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        }
    |
  > |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
    |        accounts[democHash].lastPaymentTs = now;
    |    }
  at SVIndex.sol(2021)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
  > |        accounts[democHash].lastPaymentTs = now;
    |    }
    |
  at SVIndex.sol(2022)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            _modAccountBalance(democHash, additionalSeconds);
    |        }
  > |        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  at SVIndex.sol(2058)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  > |        accounts[democHash].paidUpTill = newPaidUpTill;
    |        emit FreeExtension(democHash);
    |    }
  at SVIndex.sol(2067)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
  > |        accounts[democHash].isPremium = false;
    |        // convert premium minutes to basic
    |        uint paidTill = accounts[democHash].paidUpTill;
  at SVIndex.sol(2073)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");
    |            timeRemaining *= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        emit DowngradeToBasic(democHash);
  at SVIndex.sol(2083)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  > |        accounts[democHash].isPremium = true;
    |        // convert basic minutes to premium minutes
    |        uint paidTill = accounts[democHash].paidUpTill;
  at SVIndex.sol(2091)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (timeRemaining > 0) {
    |            timeRemaining /= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        accounts[democHash].lastUpgradeTs = now;
  at SVIndex.sol(2098)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
  > |        accounts[democHash].lastUpgradeTs = now;
    |        emit UpgradedToPremium(democHash);
    |    }
  at SVIndex.sol(2100)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
  > |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
    |        emit GrantedAccountTime(democHash, additionalSeconds, ref);
    |    }
  at SVIndex.sol(2137)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at SVIndex.sol(526)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at SVIndex.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at SVIndex.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at SVIndex.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at SVIndex.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
  > |        owner = newOwner;
    |    }
    |    /* END BREAK GLASS */
  at SVIndex.sol(1995)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinorEditsAddr(address a) only_owner() external {
  > |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
    |    }
  at SVIndex.sol(2149)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
  > |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
    |    }
  at SVIndex.sol(2154)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
  > |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
    |    }
  at SVIndex.sol(2159)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPremiumMultiplier(uint8 m) only_owner() external {
  > |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
    |    }
  at SVIndex.sol(2164)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
  > |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
    |    }
  at SVIndex.sol(2169)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
  > |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
    |    }
  at SVIndex.sol(2174)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
  > |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
    |    }
  at SVIndex.sol(2179)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
  > |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
    |    }
  at SVIndex.sol(2184)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at SVIndex.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at SVIndex.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at SVIndex.sol(664)

[33mWarning[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at SVIndex.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at SVIndex.sol(681)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at SVIndex.sol(566)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[31mViolation[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODAmount in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for TODReceiver in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at SVIndex.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at SVIndex.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at SVIndex.sol(506)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at SVIndex.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at SVIndex.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at SVIndex.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at SVIndex.sol(758)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at SVIndex.sol(766)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at SVIndex.sol(773)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at SVIndex.sol(779)

[33mWarning[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at SVIndex.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at SVIndex.sol(689)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at SVIndex.sol(690)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at SVIndex.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at SVIndex.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at SVIndex.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at SVIndex.sol(775)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at SVIndex.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at SVIndex.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at SVIndex.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at SVIndex.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at SVIndex.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at SVIndex.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at SVIndex.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at SVIndex.sol(785)

[FILE] CDPCreator.sol
Processing contract: CDPCreator.sol:CDPCreator
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSAuth
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSAuthEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSAuthority
Processing contract: CDPCreator.sol:DSMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSNote
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSStop
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSThing
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSTokenBase
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:DSValue
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:ERC20
Processing contract: CDPCreator.sol:ERC20Events
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:SaiTub
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle13229225788667127576/mustExplicit -j 8 -F /tmp/souffle-7680fa64-0c98-4b4e-8767-fdfb5101b019 -D /tmp/souffle-7680fa64-0c98-4b4e-8767-fdfb5101b019_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: CDPCreator.sol:SaiTub
Processing contract: CDPCreator.sol:SaiTubEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:SaiVox
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CDPCreator.sol:WETH9
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for TODAmount in contract 'CDPCreator':
    |    function createCDP(uint256 amountDAI) payable external {
    |        require(msg.value >= 0.005 ether);
  > |        require(address(weth).call.value(msg.value)());
    |
    |        bytes32 cupID = tub.open();
  at CDPCreator.sol(1732)

[33mWarning[0m for TODAmount in contract 'CDPCreator':
    |
    |    function lockETH(uint256 id) payable external {
  > |        require(address(weth).call.value(msg.value)());
    |
    |        uint256 amountPETH = rdiv(msg.value, tub.per());
  at CDPCreator.sol(1748)

[33mWarning[0m for TODAmount in contract 'CDPCreator':
    |
    |    function convertETHToPETH() payable external {
  > |        require(address(weth).call.value(msg.value)());
    |
    |        uint256 amountPETH = rdiv(msg.value, tub.per());
  at CDPCreator.sol(1757)

[31mViolation[0m for UnrestrictedEtherFlow in contract 'CDPCreator':
    |        tub.exit(amountPETH);
    |        weth.withdraw(bid);
  > |        msg.sender.transfer(bid);
    |    }
    |
  at CDPCreator.sol(1770)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'CDPCreator':
    |    function createCDP(uint256 amountDAI) payable external {
    |        require(msg.value >= 0.005 ether);
  > |        require(address(weth).call.value(msg.value)());
    |
    |        bytes32 cupID = tub.open();
  at CDPCreator.sol(1732)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'CDPCreator':
    |
    |    function lockETH(uint256 id) payable external {
  > |        require(address(weth).call.value(msg.value)());
    |
    |        uint256 amountPETH = rdiv(msg.value, tub.per());
  at CDPCreator.sol(1748)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'CDPCreator':
    |
    |    function convertETHToPETH() payable external {
  > |        require(address(weth).call.value(msg.value)());
    |
    |        uint256 amountPETH = rdiv(msg.value, tub.per());
  at CDPCreator.sol(1757)

[33mWarning[0m for DAO in contract 'DSAuth':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for MissingInputValidation in contract 'DSAuth':
    |    }
    |
  > |    function setOwner(address owner_)
    |        public
    |        auth
  at CDPCreator.sol(41)

[33mWarning[0m for MissingInputValidation in contract 'DSAuth':
    |    }
    |
  > |    function setAuthority(DSAuthority authority_)
    |        public
    |        auth
  at CDPCreator.sol(49)

[33mWarning[0m for TODAmount in contract 'DSAuth':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for TODReceiver in contract 'DSAuth':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'DSAuth':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[31mViolation[0m for UnrestrictedWrite in contract 'DSAuth':
    |        auth
    |    {
  > |        owner = owner_;
    |        LogSetOwner(owner);
    |    }
  at CDPCreator.sol(45)

[31mViolation[0m for UnrestrictedWrite in contract 'DSAuth':
    |        auth
    |    {
  > |        authority = authority_;
    |        LogSetAuthority(authority);
    |    }
  at CDPCreator.sol(53)

[33mWarning[0m for DAO in contract 'DSStop':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for MissingInputValidation in contract 'DSStop':
    |    }
    |
  > |    function setOwner(address owner_)
    |        public
    |        auth
  at CDPCreator.sol(41)

[33mWarning[0m for MissingInputValidation in contract 'DSStop':
    |    }
    |
  > |    function setAuthority(DSAuthority authority_)
    |        public
    |        auth
  at CDPCreator.sol(49)

[33mWarning[0m for TODAmount in contract 'DSStop':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for TODReceiver in contract 'DSStop':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'DSStop':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[31mViolation[0m for UnrestrictedWrite in contract 'DSStop':
    |        auth
    |    {
  > |        owner = owner_;
    |        LogSetOwner(owner);
    |    }
  at CDPCreator.sol(45)

[31mViolation[0m for UnrestrictedWrite in contract 'DSStop':
    |        auth
    |    {
  > |        authority = authority_;
    |        LogSetAuthority(authority);
    |    }
  at CDPCreator.sol(53)

[31mViolation[0m for UnrestrictedWrite in contract 'DSStop':
    |    }
    |    function stop() public auth note {
  > |        stopped = true;
    |    }
    |    function start() public auth note {
  at CDPCreator.sol(268)

[31mViolation[0m for UnrestrictedWrite in contract 'DSStop':
    |    }
    |    function start() public auth note {
  > |        stopped = false;
    |    }
    |
  at CDPCreator.sol(271)

[33mWarning[0m for DAO in contract 'DSThing':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for MissingInputValidation in contract 'DSThing':
    |    }
    |
  > |    function setOwner(address owner_)
    |        public
    |        auth
  at CDPCreator.sol(41)

[33mWarning[0m for MissingInputValidation in contract 'DSThing':
    |    }
    |
  > |    function setAuthority(DSAuthority authority_)
    |        public
    |        auth
  at CDPCreator.sol(49)

[33mWarning[0m for TODAmount in contract 'DSThing':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for TODReceiver in contract 'DSThing':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'DSThing':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[31mViolation[0m for UnrestrictedWrite in contract 'DSThing':
    |        auth
    |    {
  > |        owner = owner_;
    |        LogSetOwner(owner);
    |    }
  at CDPCreator.sol(45)

[31mViolation[0m for UnrestrictedWrite in contract 'DSThing':
    |        auth
    |    {
  > |        authority = authority_;
    |        LogSetAuthority(authority);
    |    }
  at CDPCreator.sol(53)

[33mWarning[0m for DAO in contract 'DSToken':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |        return _supply;
    |    }
  > |    function balanceOf(address src) public view returns (uint) {
    |        return _balances[src];
    |    }
  at CDPCreator.sol(340)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |        return _balances[src];
    |    }
  > |    function allowance(address src, address guy) public view returns (uint) {
    |        return _approvals[src][guy];
    |    }
  at CDPCreator.sol(343)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function transfer(address dst, uint wad) public returns (bool) {
    |        return transferFrom(msg.sender, dst, wad);
    |    }
  at CDPCreator.sol(347)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |    event Burn(address indexed guy, uint wad);
    |
  > |    function approve(address guy) public stoppable returns (bool) {
    |        return super.approve(guy, uint(-1));
    |    }
  at CDPCreator.sol(412)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function approve(address guy, uint wad) public stoppable returns (bool) {
    |        return super.approve(guy, wad);
    |    }
  at CDPCreator.sol(416)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function transferFrom(address src, address dst, uint wad)
    |        public
    |        stoppable
  at CDPCreator.sol(420)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function push(address dst, uint wad) public {
    |        transferFrom(msg.sender, dst, wad);
    |    }
  at CDPCreator.sol(437)

[31mViolation[0m for MissingInputValidation in contract 'DSToken':
    |        transferFrom(src, msg.sender, wad);
    |    }
  > |    function move(address src, address dst, uint wad) public {
    |        transferFrom(src, dst, wad);
    |    }
  at CDPCreator.sol(443)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function setOwner(address owner_)
    |        public
    |        auth
  at CDPCreator.sol(41)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function setAuthority(DSAuthority authority_)
    |        public
    |        auth
  at CDPCreator.sol(49)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |        transferFrom(msg.sender, dst, wad);
    |    }
  > |    function pull(address src, uint wad) public {
    |        transferFrom(src, msg.sender, wad);
    |    }
  at CDPCreator.sol(440)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |    }
    |
  > |    function mint(uint wad) public {
    |        mint(msg.sender, wad);
    |    }
  at CDPCreator.sol(447)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |        mint(msg.sender, wad);
    |    }
  > |    function burn(uint wad) public {
    |        burn(msg.sender, wad);
    |    }
  at CDPCreator.sol(450)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |        burn(msg.sender, wad);
    |    }
  > |    function mint(address guy, uint wad) public auth stoppable {
    |        _balances[guy] = add(_balances[guy], wad);
    |        _supply = add(_supply, wad);
  at CDPCreator.sol(453)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |        Mint(guy, wad);
    |    }
  > |    function burn(address guy, uint wad) public auth stoppable {
    |        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {
    |            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);
  at CDPCreator.sol(458)

[33mWarning[0m for MissingInputValidation in contract 'DSToken':
    |    bytes32   public  name = "";
    |
  > |    function setName(bytes32 name_) public auth {
    |        name = name_;
    |    }
  at CDPCreator.sol(471)

[33mWarning[0m for TODAmount in contract 'DSToken':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for TODReceiver in contract 'DSToken':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'DSToken':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |        auth
    |    {
  > |        owner = owner_;
    |        LogSetOwner(owner);
    |    }
  at CDPCreator.sol(45)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |        auth
    |    {
  > |        authority = authority_;
    |        LogSetAuthority(authority);
    |    }
  at CDPCreator.sol(53)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |    }
    |    function stop() public auth note {
  > |        stopped = true;
    |    }
    |    function start() public auth note {
  at CDPCreator.sol(268)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |    }
    |    function start() public auth note {
  > |        stopped = false;
    |    }
    |
  at CDPCreator.sol(271)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |
    |    function approve(address guy, uint wad) public returns (bool) {
  > |        _approvals[msg.sender][guy] = wad;
    |
    |        Approval(msg.sender, guy, wad);
  at CDPCreator.sol(368)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |
    |        _balances[src] = sub(_balances[src], wad);
  > |        _balances[dst] = add(_balances[dst], wad);
    |
    |        Transfer(src, dst, wad);
  at CDPCreator.sol(430)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |    }
    |    function mint(address guy, uint wad) public auth stoppable {
  > |        _balances[guy] = add(_balances[guy], wad);
    |        _supply = add(_supply, wad);
    |        Mint(guy, wad);
  at CDPCreator.sol(454)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |    function mint(address guy, uint wad) public auth stoppable {
    |        _balances[guy] = add(_balances[guy], wad);
  > |        _supply = add(_supply, wad);
    |        Mint(guy, wad);
    |    }
  at CDPCreator.sol(455)

[31mViolation[0m for UnrestrictedWrite in contract 'DSToken':
    |
    |    function setName(bytes32 name_) public auth {
  > |        name = name_;
    |    }
    |}
  at CDPCreator.sol(472)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |        }
    |
  > |        _balances[src] = sub(_balances[src], wad);
    |        _balances[dst] = add(_balances[dst], wad);
    |
  at CDPCreator.sol(429)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |
    |        _balances[src] = sub(_balances[src], wad);
  > |        _balances[dst] = add(_balances[dst], wad);
    |
    |        Transfer(src, dst, wad);
  at CDPCreator.sol(430)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |    }
    |    function mint(address guy, uint wad) public auth stoppable {
  > |        _balances[guy] = add(_balances[guy], wad);
    |        _supply = add(_supply, wad);
    |        Mint(guy, wad);
  at CDPCreator.sol(454)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |    function mint(address guy, uint wad) public auth stoppable {
    |        _balances[guy] = add(_balances[guy], wad);
  > |        _supply = add(_supply, wad);
    |        Mint(guy, wad);
    |    }
  at CDPCreator.sol(455)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |    function burn(address guy, uint wad) public auth stoppable {
    |        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {
  > |            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);
    |        }
    |
  at CDPCreator.sol(460)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |        }
    |
  > |        _balances[guy] = sub(_balances[guy], wad);
    |        _supply = sub(_supply, wad);
    |        Burn(guy, wad);
  at CDPCreator.sol(463)

[33mWarning[0m for UnrestrictedWrite in contract 'DSToken':
    |
    |        _balances[guy] = sub(_balances[guy], wad);
  > |        _supply = sub(_supply, wad);
    |        Burn(guy, wad);
    |    }
  at CDPCreator.sol(464)

[31mViolation[0m for MissingInputValidation in contract 'DSTokenBase':
    |        return _supply;
    |    }
  > |    function balanceOf(address src) public view returns (uint) {
    |        return _balances[src];
    |    }
  at CDPCreator.sol(340)

[31mViolation[0m for MissingInputValidation in contract 'DSTokenBase':
    |        return _balances[src];
    |    }
  > |    function allowance(address src, address guy) public view returns (uint) {
    |        return _approvals[src][guy];
    |    }
  at CDPCreator.sol(343)

[31mViolation[0m for MissingInputValidation in contract 'DSTokenBase':
    |    }
    |
  > |    function transfer(address dst, uint wad) public returns (bool) {
    |        return transferFrom(msg.sender, dst, wad);
    |    }
  at CDPCreator.sol(347)

[31mViolation[0m for MissingInputValidation in contract 'DSTokenBase':
    |    }
    |
  > |    function approve(address guy, uint wad) public returns (bool) {
    |        _approvals[msg.sender][guy] = wad;
    |
  at CDPCreator.sol(367)

[33mWarning[0m for MissingInputValidation in contract 'DSTokenBase':
    |    }
    |
  > |    function transferFrom(address src, address dst, uint wad)
    |        public
    |        returns (bool)
  at CDPCreator.sol(351)

[31mViolation[0m for UnrestrictedWrite in contract 'DSTokenBase':
    |        }
    |
  > |        _balances[src] = sub(_balances[src], wad);
    |        _balances[dst] = add(_balances[dst], wad);
    |
  at CDPCreator.sol(359)

[33mWarning[0m for UnrestrictedWrite in contract 'DSTokenBase':
    |
    |        _balances[src] = sub(_balances[src], wad);
  > |        _balances[dst] = add(_balances[dst], wad);
    |
    |        Transfer(src, dst, wad);
  at CDPCreator.sol(360)

[33mWarning[0m for DAO in contract 'DSValue':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for MissingInputValidation in contract 'DSValue':
    |    }
    |
  > |    function setOwner(address owner_)
    |        public
    |        auth
  at CDPCreator.sol(41)

[33mWarning[0m for MissingInputValidation in contract 'DSValue':
    |    }
    |
  > |    function setAuthority(DSAuthority authority_)
    |        public
    |        auth
  at CDPCreator.sol(49)

[33mWarning[0m for MissingInputValidation in contract 'DSValue':
    |        return wut;
    |    }
  > |    function poke(bytes32 wut) public note auth {
    |        val = wut;
    |        has = true;
  at CDPCreator.sol(509)

[33mWarning[0m for TODAmount in contract 'DSValue':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for TODReceiver in contract 'DSValue':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'DSValue':
    |            return false;
    |        } else {
  > |            return authority.canCall(src, this, sig);
    |        }
    |    }
  at CDPCreator.sol(70)

[31mViolation[0m for UnrestrictedWrite in contract 'DSValue':
    |        auth
    |    {
  > |        owner = owner_;
    |        LogSetOwner(owner);
    |    }
  at CDPCreator.sol(45)

[31mViolation[0m for UnrestrictedWrite in contract 'DSValue':
    |        auth
    |    {
  > |        authority = authority_;
    |        LogSetAuthority(authority);
    |    }
  at CDPCreator.sol(53)

[31mViolation[0m for UnrestrictedWrite in contract 'DSValue':
    |    }
    |    function poke(bytes32 wut) public note auth {
  > |        val = wut;
    |        has = true;
    |    }
  at CDPCreator.sol(510)

[31mViolation[0m for UnrestrictedWrite in contract 'DSValue':
    |    function poke(bytes32 wut) public note auth {
    |        val = wut;
  > |        has = true;
    |    }
    |    function void() public note auth {  // unset the value
  at CDPCreator.sol(511)

[31mViolation[0m for UnrestrictedWrite in contract 'DSValue':
    |    }
    |    function void() public note auth {  // unset the value
  > |        has = false;
    |    }
    |}
  at CDPCreator.sol(514)

[31mViolation[0m for UnrestrictedWrite in contract 'SaiVox':
    |        var age = era() - tau;
    |        if (age == 0) return;  // optimised
  > |        tau = era();
    |
    |        if (_way != RAY) _par = rmul(_par, rpow(_way, age));  // optimised
  at CDPCreator.sol(584)

[31mViolation[0m for UnrestrictedWrite in contract 'SaiVox':
    |        tau = era();
    |
  > |        if (_way != RAY) _par = rmul(_par, rpow(_way, age));  // optimised
    |
    |        if (how == 0) return;  // optimised
  at CDPCreator.sol(586)

[31mViolation[0m for UnrestrictedWrite in contract 'SaiVox':
    |        if (how == 0) return;  // optimised
    |        var wag = int128(how * age);
  > |        _way = inj(prj(_way) + (fix < _par ? wag : -wag));
    |    }
    |
  at CDPCreator.sol(590)

[33mWarning[0m for UnrestrictedWrite in contract 'SaiVox':
    |        auth
    |    {
  > |        owner = owner_;
    |        LogSetOwner(owner);
    |    }
  at CDPCreator.sol(45)

[33mWarning[0m for UnrestrictedWrite in contract 'SaiVox':
    |        auth
    |    {
  > |        authority = authority_;
    |        LogSetAuthority(authority);
    |    }
  at CDPCreator.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'SaiVox':
    |
    |    function mold(bytes32 param, uint val) public note auth {
  > |        if (param == 'way') _way = val;
    |    }
    |
  at CDPCreator.sol(561)

[33mWarning[0m for UnrestrictedWrite in contract 'SaiVox':
    |
    |    function tell(uint256 ray) public note auth {
  > |        fix = ray;
    |    }
    |    function tune(uint256 ray) public note auth {
  at CDPCreator.sol(575)

[33mWarning[0m for UnrestrictedWrite in contract 'SaiVox':
    |    }
    |    function tune(uint256 ray) public note auth {
  > |        how = ray;
    |    }
    |
  at CDPCreator.sol(578)

[31mViolation[0m for MissingInputValidation in contract 'WETH9':
    |    event  Withdrawal(address indexed src, uint wad);
    |
  > |    mapping (address => uint)                       public  balanceOf;
    |    mapping (address => mapping (address => uint))  public  allowance;
    |
  at CDPCreator.sol(981)

[31mViolation[0m for MissingInputValidation in contract 'WETH9':
    |
    |    mapping (address => uint)                       public  balanceOf;
  > |    mapping (address => mapping (address => uint))  public  allowance;
    |
    |    function() public payable {
  at CDPCreator.sol(982)

[31mViolation[0m for MissingInputValidation in contract 'WETH9':
    |    }
    |
  > |    function approve(address guy, uint wad) public returns (bool) {
    |        allowance[msg.sender][guy] = wad;
    |        Approval(msg.sender, guy, wad);
  at CDPCreator.sol(1002)

[31mViolation[0m for MissingInputValidation in contract 'WETH9':
    |    }
    |
  > |    function transfer(address dst, uint wad) public returns (bool) {
    |        return transferFrom(msg.sender, dst, wad);
    |    }
  at CDPCreator.sol(1008)

[31mViolation[0m for MissingInputValidation in contract 'WETH9':
    |    }
    |
  > |    function transferFrom(address src, address dst, uint wad)
    |        public
    |        returns (bool)
  at CDPCreator.sol(1012)

[31mViolation[0m for UnrestrictedEtherFlow in contract 'WETH9':
    |        require(balanceOf[msg.sender] >= wad);
    |        balanceOf[msg.sender] -= wad;
  > |        msg.sender.transfer(wad);
    |        Withdrawal(msg.sender, wad);
    |    }
  at CDPCreator.sol(994)

[33mWarning[0m for UnrestrictedWrite in contract 'WETH9':
    |        }
    |
  > |        balanceOf[src] -= wad;
    |        balanceOf[dst] += wad;
    |
  at CDPCreator.sol(1023)

[33mWarning[0m for UnrestrictedWrite in contract 'WETH9':
    |
    |        balanceOf[src] -= wad;
  > |        balanceOf[dst] += wad;
    |
    |        Transfer(src, dst, wad);
  at CDPCreator.sol(1024)

[33mWarning[0m for UnrestrictedWrite in contract 'WETH9':
    |
    |        balanceOf[src] -= wad;
  > |        balanceOf[dst] += wad;
    |
    |        Transfer(src, dst, wad);
  at CDPCreator.sol(1024)

[FILE] BasicMultiTokenDeployer.sol
Processing contract: BasicMultiTokenDeployer.sol:AbstractDeployer
Processing contract: BasicMultiTokenDeployer.sol:BasicMultiToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:BasicMultiTokenDeployer
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:CheckedERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:DetailedERC20
Processing contract: BasicMultiTokenDeployer.sol:ERC1003Caller
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:ERC1003Token
Processing contract: BasicMultiTokenDeployer.sol:ERC20
Processing contract: BasicMultiTokenDeployer.sol:ERC20Basic
Processing contract: BasicMultiTokenDeployer.sol:IBasicMultiToken
Processing contract: BasicMultiTokenDeployer.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BasicMultiTokenDeployer.sol:StandardToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'BasicMultiToken':
    |        _sendersStack.push(msg.sender);
    |        approve(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        _sendersStack.length -= 1;
    |        return true;
  at BasicMultiTokenDeployer.sol(482)

[31mViolation[0m for DAO in contract 'BasicMultiToken':
    |        token.asmTransfer(to, amount);
    |        _inLendingMode += 1;
  > |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
    |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
  at BasicMultiTokenDeployer.sol(646)

[33mWarning[0m for LockedEther in contract 'BasicMultiToken':
    |// File: contracts/BasicMultiToken.sol
    |
  > |contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken {
    |    using CheckedERC20 for ERC20;
    |    using CheckedERC20 for DetailedERC20;
  at BasicMultiTokenDeployer.sol(520)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |        require(isContract(token));
    |        // solium-disable-next-line security/no-low-level-calls
  > |        require(token.call(bytes4(keccak256("transfer(address,uint256)")), to, value));
    |        return handleReturnBool();
    |    }
  at BasicMultiTokenDeployer.sol(408)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |        require(isContract(token));
    |        // solium-disable-next-line security/no-low-level-calls
  > |        require(token.call(bytes4(keccak256("transferFrom(address,address,uint256)")), from, to, value));
    |        return handleReturnBool();
    |    }
  at BasicMultiTokenDeployer.sol(415)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |    function checkedTransfer(ERC20 token, address to, uint256 value) internal {
    |        if (value > 0) {
  > |            uint256 balance = token.balanceOf(this);
    |            asmTransfer(token, to, value);
    |            require(token.balanceOf(this) == balance.sub(value), "checkedTransfer: Final balance didn't match");
  at BasicMultiTokenDeployer.sol(430)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |            uint256 balance = token.balanceOf(this);
    |            asmTransfer(token, to, value);
  > |            require(token.balanceOf(this) == balance.sub(value), "checkedTransfer: Final balance didn't match");
    |        }
    |    }
  at BasicMultiTokenDeployer.sol(432)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |    function checkedTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
    |        if (value > 0) {
  > |            uint256 toBalance = token.balanceOf(to);
    |            asmTransferFrom(token, from, to, value);
    |            require(token.balanceOf(to) == toBalance.add(value), "checkedTransfer: Final balance didn't match");
  at BasicMultiTokenDeployer.sol(438)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |            uint256 toBalance = token.balanceOf(to);
    |            asmTransferFrom(token, from, to, value);
  > |            require(token.balanceOf(to) == toBalance.add(value), "checkedTransfer: Final balance didn't match");
    |        }
    |    }
  at BasicMultiTokenDeployer.sol(440)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |        uint256[] memory tokenAmounts = new uint256[](_tokens.length);
    |        for (uint i = 0; i < _tokens.length; i++) {
  > |            tokenAmounts[i] = _tokens[i].balanceOf(this).mul(amount).div(totalSupply_);
    |        }
    |        _bundle(beneficiary, amount, tokenAmounts);
  at BasicMultiTokenDeployer.sol(578)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |                require(someTokens[i] != someTokens[j], "unbundleSome: should not unbundle same token multiple times");
    |            }
  > |            uint256 tokenAmount = someTokens[i].balanceOf(this).mul(value).div(totalSupply);
    |            someTokens[i].checkedTransfer(beneficiary, tokenAmount);
    |        }
  at BasicMultiTokenDeployer.sol(635)

[31mViolation[0m for RepeatedCall in contract 'BasicMultiToken':
    |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
  > |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
    |    }
    |}
  at BasicMultiTokenDeployer.sol(648)

[33mWarning[0m for RepeatedCall in contract 'BasicMultiToken':
    |    function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool) {
    |        transfer(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        return true;
    |    }
  at BasicMultiTokenDeployer.sol(489)

[33mWarning[0m for RepeatedCall in contract 'BasicMultiToken':
    |        token.asmTransfer(to, amount);
    |        _inLendingMode += 1;
  > |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
    |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
  at BasicMultiTokenDeployer.sol(646)

[33mWarning[0m for TODAmount in contract 'BasicMultiToken':
    |        _sendersStack.push(msg.sender);
    |        approve(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        _sendersStack.length -= 1;
    |        return true;
  at BasicMultiTokenDeployer.sol(482)

[33mWarning[0m for TODAmount in contract 'BasicMultiToken':
    |    function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool) {
    |        transfer(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        return true;
    |    }
  at BasicMultiTokenDeployer.sol(489)

[33mWarning[0m for TODAmount in contract 'BasicMultiToken':
    |        token.asmTransfer(to, amount);
    |        _inLendingMode += 1;
  > |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
    |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
  at BasicMultiTokenDeployer.sol(646)

[33mWarning[0m for TODReceiver in contract 'BasicMultiToken':
    |        _sendersStack.push(msg.sender);
    |        approve(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        _sendersStack.length -= 1;
    |        return true;
  at BasicMultiTokenDeployer.sol(482)

[33mWarning[0m for TODReceiver in contract 'BasicMultiToken':
    |    function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool) {
    |        transfer(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        return true;
    |    }
  at BasicMultiTokenDeployer.sol(489)

[33mWarning[0m for TODReceiver in contract 'BasicMultiToken':
    |        token.asmTransfer(to, amount);
    |        _inLendingMode += 1;
  > |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
    |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
  at BasicMultiTokenDeployer.sol(646)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BasicMultiToken':
    |        _sendersStack.push(msg.sender);
    |        approve(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        _sendersStack.length -= 1;
    |        return true;
  at BasicMultiTokenDeployer.sol(482)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BasicMultiToken':
    |    function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool) {
    |        transfer(to, value);
  > |        require(_caller.makeCall.value(msg.value)(to, data));
    |        return true;
    |    }
  at BasicMultiTokenDeployer.sol(489)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BasicMultiToken':
    |        token.asmTransfer(to, amount);
    |        _inLendingMode += 1;
  > |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
    |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
  at BasicMultiTokenDeployer.sol(646)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiToken':
    |pragma solidity ^0.4.24;
    |
  > |// File: openzeppelin-solidity/contracts/ownership/Ownable.sol
    |
    |/**
  at BasicMultiTokenDeployer.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiToken':
    |
    |    function approveAndCall(address to, uint256 value, bytes data) public payable returns (bool) {
  > |        _sendersStack.push(msg.sender);
    |        approve(to, value);
    |        require(_caller.makeCall.value(msg.value)(to, data));
  at BasicMultiTokenDeployer.sol(480)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiToken':
    |// File: contracts/BasicMultiToken.sol
    |
  > |contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken {
    |    using CheckedERC20 for ERC20;
    |    using CheckedERC20 for DetailedERC20;
  at BasicMultiTokenDeployer.sol(520)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiToken':
    |        uint256 prevBalance = token.balanceOf(this);
    |        token.asmTransfer(to, amount);
  > |        _inLendingMode += 1;
    |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
    |        _inLendingMode -= 1;
  at BasicMultiTokenDeployer.sol(645)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiToken':
    |        _inLendingMode += 1;
    |        require(caller().makeCall.value(msg.value)(target, data), "lend: arbitrary call failed");
  > |        _inLendingMode -= 1;
    |        require(token.balanceOf(this) >= prevBalance, "lend: lended token must be refilled");
    |    }
  at BasicMultiTokenDeployer.sol(647)

[31mViolation[0m for LockedEther in contract 'BasicMultiTokenDeployer':
    |// File: contracts/network/BasicMultiTokenDeployer.sol
    |
  > |contract BasicMultiTokenDeployer is AbstractDeployer {
    |    function title() public view returns(string) {
    |        return "BasicMultiTokenDeployer";
  at BasicMultiTokenDeployer.sol(654)

[31mViolation[0m for MissingInputValidation in contract 'BasicMultiTokenDeployer':
    |    function title() public view returns(string);
    |
  > |    function deploy(bytes data)
    |        external onlyOwner returns(address result)
    |    {
  at BasicMultiTokenDeployer.sol(72)

[31mViolation[0m for MissingInputValidation in contract 'BasicMultiTokenDeployer':
    |    }
    |
  > |    function create(ERC20[] tokens, string name, string symbol, uint8 decimals)
    |        external returns(address)
    |    {
  at BasicMultiTokenDeployer.sol(659)

[31mViolation[0m for UnrestrictedWrite in contract 'BasicMultiTokenDeployer':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at BasicMultiTokenDeployer.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiTokenDeployer':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at BasicMultiTokenDeployer.sol(45)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicMultiTokenDeployer':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at BasicMultiTokenDeployer.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'BasicToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at BasicMultiTokenDeployer.sol(181)

[31mViolation[0m for MissingInputValidation in contract 'ERC1003Caller':
    |
    |contract ERC1003Caller is Ownable {
  > |    function makeCall(address target, bytes data) external payable onlyOwner returns (bool) {
    |        // solium-disable-next-line security/no-call-value
    |        return target.call.value(msg.value)(data);
  at BasicMultiTokenDeployer.sol(464)

[33mWarning[0m for TODAmount in contract 'ERC1003Caller':
    |    function makeCall(address target, bytes data) external payable onlyOwner returns (bool) {
    |        // solium-disable-next-line security/no-call-value
  > |        return target.call.value(msg.value)(data);
    |    }
    |}
  at BasicMultiTokenDeployer.sol(466)

[31mViolation[0m for UnhandledException in contract 'ERC1003Caller':
    |    function makeCall(address target, bytes data) external payable onlyOwner returns (bool) {
    |        // solium-disable-next-line security/no-call-value
  > |        return target.call.value(msg.value)(data);
    |    }
    |}
  at BasicMultiTokenDeployer.sol(466)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC1003Caller':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at BasicMultiTokenDeployer.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1003Caller':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at BasicMultiTokenDeployer.sol(45)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1003Caller':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at BasicMultiTokenDeployer.sol(63)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at BasicMultiTokenDeployer.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at BasicMultiTokenDeployer.sol(45)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at BasicMultiTokenDeployer.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at BasicMultiTokenDeployer.sol(181)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(_to != address(0));
    |
  > |    balances[_from] = balances[_from].sub(_value);
    |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  at BasicMultiTokenDeployer.sol(250)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[_from] = balances[_from].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    |    emit Transfer(_from, _to, _value);
  at BasicMultiTokenDeployer.sol(251)

[FILE] OwnedUpgradeabilityProxy.sol
Processing contract: OwnedUpgradeabilityProxy.sol:DataSet
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:Events
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:NumberCompressor
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:OwnedUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:Proxy
Processing contract: OwnedUpgradeabilityProxy.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:Winner
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for MissingInputValidation in contract 'OwnedUpgradeabilityProxy':
    |    * @param implementation representing the address of the new implementation to be set.
    |    */
  > |    function upgradeTo(address implementation) public onlyProxyOwner {
    |        _upgradeTo(implementation);
    |    }
  at OwnedUpgradeabilityProxy.sol(716)

[33mWarning[0m for MissingInputValidation in contract 'OwnedUpgradeabilityProxy':
    |    * signature of the implementation to be called with the needed payload
    |    */
  > |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
    |        require(address(this).call.value(msg.value)(data), "data is invalid");
  at OwnedUpgradeabilityProxy.sol(727)

[33mWarning[0m for TODAmount in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
  > |        require(address(this).call.value(msg.value)(data), "data is invalid");
    |    }
    |}
  at OwnedUpgradeabilityProxy.sol(729)

[33mWarning[0m for TODReceiver in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
  > |        require(address(this).call.value(msg.value)(data), "data is invalid");
    |    }
    |}
  at OwnedUpgradeabilityProxy.sol(729)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
  > |        require(address(this).call.value(msg.value)(data), "data is invalid");
    |    }
    |}
  at OwnedUpgradeabilityProxy.sol(729)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = implementationPosition;
    |        assembly {
  > |            sstore(position, newImplementation)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(635)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = proxyOwnerPosition;
    |        assembly {
  > |            sstore(position, newProxyOwner)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(698)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = implementationPosition;
    |        assembly {
  > |            sstore(position, newImplementation)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(635)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = implementationPosition;
    |        assembly {
  > |            sstore(position, newImplementation)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(635)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |                // assgin bonus to player, and the rest of the pond to platform
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
  > |                _player.transfer(bonus);
    |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
  at OwnedUpgradeabilityProxy.sol(450)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
    |                _player.transfer(bonus);
  > |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
    |                rounds[_roundID].winner = _player;
  at OwnedUpgradeabilityProxy.sol(451)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |        uint256 amount = count.mul(PRICE).mul(REFUND_RATE).div(100);
    |        rounds[curRoundID].pond = rounds[curRoundID].pond.sub(amount);
  > |        _player.transfer(amount);
    |
    |        emit onRefund(msg.sender, block.timestamp, _player, count, amount);
  at OwnedUpgradeabilityProxy.sol(492)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |        {
    |            uint256 last = rounds[curRoundID].pond;
  > |            platform.transfer(last);
    |            rounds[curRoundID].pond = 0;
    |
  at OwnedUpgradeabilityProxy.sol(501)

[31mViolation[0m for TODAmount in contract 'Winner':
    |                // assgin bonus to player, and the rest of the pond to platform
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
  > |                _player.transfer(bonus);
    |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
  at OwnedUpgradeabilityProxy.sol(450)

[33mWarning[0m for TODAmount in contract 'Winner':
    |        {
    |            uint256 last = rounds[curRoundID].pond;
  > |            platform.transfer(last);
    |            rounds[curRoundID].pond = 0;
    |
  at OwnedUpgradeabilityProxy.sol(501)

[33mWarning[0m for TODAmount in contract 'Winner':
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
    |                _player.transfer(bonus);
  > |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
    |                rounds[_roundID].winner = _player;
  at OwnedUpgradeabilityProxy.sol(451)

[33mWarning[0m for TODReceiver in contract 'Winner':
    |                // assgin bonus to player, and the rest of the pond to platform
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
  > |                _player.transfer(bonus);
    |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
  at OwnedUpgradeabilityProxy.sol(450)

[33mWarning[0m for TODReceiver in contract 'Winner':
    |        uint256 amount = count.mul(PRICE).mul(REFUND_RATE).div(100);
    |        rounds[curRoundID].pond = rounds[curRoundID].pond.sub(amount);
  > |        _player.transfer(amount);
    |
    |        emit onRefund(msg.sender, block.timestamp, _player, count, amount);
  at OwnedUpgradeabilityProxy.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Winner':
    |            drawnRoundID += 1;
    |
  > |            rounds[drawnRoundID].winningNumber = drawNumber();
    |            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;
    |            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;
  at OwnedUpgradeabilityProxy.sol(371)

[33mWarning[0m for UnrestrictedWrite in contract 'Winner':
    |
    |            rounds[drawnRoundID].winningNumber = drawNumber();
  > |            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;
    |            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;
    |
  at OwnedUpgradeabilityProxy.sol(372)

[33mWarning[0m for UnrestrictedWrite in contract 'Winner':
    |            rounds[drawnRoundID].winningNumber = drawNumber();
    |            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;
  > |            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;
    |
    |            emit onDraw(block.timestamp, drawnBlockNumber, drawnRoundID, rounds[drawnRoundID].winningNumber);
  at OwnedUpgradeabilityProxy.sol(373)

[FILE] RC_KYC.sol
Processing contract: RC_KYC.sol:AtomaxKyc
Processing contract: RC_KYC.sol:AtomaxKycInterface
Processing contract: RC_KYC.sol:MilestoneSystem
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC.sol:RC_KYC
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle12177887016078781158/mustExplicit -j 8 -F /tmp/souffle-0f6779e8-abbb-4399-9675-808253ea5aca -D /tmp/souffle-0f6779e8-abbb-4399-9675-808253ea5aca_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: RC_KYC.sol:RC_KYC
Processing contract: RC_KYC.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC.sol:TokedoDaico
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC.sol:tokenInterface
[33mWarning[0m for DAOConstantGas in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at RC_KYC.sol(518)

[31mViolation[0m for RepeatedCall in contract 'MilestoneSystem':
    |        
    |        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);
  > |        tokenContract.transfer(msg.sender, amount);
    |        
    |        emit Trust(msg.sender, amount);
  at RC_KYC.sol(443)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |		    money = address(this).balance;
    |		}
  > |        msg.sender.transfer(money);
    |        
    |        emit Refund(msg.sender, money);
  at RC_KYC.sol(477)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |		}
    |		
  > |        msg.sender.transfer(value);
    |    }
    |    
  at RC_KYC.sol(499)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at RC_KYC.sol(518)

[31mViolation[0m for TODReceiver in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at RC_KYC.sol(518)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MilestoneSystem':
    |		    money = address(this).balance;
    |		}
  > |        msg.sender.transfer(money);
    |        
    |        emit Refund(msg.sender, money);
  at RC_KYC.sol(477)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |        
    |        uint256 amountApplied = funds[step];
  > |        funds[step] = 0;
    |		step = step+1;
    |		
  at RC_KYC.sol(489)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |        uint256 amountApplied = funds[step];
    |        funds[step] = 0;
  > |		step = step+1;
    |		
    |		uint256 value;
  at RC_KYC.sol(490)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |    function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) {
    |        require( _wallet != address(0), "_wallet != address(0)" );
  > |        wallet = _wallet;
    |		return true;
    |    }
  at RC_KYC.sol(509)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |	function transferOwnership(address _newOwner) public onlyOwner {
    |		require(address(0) != _newOwner, "address(0) != _newOwner");
  > |		newOwner = _newOwner;
    |	}
    |
  at RC_KYC.sol(47)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |		require(msg.sender == newOwner, "msg.sender == newOwner");
    |		emit OwnershipTransferred(owner, msg.sender);
  > |		owner = msg.sender;
    |		newOwner = address(0);
    |	}
  at RC_KYC.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |		emit OwnershipTransferred(owner, msg.sender);
    |		owner = msg.sender;
  > |		newOwner = address(0);
    |	}
    |}
  at RC_KYC.sol(54)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    uint256 public tokenPrice;
    |
  > |    mapping(address => bool) public rc;
    |
    |    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {
  at RC_KYC.sol(301)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |	function sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) {
    |        return tokenContract.transfer(_buyer, _amount);
    |    }
  at RC_KYC.sol(320)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    event NewRC(address contr);
    |    
  > |    function addRC(address _rc) onlyOwner public {
    |        rc[ _rc ]  = true;
    |        emit NewRC(_rc);
  at RC_KYC.sol(326)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
    |        return tokenContract.transfer(to, value);
    |    }
  at RC_KYC.sol(331)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |    function setTokenContract(address _tokenContract) public onlyOwner {
    |        tokenContract = tokenInterface(_tokenContract);
    |    }
  at RC_KYC.sol(335)

[33mWarning[0m for TODAmount in contract 'TokedoDaico':
    |    
    |    function forwardEther() onlyRC payable public returns(bool) {
  > |        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
    |        return true;
    |    }
  at RC_KYC.sol(316)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'TokedoDaico':
    |    
    |    function forwardEther() onlyRC payable public returns(bool) {
  > |        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
    |        return true;
    |    }
  at RC_KYC.sol(316)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |	function transferOwnership(address _newOwner) public onlyOwner {
    |		require(address(0) != _newOwner, "address(0) != _newOwner");
  > |		newOwner = _newOwner;
    |	}
    |
  at RC_KYC.sol(47)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |		require(msg.sender == newOwner, "msg.sender == newOwner");
    |		emit OwnershipTransferred(owner, msg.sender);
  > |		owner = msg.sender;
    |		newOwner = address(0);
    |	}
  at RC_KYC.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |		emit OwnershipTransferred(owner, msg.sender);
    |		owner = msg.sender;
  > |		newOwner = address(0);
    |	}
    |}
  at RC_KYC.sol(54)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |    
    |    function addRC(address _rc) onlyOwner public {
  > |        rc[ _rc ]  = true;
    |        emit NewRC(_rc);
    |    }
  at RC_KYC.sol(327)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |    
    |    function setTokenContract(address _tokenContract) public onlyOwner {
  > |        tokenContract = tokenInterface(_tokenContract);
    |    }
    |}
  at RC_KYC.sol(336)

[FILE] RC_KYC_ADV.sol
Processing contract: RC_KYC_ADV.sol:AtomaxKyc
Processing contract: RC_KYC_ADV.sol:AtomaxKycInterface
Processing contract: RC_KYC_ADV.sol:MilestoneSystem
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC_ADV.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC_ADV.sol:RC_KYC_ADV
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle14826990563451741971/mustExplicit -j 8 -F /tmp/souffle-70fd2081-ebab-435d-8ff7-b691334caa16 -D /tmp/souffle-70fd2081-ebab-435d-8ff7-b691334caa16_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: RC_KYC_ADV.sol:RC_KYC_ADV
Processing contract: RC_KYC_ADV.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC_ADV.sol:TokedoDaico
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RC_KYC_ADV.sol:tokenInterface
[33mWarning[0m for DAOConstantGas in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at RC_KYC_ADV.sol(522)

[31mViolation[0m for RepeatedCall in contract 'MilestoneSystem':
    |        
    |        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);
  > |        tokenContract.transfer(msg.sender, amount);
    |        
    |        emit Trust(msg.sender, amount);
  at RC_KYC_ADV.sol(447)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |		    money = address(this).balance;
    |		}
  > |        msg.sender.transfer(money);
    |        
    |        emit Refund(msg.sender, money);
  at RC_KYC_ADV.sol(481)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |		}
    |		
  > |        msg.sender.transfer(value);
    |    }
    |    
  at RC_KYC_ADV.sol(503)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at RC_KYC_ADV.sol(522)

[31mViolation[0m for TODReceiver in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at RC_KYC_ADV.sol(522)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MilestoneSystem':
    |		    money = address(this).balance;
    |		}
  > |        msg.sender.transfer(money);
    |        
    |        emit Refund(msg.sender, money);
  at RC_KYC_ADV.sol(481)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |        
    |        uint256 amountApplied = funds[step];
  > |        funds[step] = 0;
    |		step = step+1;
    |		
  at RC_KYC_ADV.sol(493)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |        uint256 amountApplied = funds[step];
    |        funds[step] = 0;
  > |		step = step+1;
    |		
    |		uint256 value;
  at RC_KYC_ADV.sol(494)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |    function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) {
    |        require( _wallet != address(0), "_wallet != address(0)" );
  > |        wallet = _wallet;
    |		return true;
    |    }
  at RC_KYC_ADV.sol(513)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |	function transferOwnership(address _newOwner) public onlyOwner {
    |		require(address(0) != _newOwner, "address(0) != _newOwner");
  > |		newOwner = _newOwner;
    |	}
    |
  at RC_KYC_ADV.sol(47)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |		require(msg.sender == newOwner, "msg.sender == newOwner");
    |		emit OwnershipTransferred(owner, msg.sender);
  > |		owner = msg.sender;
    |		newOwner = address(0);
    |	}
  at RC_KYC_ADV.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |		emit OwnershipTransferred(owner, msg.sender);
    |		owner = msg.sender;
  > |		newOwner = address(0);
    |	}
    |}
  at RC_KYC_ADV.sol(54)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    uint256 public tokenPrice;
    |
  > |    mapping(address => bool) public rc;
    |
    |    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {
  at RC_KYC_ADV.sol(305)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |	function sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) {
    |        return tokenContract.transfer(_buyer, _amount);
    |    }
  at RC_KYC_ADV.sol(324)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    event NewRC(address contr);
    |    
  > |    function addRC(address _rc) onlyOwner public {
    |        rc[ _rc ]  = true;
    |        emit NewRC(_rc);
  at RC_KYC_ADV.sol(330)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
    |        return tokenContract.transfer(to, value);
    |    }
  at RC_KYC_ADV.sol(335)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |    function setTokenContract(address _tokenContract) public onlyOwner {
    |        tokenContract = tokenInterface(_tokenContract);
    |    }
  at RC_KYC_ADV.sol(339)

[33mWarning[0m for TODAmount in contract 'TokedoDaico':
    |    
    |    function forwardEther() onlyRC payable public returns(bool) {
  > |        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
    |        return true;
    |    }
  at RC_KYC_ADV.sol(320)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'TokedoDaico':
    |    
    |    function forwardEther() onlyRC payable public returns(bool) {
  > |        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
    |        return true;
    |    }
  at RC_KYC_ADV.sol(320)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |	function transferOwnership(address _newOwner) public onlyOwner {
    |		require(address(0) != _newOwner, "address(0) != _newOwner");
  > |		newOwner = _newOwner;
    |	}
    |
  at RC_KYC_ADV.sol(47)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |		require(msg.sender == newOwner, "msg.sender == newOwner");
    |		emit OwnershipTransferred(owner, msg.sender);
  > |		owner = msg.sender;
    |		newOwner = address(0);
    |	}
  at RC_KYC_ADV.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |		emit OwnershipTransferred(owner, msg.sender);
    |		owner = msg.sender;
  > |		newOwner = address(0);
    |	}
    |}
  at RC_KYC_ADV.sol(54)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |    
    |    function addRC(address _rc) onlyOwner public {
  > |        rc[ _rc ]  = true;
    |        emit NewRC(_rc);
    |    }
  at RC_KYC_ADV.sol(331)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |    
    |    function setTokenContract(address _tokenContract) public onlyOwner {
  > |        tokenContract = tokenInterface(_tokenContract);
    |    }
    |}
  at RC_KYC_ADV.sol(340)

[FILE] SuperFoMo3D.sol
Processing contract: SuperFoMo3D.sol:DiviesInterface
Processing contract: SuperFoMo3D.sol:F3DKeysCalcLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:F3DexternalSettingsInterface
Processing contract: SuperFoMo3D.sol:JIincForwarderInterface
Processing contract: SuperFoMo3D.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:PlayerBookInterface
Processing contract: SuperFoMo3D.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:SuperFoMo3D
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAOConstantGas in contract 'SuperFoMo3D':
    |    {
    |        require(customerBalance[msg.sender] >= _value,'please ensure you have enough balance');
  > |        msg.sender.transfer(_value);
    |        customerBalance[msg.sender] = customerBalance[msg.sender].sub(_value);
    |        return customerBalance[msg.sender];
  at SuperFoMo3D.sol(462)

[33mWarning[0m for TODAmount in contract 'SuperFoMo3D':
    |        address _addr = msg.sender;
    |        uint256 _paid = msg.value;
  > |        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);
    |        
    |        uint256 _pID = pIDxAddr_[_addr];
  at SuperFoMo3D.sol(523)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SuperFoMo3D':
    |        address _addr = msg.sender;
    |        uint256 _paid = msg.value;
  > |        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);
    |        
    |        uint256 _pID = pIDxAddr_[_addr];
  at SuperFoMo3D.sol(523)

[FILE] TokedoDaico.sol
Processing contract: TokedoDaico.sol:AtomaxKyc
Processing contract: TokedoDaico.sol:AtomaxKycInterface
Processing contract: TokedoDaico.sol:MilestoneSystem
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: TokedoDaico.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: TokedoDaico.sol:RC_KYC
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle17582460429397357356/mustExplicit -j 8 -F /tmp/souffle-1f601739-28eb-4ce4-bb8b-f7404676ec91 -D /tmp/souffle-1f601739-28eb-4ce4-bb8b-f7404676ec91_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: TokedoDaico.sol:RC_KYC
Processing contract: TokedoDaico.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: TokedoDaico.sol:TokedoDaico
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: TokedoDaico.sol:tokenInterface
[33mWarning[0m for DAOConstantGas in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at TokedoDaico.sol(518)

[31mViolation[0m for RepeatedCall in contract 'MilestoneSystem':
    |        
    |        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);
  > |        tokenContract.transfer(msg.sender, amount);
    |        
    |        emit Trust(msg.sender, amount);
  at TokedoDaico.sol(443)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |		    money = address(this).balance;
    |		}
  > |        msg.sender.transfer(money);
    |        
    |        emit Refund(msg.sender, money);
  at TokedoDaico.sol(477)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |		}
    |		
  > |        msg.sender.transfer(value);
    |    }
    |    
  at TokedoDaico.sol(499)

[33mWarning[0m for TODAmount in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at TokedoDaico.sol(518)

[31mViolation[0m for TODReceiver in contract 'MilestoneSystem':
    |        if( etherReceived < funds[0]  ) {
    |            require( wallet != address(0), "wallet != address(0)" );
  > |            wallet.transfer(msg.value);
    |        }
    |        
  at TokedoDaico.sol(518)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MilestoneSystem':
    |		    money = address(this).balance;
    |		}
  > |        msg.sender.transfer(money);
    |        
    |        emit Refund(msg.sender, money);
  at TokedoDaico.sol(477)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |        
    |        uint256 amountApplied = funds[step];
  > |        funds[step] = 0;
    |		step = step+1;
    |		
  at TokedoDaico.sol(489)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |        uint256 amountApplied = funds[step];
    |        funds[step] = 0;
  > |		step = step+1;
    |		
    |		uint256 value;
  at TokedoDaico.sol(490)

[33mWarning[0m for UnrestrictedWrite in contract 'MilestoneSystem':
    |    function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) {
    |        require( _wallet != address(0), "_wallet != address(0)" );
  > |        wallet = _wallet;
    |		return true;
    |    }
  at TokedoDaico.sol(509)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |	function transferOwnership(address _newOwner) public onlyOwner {
    |		require(address(0) != _newOwner, "address(0) != _newOwner");
  > |		newOwner = _newOwner;
    |	}
    |
  at TokedoDaico.sol(47)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |		require(msg.sender == newOwner, "msg.sender == newOwner");
    |		emit OwnershipTransferred(owner, msg.sender);
  > |		owner = msg.sender;
    |		newOwner = address(0);
    |	}
  at TokedoDaico.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |		emit OwnershipTransferred(owner, msg.sender);
    |		owner = msg.sender;
  > |		newOwner = address(0);
    |	}
    |}
  at TokedoDaico.sol(54)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    uint256 public tokenPrice;
    |
  > |    mapping(address => bool) public rc;
    |
    |    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {
  at TokedoDaico.sol(301)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |	function sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) {
    |        return tokenContract.transfer(_buyer, _amount);
    |    }
  at TokedoDaico.sol(320)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    event NewRC(address contr);
    |    
  > |    function addRC(address _rc) onlyOwner public {
    |        rc[ _rc ]  = true;
    |        emit NewRC(_rc);
  at TokedoDaico.sol(326)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
    |        return tokenContract.transfer(to, value);
    |    }
  at TokedoDaico.sol(331)

[31mViolation[0m for MissingInputValidation in contract 'TokedoDaico':
    |    }
    |    
  > |    function setTokenContract(address _tokenContract) public onlyOwner {
    |        tokenContract = tokenInterface(_tokenContract);
    |    }
  at TokedoDaico.sol(335)

[33mWarning[0m for TODAmount in contract 'TokedoDaico':
    |    
    |    function forwardEther() onlyRC payable public returns(bool) {
  > |        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
    |        return true;
    |    }
  at TokedoDaico.sol(316)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'TokedoDaico':
    |    
    |    function forwardEther() onlyRC payable public returns(bool) {
  > |        require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
    |        return true;
    |    }
  at TokedoDaico.sol(316)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |	function transferOwnership(address _newOwner) public onlyOwner {
    |		require(address(0) != _newOwner, "address(0) != _newOwner");
  > |		newOwner = _newOwner;
    |	}
    |
  at TokedoDaico.sol(47)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |		require(msg.sender == newOwner, "msg.sender == newOwner");
    |		emit OwnershipTransferred(owner, msg.sender);
  > |		owner = msg.sender;
    |		newOwner = address(0);
    |	}
  at TokedoDaico.sol(53)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |		emit OwnershipTransferred(owner, msg.sender);
    |		owner = msg.sender;
  > |		newOwner = address(0);
    |	}
    |}
  at TokedoDaico.sol(54)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |    
    |    function addRC(address _rc) onlyOwner public {
  > |        rc[ _rc ]  = true;
    |        emit NewRC(_rc);
    |    }
  at TokedoDaico.sol(327)

[33mWarning[0m for UnrestrictedWrite in contract 'TokedoDaico':
    |    
    |    function setTokenContract(address _tokenContract) public onlyOwner {
  > |        tokenContract = tokenInterface(_tokenContract);
    |    }
    |}
  at TokedoDaico.sol(336)

[FILE] CappedSTOFactory.sol
Processing contract: CappedSTOFactory.sol:BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:CappedSTO
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:CappedSTOFactory
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:DetailedERC20
Processing contract: CappedSTOFactory.sol:ERC20
Processing contract: CappedSTOFactory.sol:ERC20Basic
Processing contract: CappedSTOFactory.sol:IModule
Processing contract: CappedSTOFactory.sol:IModuleFactory
Processing contract: CappedSTOFactory.sol:IST20
Processing contract: CappedSTOFactory.sol:ISTO
Processing contract: CappedSTOFactory.sol:ISecurityToken
Processing contract: CappedSTOFactory.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:Pausable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:ReentrancyGuard
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CappedSTOFactory.sol:StandardToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'BasicToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at CappedSTOFactory.sol(139)

[31mViolation[0m for DAOConstantGas in contract 'CappedSTO':
    |    */
    |    function _forwardFunds() internal {
  > |        wallet.transfer(msg.value);
    |    }
    |
  at CappedSTOFactory.sol(992)

[31mViolation[0m for RepeatedCall in contract 'CappedSTO':
    |     */
    |    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {
  > |        require(polyToken.transferFrom(address(this), IModuleFactory(factory).owner(), _amount), "Unable to take fee");
    |        return true;
    |    }
  at CappedSTOFactory.sol(625)

[33mWarning[0m for TODAmount in contract 'CappedSTO':
    |    */
    |    function _forwardFunds() internal {
  > |        wallet.transfer(msg.value);
    |    }
    |
  at CappedSTOFactory.sol(992)

[31mViolation[0m for TODReceiver in contract 'CappedSTO':
    |    */
    |    function _forwardFunds() internal {
  > |        wallet.transfer(msg.value);
    |    }
    |
  at CappedSTOFactory.sol(992)

[31mViolation[0m for UnrestrictedWrite in contract 'CappedSTO':
    |  modifier nonReentrant() {
    |    require(!reentrancyLock);
  > |    reentrancyLock = true;
    |    _;
    |    reentrancyLock = false;
  at CappedSTOFactory.sol(722)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |    function _pause() internal {
    |        require(!paused);
  > |        paused = true;
    |        emit Pause(now);
    |    }
  at CappedSTOFactory.sol(34)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |    function _unpause() internal {
    |        require(paused);
  > |        paused = false;
    |        emit Unpause(now);
    |    }
  at CappedSTOFactory.sol(43)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        require(_newEndDate >= endTime);
    |        super._unpause();
  > |        endTime = _newEndDate;
    |    }
    |
  at CappedSTOFactory.sol(683)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        require(_startTime >= now && _endTime > _startTime, "Date parameters are not valid");
    |        require(_cap > 0, "Cap should be greater than 0");
  > |        startTime = _startTime;
    |        endTime = _endTime;
    |        cap = _cap;
  at CappedSTOFactory.sol(800)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        require(_cap > 0, "Cap should be greater than 0");
    |        startTime = _startTime;
  > |        endTime = _endTime;
    |        cap = _cap;
    |        rate = _rate;
  at CappedSTOFactory.sol(801)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        startTime = _startTime;
    |        endTime = _endTime;
  > |        cap = _cap;
    |        rate = _rate;
    |        wallet = _fundsReceiver;
  at CappedSTOFactory.sol(802)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        endTime = _endTime;
    |        cap = _cap;
  > |        rate = _rate;
    |        wallet = _fundsReceiver;
    |        _check(_fundRaiseType);
  at CappedSTOFactory.sol(803)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        cap = _cap;
    |        rate = _rate;
  > |        wallet = _fundsReceiver;
    |        _check(_fundRaiseType);
    |    }
  at CappedSTOFactory.sol(804)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        require(_fundraiseType == 0 || _fundraiseType == 1, "Not a valid fundraise type");
    |        if (_fundraiseType == 0) {
  > |            fundraiseType = FundraiseType.ETH;
    |        }
    |        if (_fundraiseType == 1) {
  at CappedSTOFactory.sol(1002)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTO':
    |        if (_fundraiseType == 1) {
    |            require(address(polyToken) != address(0), "Address of the polyToken should not be 0x");
  > |            fundraiseType = FundraiseType.POLY;
    |        }
    |    }
  at CappedSTOFactory.sol(1006)

[31mViolation[0m for LockedEther in contract 'CappedSTOFactory':
    | * @title Factory for deploying CappedSTO module
    | */
  > |contract CappedSTOFactory is IModuleFactory {
    |
    |    /**
  at CappedSTOFactory.sol(1025)

[31mViolation[0m for MissingInputValidation in contract 'CappedSTOFactory':
    |     * @param _newSetupCost new setup cost
    |     */
  > |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
    |        setupCost = _newSetupCost;
  at CappedSTOFactory.sol(538)

[31mViolation[0m for MissingInputValidation in contract 'CappedSTOFactory':
    |     * @param _newUsageCost new usage cost
    |     */
  > |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
    |        usageCost = _newUsageCost;
  at CappedSTOFactory.sol(547)

[31mViolation[0m for MissingInputValidation in contract 'CappedSTOFactory':
    |     * @param _newSubscriptionCost new subscription cost
    |     */
  > |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
    |        monthlySubscriptionCost = _newSubscriptionCost;
  at CappedSTOFactory.sol(556)

[31mViolation[0m for MissingInputValidation in contract 'CappedSTOFactory':
    |     * @return address Contract address of the Module
    |     */
  > |    function deploy(bytes _data) external returns(address) {
    |        if(setupCost > 0)
    |            require(polyToken.transferFrom(msg.sender, owner, setupCost), "Failed transferFrom because of sufficent Allowance is not provided");
  at CappedSTOFactory.sol(1041)

[31mViolation[0m for UnrestrictedWrite in contract 'CappedSTOFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CappedSTOFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTOFactory':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at CappedSTOFactory.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTOFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CappedSTOFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTOFactory':
    |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
  > |        setupCost = _newSetupCost;
    |    }
    |
  at CappedSTOFactory.sol(540)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTOFactory':
    |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
  > |        usageCost = _newUsageCost;
    |    }
    |
  at CappedSTOFactory.sol(549)

[33mWarning[0m for UnrestrictedWrite in contract 'CappedSTOFactory':
    |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
  > |        monthlySubscriptionCost = _newSubscriptionCost;
    |        
    |    }
  at CappedSTOFactory.sol(558)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CappedSTOFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at CappedSTOFactory.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CappedSTOFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at CappedSTOFactory.sol(139)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(_value <= allowed[_from][msg.sender]);
    |
  > |    balances[_from] = balances[_from].sub(_value);
    |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  at CappedSTOFactory.sol(204)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[_from] = balances[_from].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    |    emit Transfer(_from, _to, _value);
  at CappedSTOFactory.sol(205)

[FILE] PvPCrash.sol
Processing contract: PvPCrash.sol:FairExchange
Processing contract: PvPCrash.sol:PvPCrash
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PvPCrash.sol:PvPCrashFormula
Processing contract: PvPCrash.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'PvPCrash':
    |            } else {
    |                if (_userBalance > 0) {
  > |                    _user.transfer(_balance);
    |                    if (investments[_user][_roundCount].mul(95).div(100) > _balance) {
    |                        
  at PvPCrash.sol(293)

[31mViolation[0m for DAO in contract 'PvPCrash':
    |                    emit Withdraw(_user, _userBalance);
    |                } else {
  > |                    _user.transfer(_balance);
    |                    roundEnded = true;
    |                    roundEndTime[_roundCount] = _currentTimestamp;
  at PvPCrash.sol(317)

[33mWarning[0m for DAO in contract 'PvPCrash':
    |                _userBalance = investments[_user][_roundCount].mul(refundRatio).div(100);
    |                if (_balance > _userBalance) {
  > |                    _user.transfer(_userBalance);
    |                    emit Withdraw(_user, _userBalance);
    |                } else {
  at PvPCrash.sol(314)

[31mViolation[0m for TODAmount in contract 'PvPCrash':
    |            } else {
    |                if (_userBalance > 0) {
  > |                    _user.transfer(_balance);
    |                    if (investments[_user][_roundCount].mul(95).div(100) > _balance) {
    |                        
  at PvPCrash.sol(293)

[33mWarning[0m for TODAmount in contract 'PvPCrash':
    |            investments[_user][_roundCount] = _amount;
    |            userInputAmount[_user] = userInputAmount[_user].add(_amount);
  > |            bool _status = address(fairExchangeContract).call.value(_amount / 20).gas(1000000)();
    |            require(_status);
    |            emit FairTokenBuy(_amount / 20, myTokens());
  at PvPCrash.sol(249)

[33mWarning[0m for TODAmount in contract 'PvPCrash':
    |                _userBalance = investments[_user][_roundCount].mul(refundRatio).div(100);
    |                if (_balance > _userBalance) {
  > |                    _user.transfer(_userBalance);
    |                    emit Withdraw(_user, _userBalance);
    |                } else {
  at PvPCrash.sol(314)

[33mWarning[0m for TODAmount in contract 'PvPCrash':
    |                    emit Withdraw(_user, _userBalance);
    |                } else {
  > |                    _user.transfer(_balance);
    |                    roundEnded = true;
    |                    roundEndTime[_roundCount] = _currentTimestamp;
  at PvPCrash.sol(317)

[33mWarning[0m for TODReceiver in contract 'PvPCrash':
    |                _userBalance = investments[_user][_roundCount].mul(refundRatio).div(100);
    |                if (_balance > _userBalance) {
  > |                    _user.transfer(_userBalance);
    |                    emit Withdraw(_user, _userBalance);
    |                } else {
  at PvPCrash.sol(314)

[33mWarning[0m for TODReceiver in contract 'PvPCrash':
    |                    emit Withdraw(_user, _userBalance);
    |                } else {
  > |                    _user.transfer(_balance);
    |                    roundEnded = true;
    |                    roundEndTime[_roundCount] = _currentTimestamp;
  at PvPCrash.sol(317)

[FILE] WPPPresale.sol
Processing contract: WPPPresale.sol:ERC20
Processing contract: WPPPresale.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WPPPresale.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WPPPresale.sol:WPPPresale
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WPPPresale.sol:WPPToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at WPPPresale.sol(54)

[31mViolation[0m for DAOConstantGas in contract 'WPPPresale':
    |			uint256 refund = weiAmount - real.mul(100).div(110).div(rate);
    |
  > |			beneficiary.transfer(refund);
    |
    |			transferToken(beneficiary, real);
  at WPPPresale.sol(239)

[31mViolation[0m for DAOConstantGas in contract 'WPPPresale':
    |	// override to create custom fund forwarding mechanisms
    |	function forwardFunds(uint256 weiAmount) internal {
  > |		multisigwallet.transfer(weiAmount);
    |	}
    |
  at WPPPresale.sol(275)

[31mViolation[0m for RepeatedCall in contract 'WPPPresale':
    |	// override to create custom token transfer mechanism, eg. pull pattern
    |	function transferToken(address beneficiary, uint256 tokenamount) internal {
  > |		wpp.transfer(beneficiary, tokenamount);
    |		// address(wpp).call(bytes4(keccak256("transfer(address, uint256)")), beneficiary,tokenamount);
    |	}
  at WPPPresale.sol(268)

[33mWarning[0m for TODAmount in contract 'WPPPresale':
    |			uint256 refund = weiAmount - real.mul(100).div(110).div(rate);
    |
  > |			beneficiary.transfer(refund);
    |
    |			transferToken(beneficiary, real);
  at WPPPresale.sol(239)

[33mWarning[0m for TODAmount in contract 'WPPPresale':
    |	// override to create custom fund forwarding mechanisms
    |	function forwardFunds(uint256 weiAmount) internal {
  > |		multisigwallet.transfer(weiAmount);
    |	}
    |
  at WPPPresale.sol(275)

[33mWarning[0m for TODReceiver in contract 'WPPPresale':
    |	// override to create custom fund forwarding mechanisms
    |	function forwardFunds(uint256 weiAmount) internal {
  > |		multisigwallet.transfer(weiAmount);
    |	}
    |
  at WPPPresale.sol(275)

[33mWarning[0m for TODReceiver in contract 'WPPPresale':
    |			uint256 refund = weiAmount - real.mul(100).div(110).div(rate);
    |
  > |			beneficiary.transfer(refund);
    |
    |			transferToken(beneficiary, real);
  at WPPPresale.sol(239)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPPresale':
    |	function setWhitelist(address _addr) public onlyOwners {
    |        require(_addr != address(0));
  > |        isWhitelisted[_addr] = true;
    |        emit WhitelistSet(_addr, true);
    |    }
  at WPPPresale.sol(293)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPPresale':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at WPPPresale.sol(54)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPPresale':
    |
    |	function setAdminlist(address _addr, bool _state) public onlyOwner {
  > |		isAdminlisted[_addr] = _state;
    |		emit AdminlistSet(_addr, _state);
    |	}
  at WPPPresale.sol(287)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPPresale':
    |	function setRate(uint256 _rate) public onlyOwner returns (bool) {
    |		require (now >= startTime && now <= endTime);
  > |		rate = _rate;
    |	}
    |
  at WPPPresale.sol(316)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPPresale':
    |		require(remain > 0);
    |		wpp.transfer(multisigwallet, remain);
  > |		remain = 0;
    |		emit TreatRemainToken();
    |		return true;
  at WPPPresale.sol(323)

[31mViolation[0m for LockedEther in contract 'WPPToken':
    | * The WPPToken contract does this and that...
    | */
  > |contract WPPToken is ERC20, Ownable {
    |
    |	using SafeMath for uint256;
  at WPPPresale.sol(92)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPToken':
    |        
    |        _balances[msg.sender] = _balances[msg.sender].sub(wad);
  > |        _balances[dst] = _balances[dst].add(wad);
    |        
    |        emit Transfer(msg.sender, dst, wad);
  at WPPPresale.sol(128)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPToken':
    |        
    |        _approvals[src][msg.sender] = _approvals[src][msg.sender].sub(wad);
  > |        _balances[src] = _balances[src].sub(wad);
    |        _balances[dst] = _balances[dst].add(wad);
    |        
  at WPPPresale.sol(140)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPToken':
    |        _approvals[src][msg.sender] = _approvals[src][msg.sender].sub(wad);
    |        _balances[src] = _balances[src].sub(wad);
  > |        _balances[dst] = _balances[dst].add(wad);
    |        
    |        emit Transfer(src, dst, wad);
  at WPPPresale.sol(141)

[33mWarning[0m for UnrestrictedWrite in contract 'WPPToken':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at WPPPresale.sol(54)

[FILE] FastGameMultiplier.sol
Processing contract: FastGameMultiplier.sol:FastGameMultiplier
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'FastGameMultiplier':
    |            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor
    |                    
  > |                dep.depositor.send(dep.expect); 
    |                money -= dep.expect;          
    |                
  at FastGameMultiplier.sol(131)

[31mViolation[0m for DAO in contract 'FastGameMultiplier':
    |                //Here we don't have enough money so partially pay to investor
    |
  > |                dep.depositor.send(money);      //Send to him everything we have
    |                money -= dep.expect;            //update money left
    |
  at FastGameMultiplier.sol(141)

[31mViolation[0m for DAOConstantGas in contract 'FastGameMultiplier':
    |            Deposit storage dep = queue[i]; //get the info of the first investor
    |
  > |                dep.depositor.send(dep.deposit); //Игра не состоялась, возврат
    |                money -= dep.deposit;            
    |                
  at FastGameMultiplier.sol(167)

[31mViolation[0m for DAOConstantGas in contract 'FastGameMultiplier':
    |        }
    |
  > |        queue[lastDepositInfoForPrize.index].depositor.send(prize);
    |        
    |        proceedToNewStage(getCurrentStageByTime() + 1);
  at FastGameMultiplier.sol(251)

[33mWarning[0m for DAOConstantGas in contract 'FastGameMultiplier':
    |        //Send small part to tech support
    |        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);
  > |        support.send(moneyS);
    |        money -= moneyS;
    |        
  at FastGameMultiplier.sol(121)

[33mWarning[0m for DAOConstantGas in contract 'FastGameMultiplier':
    |        if(previosDepositInfoForPrize.index > 0){
    |            uint prizePrevios = prize*10/100;
  > |            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);
    |            prize -= prizePrevios;
    |        }
  at FastGameMultiplier.sol(247)

[31mViolation[0m for TODAmount in contract 'FastGameMultiplier':
    |        if(previosDepositInfoForPrize.index > 0){
    |            uint prizePrevios = prize*10/100;
  > |            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);
    |            prize -= prizePrevios;
    |        }
  at FastGameMultiplier.sol(247)

[31mViolation[0m for TODAmount in contract 'FastGameMultiplier':
    |        }
    |
  > |        queue[lastDepositInfoForPrize.index].depositor.send(prize);
    |        
    |        proceedToNewStage(getCurrentStageByTime() + 1);
  at FastGameMultiplier.sol(251)

[33mWarning[0m for TODAmount in contract 'FastGameMultiplier':
    |        //Send small part to tech support
    |        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);
  > |        support.send(moneyS);
    |        money -= moneyS;
    |        
  at FastGameMultiplier.sol(121)

[33mWarning[0m for TODAmount in contract 'FastGameMultiplier':
    |            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor
    |                    
  > |                dep.depositor.send(dep.expect); 
    |                money -= dep.expect;          
    |                
  at FastGameMultiplier.sol(131)

[33mWarning[0m for TODAmount in contract 'FastGameMultiplier':
    |                //Here we don't have enough money so partially pay to investor
    |
  > |                dep.depositor.send(money);      //Send to him everything we have
    |                money -= dep.expect;            //update money left
    |
  at FastGameMultiplier.sol(141)

[33mWarning[0m for TODAmount in contract 'FastGameMultiplier':
    |            Deposit storage dep = queue[i]; //get the info of the first investor
    |
  > |                dep.depositor.send(dep.deposit); //Игра не состоялась, возврат
    |                money -= dep.deposit;            
    |                
  at FastGameMultiplier.sol(167)

[33mWarning[0m for TODReceiver in contract 'FastGameMultiplier':
    |        //Send small part to tech support
    |        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);
  > |        support.send(moneyS);
    |        money -= moneyS;
    |        
  at FastGameMultiplier.sol(121)

[33mWarning[0m for TODReceiver in contract 'FastGameMultiplier':
    |            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor
    |                    
  > |                dep.depositor.send(dep.expect); 
    |                money -= dep.expect;          
    |                
  at FastGameMultiplier.sol(131)

[33mWarning[0m for TODReceiver in contract 'FastGameMultiplier':
    |                //Here we don't have enough money so partially pay to investor
    |
  > |                dep.depositor.send(money);      //Send to him everything we have
    |                money -= dep.expect;            //update money left
    |
  at FastGameMultiplier.sol(141)

[33mWarning[0m for TODReceiver in contract 'FastGameMultiplier':
    |            Deposit storage dep = queue[i]; //get the info of the first investor
    |
  > |                dep.depositor.send(dep.deposit); //Игра не состоялась, возврат
    |                money -= dep.deposit;            
    |                
  at FastGameMultiplier.sol(167)

[33mWarning[0m for TODReceiver in contract 'FastGameMultiplier':
    |        if(previosDepositInfoForPrize.index > 0){
    |            uint prizePrevios = prize*10/100;
  > |            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);
    |            prize -= prizePrevios;
    |        }
  at FastGameMultiplier.sol(247)

[33mWarning[0m for TODReceiver in contract 'FastGameMultiplier':
    |        }
    |
  > |        queue[lastDepositInfoForPrize.index].depositor.send(prize);
    |        
    |        proceedToNewStage(getCurrentStageByTime() + 1);
  at FastGameMultiplier.sol(251)

[31mViolation[0m for UnhandledException in contract 'FastGameMultiplier':
    |        //Send small part to tech support
    |        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);
  > |        support.send(moneyS);
    |        money -= moneyS;
    |        
  at FastGameMultiplier.sol(121)

[31mViolation[0m for UnhandledException in contract 'FastGameMultiplier':
    |            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor
    |                    
  > |                dep.depositor.send(dep.expect); 
    |                money -= dep.expect;          
    |                
  at FastGameMultiplier.sol(131)

[31mViolation[0m for UnhandledException in contract 'FastGameMultiplier':
    |                //Here we don't have enough money so partially pay to investor
    |
  > |                dep.depositor.send(money);      //Send to him everything we have
    |                money -= dep.expect;            //update money left
    |
  at FastGameMultiplier.sol(141)

[31mViolation[0m for UnhandledException in contract 'FastGameMultiplier':
    |            Deposit storage dep = queue[i]; //get the info of the first investor
    |
  > |                dep.depositor.send(dep.deposit); //Игра не состоялась, возврат
    |                money -= dep.deposit;            
    |                
  at FastGameMultiplier.sol(167)

[31mViolation[0m for UnhandledException in contract 'FastGameMultiplier':
    |        }
    |
  > |        queue[lastDepositInfoForPrize.index].depositor.send(prize);
    |        
    |        proceedToNewStage(getCurrentStageByTime() + 1);
  at FastGameMultiplier.sol(251)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FastGameMultiplier':
    |            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor
    |                    
  > |                dep.depositor.send(dep.expect); 
    |                money -= dep.expect;          
    |                
  at FastGameMultiplier.sol(131)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FastGameMultiplier':
    |                //Here we don't have enough money so partially pay to investor
    |
  > |                dep.depositor.send(money);      //Send to him everything we have
    |                money -= dep.expect;            //update money left
    |
  at FastGameMultiplier.sol(141)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FastGameMultiplier':
    |            Deposit storage dep = queue[i]; //get the info of the first investor
    |
  > |                dep.depositor.send(dep.deposit); //Игра не состоялась, возврат
    |                money -= dep.deposit;            
    |                
  at FastGameMultiplier.sol(167)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |pragma solidity ^0.4.25;
    |
  > |contract FastGameMultiplier {
    |
    |    //адрес поддержки
  at FastGameMultiplier.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |                
    |                //После выплаты депозиты + процента удаляется из очереди this investor is fully paid, so remove him
  > |                delete queue[i];
    |            
    |                
  at FastGameMultiplier.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |        }
    |
  > |        currentReceiverIndex = i; //Update the index of the current first investor
    |    }
    |    
  at FastGameMultiplier.sol(151)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |                
    |                //После выплаты депозиты + процента удаляется из очереди this investor is fully paid, so remove him
  > |                delete queue[i];
    |
    |        }
  at FastGameMultiplier.sol(171)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |        }
    |
  > |        prizeStageAmount = 0; //Вернули деньги, джека текущей очереди нет.
    |        proceedToNewStage(getCurrentStageByTime() + 1);
    |    }
  at FastGameMultiplier.sol(175)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |        prizeStageAmount = 0;
    |        delete queue;
  > |        delete previosDepositInfoForPrize;
    |        delete lastDepositInfoForPrize;
    |    }
  at FastGameMultiplier.sol(226)

[33mWarning[0m for UnrestrictedWrite in contract 'FastGameMultiplier':
    |        delete queue;
    |        delete previosDepositInfoForPrize;
  > |        delete lastDepositInfoForPrize;
    |    }
    |
  at FastGameMultiplier.sol(227)

[FILE] Protocol.sol
Processing contract: Protocol.sol:DateTime
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Protocol.sol:ERC20x
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Protocol.sol:ERC20xVariables
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Protocol.sol:OptionToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Protocol.sol:Protocol
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Protocol.sol:Token
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Protocol.sol:VariableSupplyToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'DateTime':
    |pragma solidity ^0.4.18;
    |
  > |contract DateTime {
    |        /*
    |         *  Date and Time utilities for ethereum contracts
  at Protocol.sol(3)

[31mViolation[0m for LockedEther in contract 'ERC20x':
    |}
    |
  > |contract ERC20x is ERC20xVariables {
    |
    |    function transfer(address _to, uint256 _value) public returns (bool success) {
  at Protocol.sol(245)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
  > |    mapping(address => uint) public balances;
    |    mapping(address => mapping(address => uint)) public allowed;
    |
  at Protocol.sol(223)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
    |    mapping(address => uint) public balances;
  > |    mapping(address => mapping(address => uint)) public allowed;
    |
    |    uint8 public constant decimals = 18;
  at Protocol.sol(224)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |    event Created(address creator, uint supply);
    |
  > |    function balanceOf(address _owner) public view returns (uint256 balance) {
    |        return balances[_owner];
    |    }
  at Protocol.sol(236)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |    }
    |
  > |    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    |        return allowed[_owner][_spender];
    |    }
  at Protocol.sol(240)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |contract ERC20x is ERC20xVariables {
    |
  > |    function transfer(address _to, uint256 _value) public returns (bool success) {
    |        _transferBalance(msg.sender, _to, _value);
    |        emit Transfer(msg.sender, _to, _value);
  at Protocol.sol(247)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |    }
    |
  > |    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    |        uint256 allowance = allowed[_from][msg.sender];
    |        require(allowance >= _value);
  at Protocol.sol(253)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |    }
    |
  > |    function approve(address _spender, uint256 _value) public returns (bool success) {
    |        allowed[msg.sender][_spender] = _value;
    |        emit Approval(msg.sender, _spender, _value);
  at Protocol.sol(264)

[31mViolation[0m for MissingInputValidation in contract 'ERC20x':
    |    }
    |
  > |    function transferToContract(address _to, uint256 _value, bytes data) public returns (bool) {
    |        _transferBalance(msg.sender, _to, _value);
    |        bytes4 sig = bytes4(keccak256("receiveTokens(address,uint256,bytes)"));
  at Protocol.sol(270)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC20x':
    |    function _transferBalance(address _from, address _to, uint _value) internal {
    |        require(balances[_from] >= _value);
  > |        balances[_from] -= _value;
    |        balances[_to] += _value;
    |    }
  at Protocol.sol(280)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC20x':
    |        require(balances[_from] >= _value);
    |        balances[_from] -= _value;
  > |        balances[_to] += _value;
    |    }
    |}
  at Protocol.sol(281)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC20x':
    |        require(balances[_from] >= _value);
    |        balances[_from] -= _value;
  > |        balances[_to] += _value;
    |    }
    |}
  at Protocol.sol(281)

[31mViolation[0m for LockedEther in contract 'ERC20xVariables':
    |}
    |
  > |contract ERC20xVariables {
    |    address public creator;
    |    address public lib;
  at Protocol.sol(218)

[31mViolation[0m for MissingInputValidation in contract 'ERC20xVariables':
    |
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
  > |    mapping(address => uint) public balances;
    |    mapping(address => mapping(address => uint)) public allowed;
    |
  at Protocol.sol(223)

[31mViolation[0m for MissingInputValidation in contract 'ERC20xVariables':
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
    |    mapping(address => uint) public balances;
  > |    mapping(address => mapping(address => uint)) public allowed;
    |
    |    uint8 public constant decimals = 18;
  at Protocol.sol(224)

[31mViolation[0m for MissingInputValidation in contract 'ERC20xVariables':
    |    event Created(address creator, uint supply);
    |
  > |    function balanceOf(address _owner) public view returns (uint256 balance) {
    |        return balances[_owner];
    |    }
  at Protocol.sol(236)

[31mViolation[0m for MissingInputValidation in contract 'ERC20xVariables':
    |    }
    |
  > |    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    |        return allowed[_owner][_spender];
    |    }
  at Protocol.sol(240)

[31mViolation[0m for MissingInputValidation in contract 'OptionToken':
    |
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
  > |    mapping(address => uint) public balances;
    |    mapping(address => mapping(address => uint)) public allowed;
    |
  at Protocol.sol(223)

[31mViolation[0m for MissingInputValidation in contract 'OptionToken':
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
    |    mapping(address => uint) public balances;
  > |    mapping(address => mapping(address => uint)) public allowed;
    |
    |    uint8 public constant decimals = 18;
  at Protocol.sol(224)

[31mViolation[0m for MissingInputValidation in contract 'OptionToken':
    |    event Created(address creator, uint supply);
    |
  > |    function balanceOf(address _owner) public view returns (uint256 balance) {
    |        return balances[_owner];
    |    }
  at Protocol.sol(236)

[31mViolation[0m for MissingInputValidation in contract 'OptionToken':
    |    }
    |
  > |    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    |        return allowed[_owner][_spender];
    |    }
  at Protocol.sol(240)

[33mWarning[0m for DAO in contract 'Protocol':
    |                msg.sender.transfer(amount);
    |            } else {
  > |                result = msg.sender.call.value(amount)(RECEIVE_ETH, _series, amount);
    |                require(result);
    |            }
  at Protocol.sol(576)

[31mViolation[0m for DAOConstantGas in contract 'Protocol':
    |
    |            if (hasFunds) {
  > |                msg.sender.transfer(amount);
    |            } else {
    |                result = msg.sender.call.value(amount)(RECEIVE_ETH, _series, amount);
  at Protocol.sol(574)

[33mWarning[0m for DAOConstantGas in contract 'Protocol':
    |            } else {
    |                require(msg.value >= amount);
  > |                msg.sender.transfer(msg.value - amount);
    |            }
    |        }
  at Protocol.sol(597)

[33mWarning[0m for DAOConstantGas in contract 'Protocol':
    |            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;
    |            if (owed > 0) {
  > |                msg.sender.transfer(owed);
    |            }
    |
  at Protocol.sol(616)

[33mWarning[0m for DAOConstantGas in contract 'Protocol':
    |            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;
    |            if (owed > 0) {
  > |                msg.sender.transfer(owed);
    |            }
    |        }
  at Protocol.sol(633)

[31mViolation[0m for RepeatedCall in contract 'Protocol':
    |            require(escrow / amount == series.strike);
    |            escrow /= 1 ether;
  > |            require(usdERC20.transferFrom(msg.sender, this, escrow));
    |        }
    |        
  at Protocol.sol(478)

[31mViolation[0m for RepeatedCall in contract 'Protocol':
    |    function _preference(address from) public view returns (uint) {
    |        return _min(
  > |            protocolToken.balanceOf(from) * 1 ether / protocolToken.totalSupply(),
    |            PREFERENCE_MAX
    |        );
  at Protocol.sol(672)

[33mWarning[0m for RepeatedCall in contract 'Protocol':
    |                msg.sender.transfer(amount);
    |            } else {
  > |                result = msg.sender.call.value(amount)(RECEIVE_ETH, _series, amount);
    |                require(result);
    |            }
  at Protocol.sol(576)

[33mWarning[0m for RepeatedCall in contract 'Protocol':
    |                expectValue[msg.sender] = amount;
    |
  > |                result = msg.sender.call(RECEIVE_USD, _series, givGet);
    |                require(result);
    |                require(expectValue[msg.sender] == 0);
  at Protocol.sol(592)

[33mWarning[0m for TODAmount in contract 'Protocol':
    |            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;
    |            if (owed > 0) {
  > |                msg.sender.transfer(owed);
    |            }
    |
  at Protocol.sol(616)

[33mWarning[0m for TODAmount in contract 'Protocol':
    |            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;
    |            if (owed > 0) {
  > |                msg.sender.transfer(owed);
    |            }
    |        }
  at Protocol.sol(633)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Protocol':
    |        
    |        if (series.flavor == Flavor.Call) {
  > |            msg.sender.transfer(amount);
    |        } else {
    |            require(
  at Protocol.sol(501)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Protocol':
    |
    |        if (series.flavor == Flavor.Call) {
  > |            msg.sender.transfer(amount);
    |            require(msg.value == 0);
    |            require(usdERC20.transferFrom(msg.sender, this, usd));
  at Protocol.sol(523)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Protocol':
    |            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;
    |            if (owed > 0) {
  > |                msg.sender.transfer(owed);
    |            }
    |
  at Protocol.sol(616)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Protocol':
    |            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;
    |            if (owed > 0) {
  > |                msg.sender.transfer(owed);
    |            }
    |        }
  at Protocol.sol(633)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |        }
    |        
  > |        openInterest[_series] += amount;
    |        totalInterest[_series] += amount;
    |        writers[_series][msg.sender] += amount;
  at Protocol.sol(481)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |        
    |        openInterest[_series] += amount;
  > |        totalInterest[_series] += amount;
    |        writers[_series][msg.sender] += amount;
    |
  at Protocol.sol(482)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |        require(writers[_series][msg.sender] >= amount);
    |        writers[_series][msg.sender] -= amount;
  > |        openInterest[_series] -= amount;
    |        totalInterest[_series] -= amount;
    |        
  at Protocol.sol(497)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |        writers[_series][msg.sender] -= amount;
    |        openInterest[_series] -= amount;
  > |        totalInterest[_series] -= amount;
    |        
    |        if (series.flavor == Flavor.Call) {
  at Protocol.sol(498)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |        usd /= 1 ether;
    |
  > |        openInterest[_series] -= amount;
    |        earlyExercised[_series] += amount;
    |
  at Protocol.sol(519)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |
    |        openInterest[_series] -= amount;
  > |        earlyExercised[_series] += amount;
    |
    |        if (series.flavor == Flavor.Call) {
  at Protocol.sol(520)

[33mWarning[0m for UnrestrictedWrite in contract 'Protocol':
    |
    |        require(isAuction == false);
  > |        isAuction = true;
    |
    |        OptionSeries memory series = seriesInfo[_series];
  at Protocol.sol(540)

[31mViolation[0m for LockedEther in contract 'Token':
    |
    |// we don't store much state here either
  > |contract Token is VariableSupplyToken {
    |    constructor() public {
    |        creator = msg.sender;
  at Protocol.sol(318)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
  > |    mapping(address => uint) public balances;
    |    mapping(address => mapping(address => uint)) public allowed;
    |
  at Protocol.sol(223)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
    |    mapping(address => uint) public balances;
  > |    mapping(address => mapping(address => uint)) public allowed;
    |
    |    uint8 public constant decimals = 18;
  at Protocol.sol(224)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    event Created(address creator, uint supply);
    |
  > |    function balanceOf(address _owner) public view returns (uint256 balance) {
    |        return balances[_owner];
    |    }
  at Protocol.sol(236)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    }
    |
  > |    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    |        return allowed[_owner][_spender];
    |    }
  at Protocol.sol(240)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |contract ERC20x is ERC20xVariables {
    |
  > |    function transfer(address _to, uint256 _value) public returns (bool success) {
    |        _transferBalance(msg.sender, _to, _value);
    |        emit Transfer(msg.sender, _to, _value);
  at Protocol.sol(247)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    }
    |
  > |    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    |        uint256 allowance = allowed[_from][msg.sender];
    |        require(allowance >= _value);
  at Protocol.sol(253)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    }
    |
  > |    function approve(address _spender, uint256 _value) public returns (bool success) {
    |        allowed[msg.sender][_spender] = _value;
    |        emit Approval(msg.sender, _spender, _value);
  at Protocol.sol(264)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    }
    |
  > |    function transferToContract(address _to, uint256 _value, bytes data) public returns (bool) {
    |        _transferBalance(msg.sender, _to, _value);
    |        bytes4 sig = bytes4(keccak256("receiveTokens(address,uint256,bytes)"));
  at Protocol.sol(270)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |
    |contract VariableSupplyToken is ERC20x {
  > |    function grant(address to, uint256 amount) public {
    |        require(msg.sender == creator);
    |        require(balances[to] + amount >= amount);
  at Protocol.sol(286)

[31mViolation[0m for MissingInputValidation in contract 'Token':
    |    }
    |
  > |    function burn(address from, uint amount) public {
    |        require(msg.sender == creator);
    |        require(balances[from] >= amount);
  at Protocol.sol(293)

[31mViolation[0m for UnrestrictedWrite in contract 'Token':
    |    function _transferBalance(address _from, address _to, uint _value) internal {
    |        require(balances[_from] >= _value);
  > |        balances[_from] -= _value;
    |        balances[_to] += _value;
    |    }
  at Protocol.sol(280)

[31mViolation[0m for UnrestrictedWrite in contract 'Token':
    |        require(balances[_from] >= _value);
    |        balances[_from] -= _value;
  > |        balances[_to] += _value;
    |    }
    |}
  at Protocol.sol(281)

[33mWarning[0m for UnrestrictedWrite in contract 'Token':
    |        require(balances[_from] >= _value);
    |        balances[_from] -= _value;
  > |        balances[_to] += _value;
    |    }
    |}
  at Protocol.sol(281)

[33mWarning[0m for UnrestrictedWrite in contract 'Token':
    |        require(msg.sender == creator);
    |        require(balances[to] + amount >= amount);
  > |        balances[to] += amount;
    |        totalSupply += amount;
    |    }
  at Protocol.sol(289)

[33mWarning[0m for UnrestrictedWrite in contract 'Token':
    |        require(balances[to] + amount >= amount);
    |        balances[to] += amount;
  > |        totalSupply += amount;
    |    }
    |
  at Protocol.sol(290)

[33mWarning[0m for UnrestrictedWrite in contract 'Token':
    |        require(msg.sender == creator);
    |        require(balances[from] >= amount);
  > |        balances[from] -= amount;
    |        totalSupply -= amount;
    |    }
  at Protocol.sol(296)

[33mWarning[0m for UnrestrictedWrite in contract 'Token':
    |        require(balances[from] >= amount);
    |        balances[from] -= amount;
  > |        totalSupply -= amount;
    |    }
    |}
  at Protocol.sol(297)

[31mViolation[0m for LockedEther in contract 'VariableSupplyToken':
    |}
    |
  > |contract VariableSupplyToken is ERC20x {
    |    function grant(address to, uint256 amount) public {
    |        require(msg.sender == creator);
  at Protocol.sol(285)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
  > |    mapping(address => uint) public balances;
    |    mapping(address => mapping(address => uint)) public allowed;
    |
  at Protocol.sol(223)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    uint256 constant public MAX_UINT256 = 2**256 - 1;
    |    mapping(address => uint) public balances;
  > |    mapping(address => mapping(address => uint)) public allowed;
    |
    |    uint8 public constant decimals = 18;
  at Protocol.sol(224)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    event Created(address creator, uint supply);
    |
  > |    function balanceOf(address _owner) public view returns (uint256 balance) {
    |        return balances[_owner];
    |    }
  at Protocol.sol(236)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    }
    |
  > |    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    |        return allowed[_owner][_spender];
    |    }
  at Protocol.sol(240)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |contract ERC20x is ERC20xVariables {
    |
  > |    function transfer(address _to, uint256 _value) public returns (bool success) {
    |        _transferBalance(msg.sender, _to, _value);
    |        emit Transfer(msg.sender, _to, _value);
  at Protocol.sol(247)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    }
    |
  > |    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    |        uint256 allowance = allowed[_from][msg.sender];
    |        require(allowance >= _value);
  at Protocol.sol(253)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    }
    |
  > |    function approve(address _spender, uint256 _value) public returns (bool success) {
    |        allowed[msg.sender][_spender] = _value;
    |        emit Approval(msg.sender, _spender, _value);
  at Protocol.sol(264)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    }
    |
  > |    function transferToContract(address _to, uint256 _value, bytes data) public returns (bool) {
    |        _transferBalance(msg.sender, _to, _value);
    |        bytes4 sig = bytes4(keccak256("receiveTokens(address,uint256,bytes)"));
  at Protocol.sol(270)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |
    |contract VariableSupplyToken is ERC20x {
  > |    function grant(address to, uint256 amount) public {
    |        require(msg.sender == creator);
    |        require(balances[to] + amount >= amount);
  at Protocol.sol(286)

[31mViolation[0m for MissingInputValidation in contract 'VariableSupplyToken':
    |    }
    |
  > |    function burn(address from, uint amount) public {
    |        require(msg.sender == creator);
    |        require(balances[from] >= amount);
  at Protocol.sol(293)

[31mViolation[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |    function _transferBalance(address _from, address _to, uint _value) internal {
    |        require(balances[_from] >= _value);
  > |        balances[_from] -= _value;
    |        balances[_to] += _value;
    |    }
  at Protocol.sol(280)

[31mViolation[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |        require(balances[_from] >= _value);
    |        balances[_from] -= _value;
  > |        balances[_to] += _value;
    |    }
    |}
  at Protocol.sol(281)

[33mWarning[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |        require(balances[_from] >= _value);
    |        balances[_from] -= _value;
  > |        balances[_to] += _value;
    |    }
    |}
  at Protocol.sol(281)

[33mWarning[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |        require(msg.sender == creator);
    |        require(balances[to] + amount >= amount);
  > |        balances[to] += amount;
    |        totalSupply += amount;
    |    }
  at Protocol.sol(289)

[33mWarning[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |        require(balances[to] + amount >= amount);
    |        balances[to] += amount;
  > |        totalSupply += amount;
    |    }
    |
  at Protocol.sol(290)

[33mWarning[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |        require(msg.sender == creator);
    |        require(balances[from] >= amount);
  > |        balances[from] -= amount;
    |        totalSupply -= amount;
    |    }
  at Protocol.sol(296)

[33mWarning[0m for UnrestrictedWrite in contract 'VariableSupplyToken':
    |        require(balances[from] >= amount);
    |        balances[from] -= amount;
  > |        totalSupply -= amount;
    |    }
    |}
  at Protocol.sol(297)

[FILE] buyable.sol
Processing contract: buyable.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:ERC721Basic
Processing contract: buyable.sol:ERC721BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:acl
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:bloomingPool
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:buyable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:testreg
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: buyable.sol:update
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'ERC721BasicToken':
    |
    |    function setRole(uint8 rolevalue,address entity)external check(2){
  > |        permissions[entity] = Role(rolevalue);
    |    }
    |
  at buyable.sol(114)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721BasicToken':
    |        address owner = tokenOwner[_tokenId];
    |
  > |        tokenApprovals[_tokenId] = _to;
    |
    |        require(_to != ownerOf(_tokenId));
  at buyable.sol(213)

[31mViolation[0m for MissingInputValidation in contract 'acl':
    |    }
    |
  > |    function setRole(uint8 rolevalue,address entity)external check(2){
    |        permissions[entity] = Role(rolevalue);
    |    }
  at buyable.sol(113)

[31mViolation[0m for MissingInputValidation in contract 'acl':
    |    }
    |
  > |    function getRole(address entity)public view returns(Role){
    |        return permissions[entity];
    |    }
  at buyable.sol(117)

[33mWarning[0m for UnrestrictedWrite in contract 'acl':
    |
    |    function setRole(uint8 rolevalue,address entity)external check(2){
  > |        permissions[entity] = Role(rolevalue);
    |    }
    |
  at buyable.sol(114)

[31mViolation[0m for DAOConstantGas in contract 'bloomingPool':
    |
    |        totalReleased = totalReleased.add(payment);
  > |        payee.transfer(payment);
    |        substract_individual_shares(shares[payee]);
    |        reset_individual_shares(payee);
  at buyable.sol(440)

[33mWarning[0m for TODAmount in contract 'bloomingPool':
    |
    |        totalReleased = totalReleased.add(payment);
  > |        payee.transfer(payment);
    |        substract_individual_shares(shares[payee]);
    |        reset_individual_shares(payee);
  at buyable.sol(440)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'bloomingPool':
    |    function emergency_withdraw(uint amount) external check(2) {
    |        require(amount <= this.balance);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at buyable.sol(447)

[33mWarning[0m for UnrestrictedWrite in contract 'bloomingPool':
    |
    |    function setRole(uint8 rolevalue,address entity)external check(2){
  > |        permissions[entity] = Role(rolevalue);
    |    }
    |
  at buyable.sol(114)

[33mWarning[0m for UnrestrictedWrite in contract 'bloomingPool':
    |        address owner = tokenOwner[_tokenId];
    |
  > |        tokenApprovals[_tokenId] = _to;
    |
    |        require(_to != ownerOf(_tokenId));
  at buyable.sol(213)

[33mWarning[0m for UnrestrictedWrite in contract 'bloomingPool':
    |/// @dev altered version of Open Zepplin's 'SplitPayment' contract
    |
  > |contract bloomingPool is update {
    |
    |    using SafeMath for uint256;
  at buyable.sol(382)

[33mWarning[0m for UnrestrictedWrite in contract 'bloomingPool':
    |
    |    function freeze_pool(bool _freeze) external check(2){
  > |        freeze = _freeze;
    |    }
    |
  at buyable.sol(413)

[31mViolation[0m for DAOConstantGas in contract 'buyable':
    |
    |        totalReleased = totalReleased.add(payment);
  > |        payee.transfer(payment);
    |        substract_individual_shares(shares[payee]);
    |        reset_individual_shares(payee);
  at buyable.sol(440)

[33mWarning[0m for TODAmount in contract 'buyable':
    |
    |        totalReleased = totalReleased.add(payment);
  > |        payee.transfer(payment);
    |        substract_individual_shares(shares[payee]);
    |        reset_individual_shares(payee);
  at buyable.sol(440)

[33mWarning[0m for TODAmount in contract 'buyable':
    |        uint _combined = _blooming.add(_infrastructure);
    |        uint _amount_for_seller = msg.value.sub(_combined);
  > |        require(tokenOwner[UniqueID].call.gas(99999).value(_amount_for_seller)());
    |        this.transferFrom(tokenOwner[UniqueID], _to, UniqueID);
    |        if(!INFRASTRUCTURE_POOL_ADDRESS.call.gas(99999).value(_infrastructure)()){
  at buyable.sol(489)

[33mWarning[0m for TODAmount in contract 'buyable':
    |        require(tokenOwner[UniqueID].call.gas(99999).value(_amount_for_seller)());
    |        this.transferFrom(tokenOwner[UniqueID], _to, UniqueID);
  > |        if(!INFRASTRUCTURE_POOL_ADDRESS.call.gas(99999).value(_infrastructure)()){
    |            revert("transfer to infrastructurePool failed");
    |		}
  at buyable.sol(491)

[31mViolation[0m for TODReceiver in contract 'buyable':
    |        require(tokenOwner[UniqueID].call.gas(99999).value(_amount_for_seller)());
    |        this.transferFrom(tokenOwner[UniqueID], _to, UniqueID);
  > |        if(!INFRASTRUCTURE_POOL_ADDRESS.call.gas(99999).value(_infrastructure)()){
    |            revert("transfer to infrastructurePool failed");
    |		}
  at buyable.sol(491)

[33mWarning[0m for TODReceiver in contract 'buyable':
    |        uint _combined = _blooming.add(_infrastructure);
    |        uint _amount_for_seller = msg.value.sub(_combined);
  > |        require(tokenOwner[UniqueID].call.gas(99999).value(_amount_for_seller)());
    |        this.transferFrom(tokenOwner[UniqueID], _to, UniqueID);
    |        if(!INFRASTRUCTURE_POOL_ADDRESS.call.gas(99999).value(_infrastructure)()){
  at buyable.sol(489)

[33mWarning[0m for TODReceiver in contract 'buyable':
    |
    |        totalReleased = totalReleased.add(payment);
  > |        payee.transfer(payment);
    |        substract_individual_shares(shares[payee]);
    |        reset_individual_shares(payee);
  at buyable.sol(440)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'buyable':
    |    function emergency_withdraw(uint amount) external check(2) {
    |        require(amount <= this.balance);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at buyable.sol(447)

[33mWarning[0m for UnrestrictedWrite in contract 'buyable':
    |
    |    function setRole(uint8 rolevalue,address entity)external check(2){
  > |        permissions[entity] = Role(rolevalue);
    |    }
    |
  at buyable.sol(114)

[33mWarning[0m for UnrestrictedWrite in contract 'buyable':
    |        address owner = tokenOwner[_tokenId];
    |
  > |        tokenApprovals[_tokenId] = _to;
    |
    |        require(_to != ownerOf(_tokenId));
  at buyable.sol(213)

[33mWarning[0m for UnrestrictedWrite in contract 'buyable':
    |
    |    function freeze_pool(bool _freeze) external check(2){
  > |        freeze = _freeze;
    |    }
    |
  at buyable.sol(413)

[33mWarning[0m for UnrestrictedWrite in contract 'buyable':
    |// File: contracts/buyable.sol
    |
  > |contract buyable is bloomingPool {
    |
    |    address INFRASTRUCTURE_POOL_ADDRESS;
  at buyable.sol(454)

[33mWarning[0m for UnrestrictedWrite in contract 'buyable':
    |
    |    function initialisation(address _infrastructure_address) public check(2){
  > |        INFRASTRUCTURE_POOL_ADDRESS = _infrastructure_address;
    |    }
    |
  at buyable.sol(466)

[33mWarning[0m for UnrestrictedWrite in contract 'buyable':
    |        address _to = msg.sender;
    |        require(TokenIdtosetprice[UniqueID] == msg.value);
  > |        TokenIdtoprice[UniqueID] = msg.value;
    |        uint _blooming = msg.value.div(20);
    |        uint _infrastructure = msg.value.div(20);
  at buyable.sol(484)

[33mWarning[0m for UnrestrictedWrite in contract 'testreg':
    |
    |    function setRole(uint8 rolevalue,address entity)external check(2){
  > |        permissions[entity] = Role(rolevalue);
    |    }
    |
  at buyable.sol(114)

[33mWarning[0m for UnrestrictedWrite in contract 'testreg':
    |        address owner = tokenOwner[_tokenId];
    |
  > |        tokenApprovals[_tokenId] = _to;
    |
    |        require(_to != ownerOf(_tokenId));
  at buyable.sol(213)

[31mViolation[0m for LockedEther in contract 'update':
    |// File: contracts/update.sol
    |
  > |contract update is testreg {
    |
    |    event UpdateToken(uint256 _tokenId, string new_uri);
  at buyable.sol(359)

[33mWarning[0m for UnrestrictedWrite in contract 'update':
    |
    |    function setRole(uint8 rolevalue,address entity)external check(2){
  > |        permissions[entity] = Role(rolevalue);
    |    }
    |
  at buyable.sol(114)

[33mWarning[0m for UnrestrictedWrite in contract 'update':
    |        address owner = tokenOwner[_tokenId];
    |
  > |        tokenApprovals[_tokenId] = _to;
    |
    |        require(_to != ownerOf(_tokenId));
  at buyable.sol(213)

[33mWarning[0m for UnrestrictedWrite in contract 'update':
    |// File: contracts/update.sol
    |
  > |contract update is testreg {
    |
    |    event UpdateToken(uint256 _tokenId, string new_uri);
  at buyable.sol(359)

[FILE] Cryptolotto10Minutes.sol
Processing contract: Cryptolotto10Minutes.sol:Cryptolotto10Minutes
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto10Minutes.sol:iCryptolottoReferral
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto10Minutes.sol:iCryptolottoStatsAggregator
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto10Minutes.sol:iOwnable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for DAO in contract 'Cryptolotto10Minutes':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto10Minutes.sol(425)

[31mViolation[0m for DAOConstantGas in contract 'Cryptolotto10Minutes':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto10Minutes.sol(399)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto10Minutes':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto10Minutes.sol(418)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto10Minutes':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(471)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto10Minutes':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(491)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto10Minutes':
    |    * @param playedGame Game number.
    |    */
  > |    function getPlayersInGame(uint playedGame) 
    |        public 
    |        view
  at Cryptolotto10Minutes.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto10Minutes':
    |    * @param playedGame The number of the played game.
    |    */
  > |    function getGameJackpot(uint playedGame) 
    |        public 
    |        view 
  at Cryptolotto10Minutes.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto10Minutes':
    |    * @param price New ticket price.``
    |    */    
  > |    function changeTicketPrice(uint price) 
    |        public 
    |        onlyOwner() 
  at Cryptolotto10Minutes.sol(290)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto10Minutes':
    |    * @param bHash Block hash.
    |    */
  > |    function randomNumber(
    |        uint min,
    |        uint max,
  at Cryptolotto10Minutes.sol(310)

[33mWarning[0m for MissingInputValidation in contract 'Cryptolotto10Minutes':
    |    * @dev The payable method that accepts ether and adds the player to the game.
    |    */
  > |    function buyTicket(address partner) public payable {
    |        require(isActive);
    |        require(msg.value == ticketPrice);
  at Cryptolotto10Minutes.sol(350)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(487)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto10Minutes':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(509)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto10Minutes':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(527)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto10Minutes.sol(399)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto10Minutes.sol(413)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto10Minutes.sol(418)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto10Minutes.sol(425)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto10Minutes.sol(448)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto10Minutes.sol(451)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(467)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(471)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(487)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(491)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(509)

[33mWarning[0m for TODAmount in contract 'Cryptolotto10Minutes':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(527)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto10Minutes.sol(399)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto10Minutes.sol(413)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto10Minutes.sol(418)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto10Minutes.sol(425)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto10Minutes.sol(448)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto10Minutes.sol(451)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(467)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(471)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(487)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(491)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(509)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto10Minutes':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(527)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto10Minutes.sol(399)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto10Minutes.sol(413)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto10Minutes.sol(418)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto10Minutes.sol(425)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto10Minutes.sol(448)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto10Minutes.sol(451)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(467)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(471)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto10Minutes.sol(487)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto10Minutes.sol(491)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(509)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto10Minutes':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto10Minutes.sol(527)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |/**
  > |* @dev Cryptolotto referral system interface.
    |*/
    |contract iCryptolottoReferral {
  at Cryptolotto10Minutes.sol(2)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |    function toogleActive() public onlyOwner() {
    |        if (!isActive) {
  > |            isActive = true;
    |        } else {
    |            toogleStatus = !toogleStatus;
  at Cryptolotto10Minutes.sol(269)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |            isActive = true;
    |        } else {
  > |            toogleStatus = !toogleStatus;
    |        }
    |    }
  at Cryptolotto10Minutes.sol(271)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        onlyOwner() 
    |    {
  > |        newPrice = price;
    |    }
    |
  at Cryptolotto10Minutes.sol(294)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        require(msg.value == ticketPrice);
    |        
  > |        jackpot[game] += msg.value;
    |        
    |        uint playerNumber =  players[game].length;
  at Cryptolotto10Minutes.sol(354)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        
    |        uint playerNumber =  players[game].length;
  > |        players[game].push(msg.sender);
    |
    |        processReferralSystem(partner, msg.sender);
  at Cryptolotto10Minutes.sol(357)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        require(isActive);
    |
  > |        game = block.number;
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  at Cryptolotto10Minutes.sol(373)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        game = block.number;
    |        if (newPrice != 0) {
  > |            ticketPrice = newPrice;
    |            newPrice = 0;
    |        }
  at Cryptolotto10Minutes.sol(375)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  > |            newPrice = 0;
    |        }
    |        if (toogleStatus) {
  at Cryptolotto10Minutes.sol(376)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        }
    |        if (toogleStatus) {
  > |            isActive = !isActive;
    |            toogleStatus = false;
    |        }
  at Cryptolotto10Minutes.sol(379)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        if (toogleStatus) {
    |            isActive = !isActive;
  > |            toogleStatus = false;
    |        }
    |        emit Game(game, now);
  at Cryptolotto10Minutes.sol(380)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        }
    |    
  > |        paidToPartners = 0;
    |        stats.newWinner(
    |            players[game][winner],
  at Cryptolotto10Minutes.sol(424)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        );
    |        
  > |        allTimeJackpot += toPlayer;
    |        allTimePlayers += players[game].length;
    |    }
  at Cryptolotto10Minutes.sol(434)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |        
    |        allTimeJackpot += toPlayer;
  > |        allTimePlayers += players[game].length;
    |    }
    |
  at Cryptolotto10Minutes.sol(435)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto10Minutes.sol(472)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto10Minutes.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto10Minutes.sol(472)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto10Minutes':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto10Minutes.sol(492)

[FILE] Cryptolotto1Day.sol
Processing contract: Cryptolotto1Day.sol:Cryptolotto1Day
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto1Day.sol:iCryptolottoReferral
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto1Day.sol:iCryptolottoStatsAggregator
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto1Day.sol:iOwnable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for DAO in contract 'Cryptolotto1Day':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Day.sol(425)

[31mViolation[0m for DAOConstantGas in contract 'Cryptolotto1Day':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Day.sol(399)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto1Day':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Day.sol(418)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto1Day':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(471)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto1Day':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(491)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Day':
    |    * @param playedGame Game number.
    |    */
  > |    function getPlayersInGame(uint playedGame) 
    |        public 
    |        view
  at Cryptolotto1Day.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Day':
    |    * @param playedGame The number of the played game.
    |    */
  > |    function getGameJackpot(uint playedGame) 
    |        public 
    |        view 
  at Cryptolotto1Day.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Day':
    |    * @param price New ticket price.``
    |    */    
  > |    function changeTicketPrice(uint price) 
    |        public 
    |        onlyOwner() 
  at Cryptolotto1Day.sol(290)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Day':
    |    * @param bHash Block hash.
    |    */
  > |    function randomNumber(
    |        uint min,
    |        uint max,
  at Cryptolotto1Day.sol(310)

[33mWarning[0m for MissingInputValidation in contract 'Cryptolotto1Day':
    |    * @dev The payable method that accepts ether and adds the player to the game.
    |    */
  > |    function buyTicket(address partner) public payable {
    |        require(isActive);
    |        require(msg.value == ticketPrice);
  at Cryptolotto1Day.sol(350)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto1Day':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Day.sol(487)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto1Day':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(509)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto1Day':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(527)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Day.sol(399)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto1Day.sol(413)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Day.sol(418)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Day.sol(425)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto1Day.sol(448)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto1Day.sol(451)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto1Day.sol(467)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(471)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Day.sol(487)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(491)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(509)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Day':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(527)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Day.sol(399)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto1Day.sol(413)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Day.sol(418)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Day.sol(425)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto1Day.sol(448)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto1Day.sol(451)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto1Day.sol(467)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(471)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Day.sol(487)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(491)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(509)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Day':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(527)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Day.sol(399)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto1Day.sol(413)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Day.sol(418)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Day.sol(425)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto1Day.sol(448)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto1Day.sol(451)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto1Day.sol(467)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(471)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Day.sol(487)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Day.sol(491)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(509)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Day':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Day.sol(527)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |/**
  > |* @dev Cryptolotto referral system interface.
    |*/
    |contract iCryptolottoReferral {
  at Cryptolotto1Day.sol(2)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |    function toogleActive() public onlyOwner() {
    |        if (!isActive) {
  > |            isActive = true;
    |        } else {
    |            toogleStatus = !toogleStatus;
  at Cryptolotto1Day.sol(269)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |            isActive = true;
    |        } else {
  > |            toogleStatus = !toogleStatus;
    |        }
    |    }
  at Cryptolotto1Day.sol(271)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        onlyOwner() 
    |    {
  > |        newPrice = price;
    |    }
    |
  at Cryptolotto1Day.sol(294)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        require(msg.value == ticketPrice);
    |        
  > |        jackpot[game] += msg.value;
    |        
    |        uint playerNumber =  players[game].length;
  at Cryptolotto1Day.sol(354)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        
    |        uint playerNumber =  players[game].length;
  > |        players[game].push(msg.sender);
    |
    |        processReferralSystem(partner, msg.sender);
  at Cryptolotto1Day.sol(357)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        require(isActive);
    |
  > |        game = block.number;
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  at Cryptolotto1Day.sol(373)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        game = block.number;
    |        if (newPrice != 0) {
  > |            ticketPrice = newPrice;
    |            newPrice = 0;
    |        }
  at Cryptolotto1Day.sol(375)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  > |            newPrice = 0;
    |        }
    |        if (toogleStatus) {
  at Cryptolotto1Day.sol(376)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        }
    |        if (toogleStatus) {
  > |            isActive = !isActive;
    |            toogleStatus = false;
    |        }
  at Cryptolotto1Day.sol(379)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        if (toogleStatus) {
    |            isActive = !isActive;
  > |            toogleStatus = false;
    |        }
    |        emit Game(game, now);
  at Cryptolotto1Day.sol(380)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        }
    |    
  > |        paidToPartners = 0;
    |        stats.newWinner(
    |            players[game][winner],
  at Cryptolotto1Day.sol(424)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        );
    |        
  > |        allTimeJackpot += toPlayer;
    |        allTimePlayers += players[game].length;
    |    }
  at Cryptolotto1Day.sol(434)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |        
    |        allTimeJackpot += toPlayer;
  > |        allTimePlayers += players[game].length;
    |    }
    |
  at Cryptolotto1Day.sol(435)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto1Day.sol(472)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto1Day.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto1Day.sol(472)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto1Day':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto1Day.sol(492)

[FILE] Cryptolotto1Hour.sol
Processing contract: Cryptolotto1Hour.sol:Cryptolotto1Hour
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto1Hour.sol:iCryptolottoReferral
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto1Hour.sol:iCryptolottoStatsAggregator
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto1Hour.sol:iOwnable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for DAO in contract 'Cryptolotto1Hour':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Hour.sol(425)

[31mViolation[0m for DAOConstantGas in contract 'Cryptolotto1Hour':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Hour.sol(399)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto1Hour':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Hour.sol(418)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto1Hour':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(471)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto1Hour':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(491)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Hour':
    |    * @param playedGame Game number.
    |    */
  > |    function getPlayersInGame(uint playedGame) 
    |        public 
    |        view
  at Cryptolotto1Hour.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Hour':
    |    * @param playedGame The number of the played game.
    |    */
  > |    function getGameJackpot(uint playedGame) 
    |        public 
    |        view 
  at Cryptolotto1Hour.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Hour':
    |    * @param price New ticket price.``
    |    */    
  > |    function changeTicketPrice(uint price) 
    |        public 
    |        onlyOwner() 
  at Cryptolotto1Hour.sol(290)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto1Hour':
    |    * @param bHash Block hash.
    |    */
  > |    function randomNumber(
    |        uint min,
    |        uint max,
  at Cryptolotto1Hour.sol(310)

[33mWarning[0m for MissingInputValidation in contract 'Cryptolotto1Hour':
    |    * @dev The payable method that accepts ether and adds the player to the game.
    |    */
  > |    function buyTicket(address partner) public payable {
    |        require(isActive);
    |        require(msg.value == ticketPrice);
  at Cryptolotto1Hour.sol(350)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Hour.sol(487)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto1Hour':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(509)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto1Hour':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(527)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Hour.sol(399)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto1Hour.sol(413)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Hour.sol(418)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Hour.sol(425)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto1Hour.sol(448)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto1Hour.sol(451)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto1Hour.sol(467)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(471)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Hour.sol(487)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(491)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(509)

[33mWarning[0m for TODAmount in contract 'Cryptolotto1Hour':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(527)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Hour.sol(399)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto1Hour.sol(413)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Hour.sol(418)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Hour.sol(425)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto1Hour.sol(448)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto1Hour.sol(451)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto1Hour.sol(467)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(471)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Hour.sol(487)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(491)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(509)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto1Hour':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(527)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto1Hour.sol(399)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto1Hour.sol(413)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto1Hour.sol(418)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto1Hour.sol(425)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto1Hour.sol(448)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto1Hour.sol(451)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto1Hour.sol(467)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(471)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto1Hour.sol(487)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto1Hour.sol(491)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(509)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto1Hour':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto1Hour.sol(527)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |/**
  > |* @dev Cryptolotto referral system interface.
    |*/
    |contract iCryptolottoReferral {
  at Cryptolotto1Hour.sol(2)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |    function toogleActive() public onlyOwner() {
    |        if (!isActive) {
  > |            isActive = true;
    |        } else {
    |            toogleStatus = !toogleStatus;
  at Cryptolotto1Hour.sol(269)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |            isActive = true;
    |        } else {
  > |            toogleStatus = !toogleStatus;
    |        }
    |    }
  at Cryptolotto1Hour.sol(271)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        onlyOwner() 
    |    {
  > |        newPrice = price;
    |    }
    |
  at Cryptolotto1Hour.sol(294)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        require(msg.value == ticketPrice);
    |        
  > |        jackpot[game] += msg.value;
    |        
    |        uint playerNumber =  players[game].length;
  at Cryptolotto1Hour.sol(354)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        
    |        uint playerNumber =  players[game].length;
  > |        players[game].push(msg.sender);
    |
    |        processReferralSystem(partner, msg.sender);
  at Cryptolotto1Hour.sol(357)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        require(isActive);
    |
  > |        game = block.number;
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  at Cryptolotto1Hour.sol(373)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        game = block.number;
    |        if (newPrice != 0) {
  > |            ticketPrice = newPrice;
    |            newPrice = 0;
    |        }
  at Cryptolotto1Hour.sol(375)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  > |            newPrice = 0;
    |        }
    |        if (toogleStatus) {
  at Cryptolotto1Hour.sol(376)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        }
    |        if (toogleStatus) {
  > |            isActive = !isActive;
    |            toogleStatus = false;
    |        }
  at Cryptolotto1Hour.sol(379)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        if (toogleStatus) {
    |            isActive = !isActive;
  > |            toogleStatus = false;
    |        }
    |        emit Game(game, now);
  at Cryptolotto1Hour.sol(380)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        }
    |    
  > |        paidToPartners = 0;
    |        stats.newWinner(
    |            players[game][winner],
  at Cryptolotto1Hour.sol(424)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        );
    |        
  > |        allTimeJackpot += toPlayer;
    |        allTimePlayers += players[game].length;
    |    }
  at Cryptolotto1Hour.sol(434)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |        
    |        allTimeJackpot += toPlayer;
  > |        allTimePlayers += players[game].length;
    |    }
    |
  at Cryptolotto1Hour.sol(435)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto1Hour.sol(472)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto1Hour.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto1Hour.sol(472)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto1Hour':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto1Hour.sol(492)

[FILE] Cryptolotto6Hours.sol
Processing contract: Cryptolotto6Hours.sol:Cryptolotto6Hours
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto6Hours.sol:iCryptolottoReferral
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto6Hours.sol:iCryptolottoStatsAggregator
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto6Hours.sol:iOwnable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for DAO in contract 'Cryptolotto6Hours':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto6Hours.sol(425)

[31mViolation[0m for DAOConstantGas in contract 'Cryptolotto6Hours':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto6Hours.sol(399)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto6Hours':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto6Hours.sol(418)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto6Hours':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(471)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto6Hours':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(491)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto6Hours':
    |    * @param playedGame Game number.
    |    */
  > |    function getPlayersInGame(uint playedGame) 
    |        public 
    |        view
  at Cryptolotto6Hours.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto6Hours':
    |    * @param playedGame The number of the played game.
    |    */
  > |    function getGameJackpot(uint playedGame) 
    |        public 
    |        view 
  at Cryptolotto6Hours.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto6Hours':
    |    * @param price New ticket price.``
    |    */    
  > |    function changeTicketPrice(uint price) 
    |        public 
    |        onlyOwner() 
  at Cryptolotto6Hours.sol(290)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto6Hours':
    |    * @param bHash Block hash.
    |    */
  > |    function randomNumber(
    |        uint min,
    |        uint max,
  at Cryptolotto6Hours.sol(310)

[33mWarning[0m for MissingInputValidation in contract 'Cryptolotto6Hours':
    |    * @dev The payable method that accepts ether and adds the player to the game.
    |    */
  > |    function buyTicket(address partner) public payable {
    |        require(isActive);
    |        require(msg.value == ticketPrice);
  at Cryptolotto6Hours.sol(350)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto6Hours.sol(487)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto6Hours':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(509)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto6Hours':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(527)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto6Hours.sol(399)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto6Hours.sol(413)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto6Hours.sol(418)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto6Hours.sol(425)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto6Hours.sol(448)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto6Hours.sol(451)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto6Hours.sol(467)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(471)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto6Hours.sol(487)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(491)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(509)

[33mWarning[0m for TODAmount in contract 'Cryptolotto6Hours':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(527)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto6Hours.sol(399)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto6Hours.sol(413)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto6Hours.sol(418)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto6Hours.sol(425)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto6Hours.sol(448)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto6Hours.sol(451)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto6Hours.sol(467)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(471)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto6Hours.sol(487)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(491)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(509)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto6Hours':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(527)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto6Hours.sol(399)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto6Hours.sol(413)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto6Hours.sol(418)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto6Hours.sol(425)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto6Hours.sol(448)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto6Hours.sol(451)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto6Hours.sol(467)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(471)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto6Hours.sol(487)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto6Hours.sol(491)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(509)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto6Hours':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto6Hours.sol(527)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |/**
  > |* @dev Cryptolotto referral system interface.
    |*/
    |contract iCryptolottoReferral {
  at Cryptolotto6Hours.sol(2)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |    function toogleActive() public onlyOwner() {
    |        if (!isActive) {
  > |            isActive = true;
    |        } else {
    |            toogleStatus = !toogleStatus;
  at Cryptolotto6Hours.sol(269)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |            isActive = true;
    |        } else {
  > |            toogleStatus = !toogleStatus;
    |        }
    |    }
  at Cryptolotto6Hours.sol(271)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        onlyOwner() 
    |    {
  > |        newPrice = price;
    |    }
    |
  at Cryptolotto6Hours.sol(294)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        require(msg.value == ticketPrice);
    |        
  > |        jackpot[game] += msg.value;
    |        
    |        uint playerNumber =  players[game].length;
  at Cryptolotto6Hours.sol(354)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        
    |        uint playerNumber =  players[game].length;
  > |        players[game].push(msg.sender);
    |
    |        processReferralSystem(partner, msg.sender);
  at Cryptolotto6Hours.sol(357)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        require(isActive);
    |
  > |        game = block.number;
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  at Cryptolotto6Hours.sol(373)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        game = block.number;
    |        if (newPrice != 0) {
  > |            ticketPrice = newPrice;
    |            newPrice = 0;
    |        }
  at Cryptolotto6Hours.sol(375)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  > |            newPrice = 0;
    |        }
    |        if (toogleStatus) {
  at Cryptolotto6Hours.sol(376)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        }
    |        if (toogleStatus) {
  > |            isActive = !isActive;
    |            toogleStatus = false;
    |        }
  at Cryptolotto6Hours.sol(379)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        if (toogleStatus) {
    |            isActive = !isActive;
  > |            toogleStatus = false;
    |        }
    |        emit Game(game, now);
  at Cryptolotto6Hours.sol(380)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        }
    |    
  > |        paidToPartners = 0;
    |        stats.newWinner(
    |            players[game][winner],
  at Cryptolotto6Hours.sol(424)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        );
    |        
  > |        allTimeJackpot += toPlayer;
    |        allTimePlayers += players[game].length;
    |    }
  at Cryptolotto6Hours.sol(434)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |        
    |        allTimeJackpot += toPlayer;
  > |        allTimePlayers += players[game].length;
    |    }
    |
  at Cryptolotto6Hours.sol(435)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto6Hours.sol(472)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto6Hours.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto6Hours.sol(472)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto6Hours':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto6Hours.sol(492)

[FILE] Cryptolotto7Days.sol
Processing contract: Cryptolotto7Days.sol:Cryptolotto7Days
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto7Days.sol:iCryptolottoReferral
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto7Days.sol:iCryptolottoStatsAggregator
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Cryptolotto7Days.sol:iOwnable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for DAO in contract 'Cryptolotto7Days':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto7Days.sol(425)

[31mViolation[0m for DAOConstantGas in contract 'Cryptolotto7Days':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto7Days.sol(399)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto7Days':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto7Days.sol(418)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto7Days':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(471)

[33mWarning[0m for DAOConstantGas in contract 'Cryptolotto7Days':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(491)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto7Days':
    |    * @param playedGame Game number.
    |    */
  > |    function getPlayersInGame(uint playedGame) 
    |        public 
    |        view
  at Cryptolotto7Days.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto7Days':
    |    * @param playedGame The number of the played game.
    |    */
  > |    function getGameJackpot(uint playedGame) 
    |        public 
    |        view 
  at Cryptolotto7Days.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto7Days':
    |    * @param price New ticket price.``
    |    */    
  > |    function changeTicketPrice(uint price) 
    |        public 
    |        onlyOwner() 
  at Cryptolotto7Days.sol(290)

[31mViolation[0m for MissingInputValidation in contract 'Cryptolotto7Days':
    |    * @param bHash Block hash.
    |    */
  > |    function randomNumber(
    |        uint min,
    |        uint max,
  at Cryptolotto7Days.sol(310)

[33mWarning[0m for MissingInputValidation in contract 'Cryptolotto7Days':
    |    * @dev The payable method that accepts ether and adds the player to the game.
    |    */
  > |    function buyTicket(address partner) public payable {
    |        require(isActive);
    |        require(msg.value == ticketPrice);
  at Cryptolotto7Days.sol(350)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto7Days':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto7Days.sol(487)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto7Days':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(509)

[33mWarning[0m for RepeatedCall in contract 'Cryptolotto7Days':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(527)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto7Days.sol(399)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto7Days.sol(413)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto7Days.sol(418)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto7Days.sol(425)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto7Days.sol(448)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto7Days.sol(451)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto7Days.sol(467)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(471)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto7Days.sol(487)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(491)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(509)

[33mWarning[0m for TODAmount in contract 'Cryptolotto7Days':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(527)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto7Days.sol(399)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto7Days.sol(413)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto7Days.sol(418)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto7Days.sol(425)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto7Days.sol(448)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto7Days.sol(451)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto7Days.sol(467)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(471)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto7Days.sol(487)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(491)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(509)

[33mWarning[0m for TODReceiver in contract 'Cryptolotto7Days':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(527)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |        if (players[game].length == 1) {
    |            toPlayer = jackpot[game];
  > |            players[game][0].transfer(jackpot[game]);
    |            winner = 0;
    |        } else {
  at Cryptolotto7Days.sol(399)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |            uint distribute = jackpot[game] * fee / 100;
    |            toPlayer = jackpot[game] - distribute;
  > |            players[game][winner].transfer(toPlayer);
    |
    |            transferToPartner(players[game][winner]);
  at Cryptolotto7Days.sol(413)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |            
    |            distribute -= paidToPartners;
  > |            bool result = address(fundsDistributor).call.gas(30000).value(distribute)();
    |            if (!result) {
    |                revert();
  at Cryptolotto7Days.sol(418)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |    
    |        paidToPartners = 0;
  > |        stats.newWinner(
    |            players[game][winner],
    |            game,
  at Cryptolotto7Days.sol(425)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |        internal 
    |    {
  > |        address partnerRef = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  at Cryptolotto7Days.sol(448)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |        if (partner != address(0) || partnerRef != address(0)) {
    |            if (partnerRef == address(0)) {
  > |                referralInstance.addReferral(partner, referral);
    |                partnerRef = partner;
    |            }
  at Cryptolotto7Days.sol(451)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |    */
    |    function transferToPartner(address referral) internal {
  > |        address partner = referralInstance.getPartnerByReferral(referral);
    |        if (partner != address(0)) {
    |            uint sum = getPartnerAmount(partner);
  at Cryptolotto7Days.sol(467)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |            uint sum = getPartnerAmount(partner);
    |            if (sum != 0) {
  > |                partner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(471)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |    */
    |    function transferToSalesPartner(address partner) internal {
  > |        address salesPartner = referralInstance.getSalesPartner(partner);
    |        if (salesPartner != address(0)) {
    |            uint sum = getSalesPartnerAmount(partner);
  at Cryptolotto7Days.sol(487)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |            uint sum = getSalesPartnerAmount(partner);
    |            if (sum != 0) {
  > |                salesPartner.transfer(sum);
    |                paidToPartners += sum;
    |
  at Cryptolotto7Days.sol(491)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |        returns (uint) 
    |    {
  > |        uint8 partnerPercent = referralInstance.getPartnerPercent(partner);
    |        if (partnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(509)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Cryptolotto7Days':
    |        returns (uint)
    |    {
  > |        uint8 salesPartnerPercent = referralInstance.getSalesPartnerPercent(partner);
    |        if (salesPartnerPercent == 0) {
    |            return 0;
  at Cryptolotto7Days.sol(527)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |/**
  > |* @dev Cryptolotto referral system interface.
    |*/
    |contract iCryptolottoReferral {
  at Cryptolotto7Days.sol(2)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |    function toogleActive() public onlyOwner() {
    |        if (!isActive) {
  > |            isActive = true;
    |        } else {
    |            toogleStatus = !toogleStatus;
  at Cryptolotto7Days.sol(269)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |            isActive = true;
    |        } else {
  > |            toogleStatus = !toogleStatus;
    |        }
    |    }
  at Cryptolotto7Days.sol(271)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        onlyOwner() 
    |    {
  > |        newPrice = price;
    |    }
    |
  at Cryptolotto7Days.sol(294)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        require(msg.value == ticketPrice);
    |        
  > |        jackpot[game] += msg.value;
    |        
    |        uint playerNumber =  players[game].length;
  at Cryptolotto7Days.sol(354)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        
    |        uint playerNumber =  players[game].length;
  > |        players[game].push(msg.sender);
    |
    |        processReferralSystem(partner, msg.sender);
  at Cryptolotto7Days.sol(357)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        require(isActive);
    |
  > |        game = block.number;
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  at Cryptolotto7Days.sol(373)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        game = block.number;
    |        if (newPrice != 0) {
  > |            ticketPrice = newPrice;
    |            newPrice = 0;
    |        }
  at Cryptolotto7Days.sol(375)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        if (newPrice != 0) {
    |            ticketPrice = newPrice;
  > |            newPrice = 0;
    |        }
    |        if (toogleStatus) {
  at Cryptolotto7Days.sol(376)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        }
    |        if (toogleStatus) {
  > |            isActive = !isActive;
    |            toogleStatus = false;
    |        }
  at Cryptolotto7Days.sol(379)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        if (toogleStatus) {
    |            isActive = !isActive;
  > |            toogleStatus = false;
    |        }
    |        emit Game(game, now);
  at Cryptolotto7Days.sol(380)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        }
    |    
  > |        paidToPartners = 0;
    |        stats.newWinner(
    |            players[game][winner],
  at Cryptolotto7Days.sol(424)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        );
    |        
  > |        allTimeJackpot += toPlayer;
    |        allTimePlayers += players[game].length;
    |    }
  at Cryptolotto7Days.sol(434)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |        
    |        allTimeJackpot += toPlayer;
  > |        allTimePlayers += players[game].length;
    |    }
    |
  at Cryptolotto7Days.sol(435)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto7Days.sol(472)

[31mViolation[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto7Days.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |            if (sum != 0) {
    |                partner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToPartner(partner, referral, sum, now);
  at Cryptolotto7Days.sol(472)

[33mWarning[0m for UnrestrictedWrite in contract 'Cryptolotto7Days':
    |            if (sum != 0) {
    |                salesPartner.transfer(sum);
  > |                paidToPartners += sum;
    |
    |                emit ToSalesPartner(salesPartner, partner, sum, now);
  at Cryptolotto7Days.sol(492)

