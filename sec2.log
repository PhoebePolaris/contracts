[FILE] WyvernAtomicizer.sol
Processing contract: WyvernAtomicizer.sol:WyvernAtomicizer
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for LockedEther in contract 'WyvernAtomicizer':
    |pragma solidity ^0.4.13;
    |
  > |library WyvernAtomicizer {
    |
    |    function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas)
  at WyvernAtomicizer.sol(3)

[31mViolation[0m for MissingInputValidation in contract 'WyvernAtomicizer':
    |library WyvernAtomicizer {
    |
  > |    function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas)
    |        public
    |    {
  at WyvernAtomicizer.sol(5)

[31mViolation[0m for RepeatedCall in contract 'WyvernAtomicizer':
  > |pragma solidity ^0.4.13;
    |
    |library WyvernAtomicizer {
  at WyvernAtomicizer.sol(1)

[33mWarning[0m for TODAmount in contract 'WyvernAtomicizer':
  > |pragma solidity ^0.4.13;
    |
    |library WyvernAtomicizer {
  at WyvernAtomicizer.sol(1)

[33mWarning[0m for TODReceiver in contract 'WyvernAtomicizer':
  > |pragma solidity ^0.4.13;
    |
    |library WyvernAtomicizer {
  at WyvernAtomicizer.sol(1)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'WyvernAtomicizer':
  > |pragma solidity ^0.4.13;
    |
    |library WyvernAtomicizer {
  at WyvernAtomicizer.sol(1)

[FILE] casinoProxy.sol
Processing contract: casinoProxy.sol:casinoBank
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: casinoProxy.sol:casinoProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: casinoProxy.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: casinoProxy.sol:safeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: casinoProxy.sol:token
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for MissingInputValidation in contract 'casinoBank':
    |	}
    |
  > |	function changeOwner(address newOwner) onlyOwner public {
    |		owner = newOwner;
    |	}
  at casinoProxy.sol(30)

[31mViolation[0m for MissingInputValidation in contract 'casinoBank':
    |	uint public playerBalance;
    |	/** the balance per player in edgeless tokens with 4 virtual decimals */
  > |	mapping(address => uint) public balanceOf;
    |	/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */
    |	mapping(address => uint) public withdrawAfter;
  at casinoProxy.sol(59)

[31mViolation[0m for MissingInputValidation in contract 'casinoBank':
    |	mapping(address => uint) public balanceOf;
    |	/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */
  > |	mapping(address => uint) public withdrawAfter;
    |	/** the price per kgas in tokens (4 decimals) */
    |	uint public gasPrice = 20;
  at casinoProxy.sol(61)

[33mWarning[0m for MissingInputValidation in contract 'casinoBank':
    |	 *				 chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance
    |	 **/
  > |	function deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {
    |		require(numTokens > 0);
    |		uint value = safeMul(numTokens, 10000);
  at casinoProxy.sol(85)

[33mWarning[0m for MissingInputValidation in contract 'casinoBank':
    |	 * @param amount the amount of tokens to withdraw
    |	 **/
  > |	function withdraw(uint amount) public keepAlive {
    |		require(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);
    |		withdrawAfter[msg.sender] = 0;
  at casinoProxy.sol(116)

[33mWarning[0m for MissingInputValidation in contract 'casinoBank':
    |	 * @param numTokens the number of tokens to withdraw (0 decimals)
    |	 **/
  > |	function withdrawBankroll(uint numTokens) public onlyOwner {
    |		require(numTokens <= bankroll());
    |		assert(edg.transfer(owner, numTokens));
  at casinoProxy.sol(130)

[33mWarning[0m for TODAmount in contract 'casinoBank':
    |		uint value = safeMul(numTokens, 10000);
    |		if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);
  > |		assert(edg.transferFrom(msg.sender, address(this), numTokens));
    |		balanceOf[receiver] = safeAdd(balanceOf[receiver], value);
    |		playerBalance = safeAdd(playerBalance, value);
  at casinoProxy.sol(89)

[33mWarning[0m for TODAmount in contract 'casinoBank':
    |		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);
    |		playerBalance = safeSub(playerBalance, value);
  > |		assert(edg.transfer(msg.sender, amount));
    |		Withdrawal(msg.sender, msg.sender, amount);
    |	}
  at casinoProxy.sol(122)

[33mWarning[0m for TODAmount in contract 'casinoBank':
    |	function withdrawBankroll(uint numTokens) public onlyOwner {
    |		require(numTokens <= bankroll());
  > |		assert(edg.transfer(owner, numTokens));
    |	}
    |
  at casinoProxy.sol(132)

[33mWarning[0m for TODReceiver in contract 'casinoBank':
    |		uint value = safeMul(numTokens, 10000);
    |		if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);
  > |		assert(edg.transferFrom(msg.sender, address(this), numTokens));
    |		balanceOf[receiver] = safeAdd(balanceOf[receiver], value);
    |		playerBalance = safeAdd(playerBalance, value);
  at casinoProxy.sol(89)

[33mWarning[0m for TODReceiver in contract 'casinoBank':
    |		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);
    |		playerBalance = safeSub(playerBalance, value);
  > |		assert(edg.transfer(msg.sender, amount));
    |		Withdrawal(msg.sender, msg.sender, amount);
    |	}
  at casinoProxy.sol(122)

[33mWarning[0m for TODReceiver in contract 'casinoBank':
    |	function withdrawBankroll(uint numTokens) public onlyOwner {
    |		require(numTokens <= bankroll());
  > |		assert(edg.transfer(owner, numTokens));
    |	}
    |
  at casinoProxy.sol(132)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'casinoBank':
    |		uint value = safeMul(numTokens, 10000);
    |		if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);
  > |		assert(edg.transferFrom(msg.sender, address(this), numTokens));
    |		balanceOf[receiver] = safeAdd(balanceOf[receiver], value);
    |		playerBalance = safeAdd(playerBalance, value);
  at casinoProxy.sol(89)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'casinoBank':
    |		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);
    |		playerBalance = safeSub(playerBalance, value);
  > |		assert(edg.transfer(msg.sender, amount));
    |		Withdrawal(msg.sender, msg.sender, amount);
    |	}
  at casinoProxy.sol(122)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'casinoBank':
    |	function withdrawBankroll(uint numTokens) public onlyOwner {
    |		require(numTokens <= bankroll());
  > |		assert(edg.transfer(owner, numTokens));
    |	}
    |
  at casinoProxy.sol(132)

[31mViolation[0m for UnrestrictedWrite in contract 'casinoBank':
    |		if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);
    |		assert(edg.transferFrom(msg.sender, address(this), numTokens));
  > |		balanceOf[receiver] = safeAdd(balanceOf[receiver], value);
    |		playerBalance = safeAdd(playerBalance, value);
    |		Deposit(receiver, numTokens, chargeGas);
  at casinoProxy.sol(90)

[31mViolation[0m for UnrestrictedWrite in contract 'casinoBank':
    |		assert(edg.transferFrom(msg.sender, address(this), numTokens));
    |		balanceOf[receiver] = safeAdd(balanceOf[receiver], value);
  > |		playerBalance = safeAdd(playerBalance, value);
    |		Deposit(receiver, numTokens, chargeGas);
    |	}
  at casinoProxy.sol(91)

[31mViolation[0m for UnrestrictedWrite in contract 'casinoBank':
    |		withdrawAfter[msg.sender] = 0;
    |		uint value = safeMul(amount, 10000);
  > |		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);
    |		playerBalance = safeSub(playerBalance, value);
    |		assert(edg.transfer(msg.sender, amount));
  at casinoProxy.sol(120)

[31mViolation[0m for UnrestrictedWrite in contract 'casinoBank':
    |		uint value = safeMul(amount, 10000);
    |		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);
  > |		playerBalance = safeSub(playerBalance, value);
    |		assert(edg.transfer(msg.sender, amount));
    |		Withdrawal(msg.sender, msg.sender, amount);
  at casinoProxy.sol(121)

[31mViolation[0m for UnrestrictedWrite in contract 'casinoBank':
    |	 **/
    |	modifier keepAlive {
  > |		if (closeAt > 0) closeAt = now + 30 days;
    |		_;
    |	}
  at casinoProxy.sol(170)

[33mWarning[0m for UnrestrictedWrite in contract 'casinoBank':
    |
    |	function changeOwner(address newOwner) onlyOwner public {
  > |		owner = newOwner;
    |	}
    |}
  at casinoProxy.sol(31)

[33mWarning[0m for UnrestrictedWrite in contract 'casinoBank':
    |	function close() onlyOwner public {
    |		if (playerBalance == 0) selfdestruct(owner);
  > |		if (closeAt == 0) closeAt = now + 30 days;
    |		else if (closeAt < now) selfdestruct(owner);
    |	}
  at casinoProxy.sol(147)

[33mWarning[0m for UnrestrictedWrite in contract 'casinoBank':
    |	 **/
    |	function open() onlyOwner public {
  > |		closeAt = 0;
    |	}
    |
  at casinoProxy.sol(155)

[31mViolation[0m for RepeatedCall in contract 'casinoProxy':
    |		uint value = safeMul(numTokens, 10000);
    |		if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);
  > |		assert(edg.transferFrom(msg.sender, address(this), numTokens));
    |		balanceOf[receiver] = safeAdd(balanceOf[receiver], value);
    |		playerBalance = safeAdd(playerBalance, value);
  at casinoProxy.sol(89)

[31mViolation[0m for RepeatedCall in contract 'casinoProxy':
    |		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);
    |		playerBalance = safeSub(playerBalance, value);
  > |		assert(edg.transfer(msg.sender, amount));
    |		Withdrawal(msg.sender, msg.sender, amount);
    |	}
  at casinoProxy.sol(122)

[31mViolation[0m for RepeatedCall in contract 'casinoProxy':
    |	function withdrawBankroll(uint numTokens) public onlyOwner {
    |		require(numTokens <= bankroll());
  > |		assert(edg.transfer(owner, numTokens));
    |	}
    |
  at casinoProxy.sol(132)

[31mViolation[0m for RepeatedCall in contract 'casinoProxy':
    |		balanceOf[player] = safeSub(balanceOf[player], value);
    |		playerBalance = safeSub(playerBalance, value);
  > |		assert(edg.transfer(receiver, amount));
    |		Withdrawal(player, receiver, amount);
    |	}
  at casinoProxy.sol(235)

[33mWarning[0m for RepeatedCall in contract 'casinoProxy':
  > |/**
    | * Edgeless Casino Proxy Contract. Serves as a proxy for game functionality.
    | * Allows the players to deposit and withdraw funds.
  at casinoProxy.sol(1)

[33mWarning[0m for UnrestrictedWrite in contract 'casinoProxy':
    |	 **/
    |	modifier keepAlive {
  > |		if (closeAt > 0) closeAt = now + 30 days;
    |		_;
    |	}
  at casinoProxy.sol(170)

[33mWarning[0m for UnrestrictedWrite in contract 'casinoProxy':
    |}
    |
  > |contract casinoProxy is casinoBank {
    |	/** indicates if an address is authorized to call game functions  */
    |	mapping(address => bool) public authorized;
  at casinoProxy.sol(175)

[33mWarning[0m for UnrestrictedWrite in contract 'casinoProxy':
    |		uint gasCost = msg.gas / 1000 * gasPrice;
    |		var player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);
  > |		count[receiver]++;
    |		uint value = safeAdd(safeMul(amount, 10000), gasCost);
    |		balanceOf[player] = safeSub(balanceOf[player], value);
  at casinoProxy.sol(231)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |	}
    |
  > |	function changeOwner(address newOwner) onlyOwner public {
    |		owner = newOwner;
    |	}
  at casinoProxy.sol(30)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |	function changeOwner(address newOwner) onlyOwner public {
  > |		owner = newOwner;
    |	}
    |}
  at casinoProxy.sol(31)

[FILE] UserRank.sol
Processing contract: UserRank.sol:CanReceiveApproval
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: UserRank.sol:ERC20
Processing contract: UserRank.sol:LandAccessControl
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: UserRank.sol:LandManagementInterface
Processing contract: UserRank.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: UserRank.sol:UserRank
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'UserRank':
    |
    |
  > |contract UserRank is LandAccessControl, CanReceiveApproval {
    |    using SafeMath for uint256;
    |
  at UserRank.sol(178)

[31mViolation[0m for RepeatedCall in contract 'UserRank':
    |    function withdrawTokens() public onlyManager  {
    |        require(candyToken.balanceOf(this) > 0);
  > |        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));
    |        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));
    |    }
  at UserRank.sol(372)

[31mViolation[0m for RepeatedCall in contract 'UserRank':
    |        require(candyToken.balanceOf(this) > 0);
    |        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));
  > |        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));
    |    }
    |
  at UserRank.sol(373)

[31mViolation[0m for UnrestrictedWrite in contract 'UserRank':
    |
    |
  > |contract UserRank is LandAccessControl, CanReceiveApproval {
    |    using SafeMath for uint256;
    |
  at UserRank.sol(178)

[31mViolation[0m for UnrestrictedWrite in contract 'UserRank':
    |        uint _index = userRanks[_user] + 1;
    |        require(_index <= ranksCount);
  > |        userRanks[_user] = _index;
    |        return _index;
    |        emit BuyNextRank(msg.sender, _index);
  at UserRank.sol(309)

[31mViolation[0m for UnrestrictedWrite in contract 'UserRank':
    |        require(_index <= ranksCount);
    |        require(userRanks[_user] <= _index);
  > |        userRanks[_user] = _index;
    |        emit BuyRank(_user, _index);
    |    }
  at UserRank.sol(318)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |
    |        require(candyToken.transferFrom(_beneficiary, this, fullPrice));
  > |        userRanks[_beneficiary] = _index;
    |        emit BuyRank(_beneficiary, _index);
    |    }
  at UserRank.sol(292)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |
    |
  > |contract UserRank is LandAccessControl, CanReceiveApproval {
    |    using SafeMath for uint256;
    |
  at UserRank.sol(178)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |
    |    function init() onlyLandManagement whenPaused external {
  > |        candyToken = ERC20(landManagement.candyToken());
    |    }
    |
  at UserRank.sol(224)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |        //—Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ–±–∞–≤–ª—è–µ–º–æ–≥–æ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –Ω–∏–∂–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ
    |        require(ranks[ranksCount].priceCandy <= _priceCandy && ranks[ranksCount].priceEth <= _priceEth);
  > |        ranksCount++;
    |        Rank storage r = ranks[ranksCount];
    |
  at UserRank.sol(232)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |        Rank storage r = ranks[ranksCount];
    |
  > |        r.landLimit = _landLimit;
    |        r.priceCandy = _priceCandy;
    |        r.priceEth = _priceEth;
  at UserRank.sol(235)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |
    |        r.landLimit = _landLimit;
  > |        r.priceCandy = _priceCandy;
    |        r.priceEth = _priceEth;
    |        r.title = _title;
  at UserRank.sol(236)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |        r.landLimit = _landLimit;
    |        r.priceCandy = _priceCandy;
  > |        r.priceEth = _priceEth;
    |        r.title = _title;
    |        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);
  at UserRank.sol(237)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |
    |        Rank storage r = ranks[_index];
  > |        r.priceCandy = _priceCandy;
    |        r.priceEth = _priceEth;
    |        emit RankChange(_index, _priceCandy, _priceEth);
  at UserRank.sol(253)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |        Rank storage r = ranks[_index];
    |        r.priceCandy = _priceCandy;
  > |        r.priceEth = _priceEth;
    |        emit RankChange(_index, _priceCandy, _priceEth);
    |    }
  at UserRank.sol(254)

[33mWarning[0m for UnrestrictedWrite in contract 'UserRank':
    |        require(_index <= ranksCount);
    |        require(userRanks[_user] < _index);
  > |        userRanks[_user] = _index;
    |        emit BuyRank(_user, _index);
    |    }
  at UserRank.sol(300)

[FILE] MineableToken.sol
Processing contract: MineableToken.sol:ContractReceiver
Processing contract: MineableToken.sol:MineableToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MineableToken.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MineableToken.sol:tokenRecipient
[33mWarning[0m for LockedEther in contract 'MineableToken':
    |// - https://github.com/Dexaran/ERC23-tokens/blob/Recommended/ERC223_Token.sol
    |
  > |contract MineableToken is owned {
    |
    |  string  public name;
  at MineableToken.sol(38)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |  }
    |
  > |  function changeOwner( address _miner ) public onlyOwner {
    |    owner = _miner;
    |  }
  at MineableToken.sol(21)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC20
  > |  function balanceOf( address owner ) public constant returns (uint) {
    |    return balances_[owner];
    |  }
  at MineableToken.sol(92)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC20
  > |  function approve( address spender, uint256 value ) public
    |  returns (bool success)
    |  {
  at MineableToken.sol(97)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    | 
    |  // recommended fix for known attack on any ERC20
  > |  function safeApprove( address _spender,
    |                        uint256 _currentValue,
    |                        uint256 _value ) public
  at MineableToken.sol(111)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC20
  > |  function allowance( address owner, address spender ) public constant
    |  returns (uint256 remaining)
    |  {
  at MineableToken.sol(126)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC20
  > |  function transferFrom( address from, address to, uint256 value ) public
    |  returns (bool success)
    |  {
  at MineableToken.sol(140)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // Ethereum Token
  > |  function approveAndCall( address spender,
    |                           uint256 value,
    |                           bytes context ) public
  at MineableToken.sol(153)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // Ethereum Token
  > |  function burnFrom( address from, uint256 value ) public
    |  returns (bool success)
    |  {
  at MineableToken.sol(184)

[31mViolation[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC223 Transfer and invoke specified callback
  > |  function transfer( address to,
    |                     uint value,
    |                     bytes data,
  at MineableToken.sol(199)

[33mWarning[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC20
  > |  function transfer(address to, uint256 value) public
    |  {
    |    bytes memory empty; // null
  at MineableToken.sol(133)

[33mWarning[0m for MissingInputValidation in contract 'MineableToken':
    |
    |  // ERC223 Transfer to a contract or externally-owned account
  > |  function transfer( address to, uint value, bytes data ) public
    |  returns (bool success)
    |  {
  at MineableToken.sol(216)

[33mWarning[0m for TODAmount in contract 'MineableToken':
    |
    |    if (isContract(rx)) {
  > |      rx.tokenFallback( msg.sender, value, data );
    |      return true;
    |    }
  at MineableToken.sol(236)

[33mWarning[0m for TODReceiver in contract 'MineableToken':
    |
    |    if (isContract(rx)) {
  > |      rx.tokenFallback( msg.sender, value, data );
    |      return true;
    |    }
  at MineableToken.sol(236)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MineableToken':
    |
    |    if (isContract(rx)) {
  > |      rx.tokenFallback( msg.sender, value, data );
    |      return true;
    |    }
  at MineableToken.sol(236)

[31mViolation[0m for UnrestrictedWrite in contract 'MineableToken':
    |    require( balances_[msg.sender] >= value );
    |    balances_[msg.sender] -= value;
  > |    totalSupply -= value;
    |
    |    emit Burn( msg.sender, value );
  at MineableToken.sol(177)

[31mViolation[0m for UnrestrictedWrite in contract 'MineableToken':
    |    require( value <= allowances_[from][msg.sender] );
    |
  > |    balances_[from] -= value;
    |    allowances_[from][msg.sender] -= value;
    |    totalSupply -= value;
  at MineableToken.sol(190)

[31mViolation[0m for UnrestrictedWrite in contract 'MineableToken':
    |    balances_[from] -= value;
    |    allowances_[from][msg.sender] -= value;
  > |    totalSupply -= value;
    |
    |    emit Burn( from, value );
  at MineableToken.sol(192)

[33mWarning[0m for UnrestrictedWrite in contract 'MineableToken':
    |    if (msg.sender != owner) require( now >= 1527321600 );
    |
  > |    balances_[from] -= value;
    |    balances_[to] += value;
    |
  at MineableToken.sol(263)

[33mWarning[0m for UnrestrictedWrite in contract 'MineableToken':
    |
    |    balances_[from] -= value;
  > |    balances_[to] += value;
    |
    |    bytes memory ignore;
  at MineableToken.sol(264)

[33mWarning[0m for UnrestrictedWrite in contract 'MineableToken':
    |
    |  function changeOwner( address _miner ) public onlyOwner {
  > |    owner = _miner;
    |  }
    |
  at MineableToken.sol(22)

[33mWarning[0m for UnrestrictedWrite in contract 'MineableToken':
    |            );
    |
  > |    totalSupply += qty;
    |    balances_[owner] += qty;
    |    emit Transfer( address(0), owner, qty );
  at MineableToken.sol(82)

[33mWarning[0m for UnrestrictedWrite in contract 'MineableToken':
    |
    |    totalSupply += qty;
  > |    balances_[owner] += qty;
    |    emit Transfer( address(0), owner, qty );
    |  }
  at MineableToken.sol(83)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |  }
    |
  > |  function changeOwner( address _miner ) public onlyOwner {
    |    owner = _miner;
    |  }
  at MineableToken.sol(21)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |  function changeOwner( address _miner ) public onlyOwner {
  > |    owner = _miner;
    |  }
    |
  at MineableToken.sol(22)

[FILE] Updater.sol
Processing contract: Updater.sol:Updater
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for MissingInputValidation in contract 'Updater':
    |contract Updater
    |{
  > |    mapping (address => bool) public owners;
    |
    |    struct State {
  at Updater.sol(5)

[31mViolation[0m for MissingInputValidation in contract 'Updater':
    |        bool payment;
    |    }
  > |    mapping(address => State) public states;
    |
    |    event InfoUpdated(bytes4 indexed method, address indexed target, bool indexed res, uint256 ETHUSD, uint256 token, uint256 value);
  at Updater.sol(11)

[31mViolation[0m for MissingInputValidation in contract 'Updater':
    |    }
    |
  > |    function setOwner(address _newOwner,bool _state) onlyOwner public {
    |        emit OwnerChanged(_newOwner, _state);
    |        owners[_newOwner] = _state;
  at Updater.sol(25)

[33mWarning[0m for MissingInputValidation in contract 'Updater':
    |    }
    |
  > |    function setStates(address[] _addr, uint8[] _exchange, uint8[] _payment) onlyOwner public {
    |        for(uint256 i = 0; i < _addr.length; i++){
    |            states[_addr[i]].exchange = _exchange[i]>0;
  at Updater.sol(30)

[33mWarning[0m for MissingInputValidation in contract 'Updater':
    |    }
    |
  > |    function update(address[] _addr, uint256[] _ETHUSD, uint256[] _token, uint256[] _value) onlyOwner public {
    |        for(uint256 i = 0; i < _addr.length; i++){
    |            State storage state = states[_addr[i]];
  at Updater.sol(37)

[31mViolation[0m for RepeatedCall in contract 'Updater':
    |            bool res;
    |            if(!(state.exchange || state.payment)){
  > |                res=_addr[i].call(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_ETHUSD[i],_token[i],_value[i]);
    |                emit InfoUpdated(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_addr[i],res,_ETHUSD[i],_token[i],_value[i]);
    |                continue;
  at Updater.sol(42)

[31mViolation[0m for RepeatedCall in contract 'Updater':
    |            }
    |            if(state.exchange){
  > |                res=_addr[i].call(bytes4(keccak256("changeExchange(uint256)")),_ETHUSD[i]);
    |                emit InfoUpdated(bytes4(keccak256("changeExchange(uint256)")),_addr[i],res,_ETHUSD[i],0x0,0x0);
    |            }
  at Updater.sol(47)

[31mViolation[0m for RepeatedCall in contract 'Updater':
    |            }
    |            if(state.payment){
  > |                res=_addr[i].call(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_token[i],_value[i]);
    |                emit InfoUpdated(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_addr[i],res,0x0,_token[i],_value[i]);
    |            }
  at Updater.sol(51)

[31mViolation[0m for UnhandledException in contract 'Updater':
    |            bool res;
    |            if(!(state.exchange || state.payment)){
  > |                res=_addr[i].call(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_ETHUSD[i],_token[i],_value[i]);
    |                emit InfoUpdated(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_addr[i],res,_ETHUSD[i],_token[i],_value[i]);
    |                continue;
  at Updater.sol(42)

[31mViolation[0m for UnhandledException in contract 'Updater':
    |            }
    |            if(state.exchange){
  > |                res=_addr[i].call(bytes4(keccak256("changeExchange(uint256)")),_ETHUSD[i]);
    |                emit InfoUpdated(bytes4(keccak256("changeExchange(uint256)")),_addr[i],res,_ETHUSD[i],0x0,0x0);
    |            }
  at Updater.sol(47)

[31mViolation[0m for UnhandledException in contract 'Updater':
    |            }
    |            if(state.payment){
  > |                res=_addr[i].call(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_token[i],_value[i]);
    |                emit InfoUpdated(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_addr[i],res,0x0,_token[i],_value[i]);
    |            }
  at Updater.sol(51)

[31mViolation[0m for UnrestrictedWrite in contract 'Updater':
    |    function setOwner(address _newOwner,bool _state) onlyOwner public {
    |        emit OwnerChanged(_newOwner, _state);
  > |        owners[_newOwner] = _state;
    |    }
    |
  at Updater.sol(27)

[33mWarning[0m for UnrestrictedWrite in contract 'Updater':
    |    function setStates(address[] _addr, uint8[] _exchange, uint8[] _payment) onlyOwner public {
    |        for(uint256 i = 0; i < _addr.length; i++){
  > |            states[_addr[i]].exchange = _exchange[i]>0;
    |            states[_addr[i]].payment = _payment[i]>0;
    |        }
  at Updater.sol(32)

[33mWarning[0m for UnrestrictedWrite in contract 'Updater':
    |        for(uint256 i = 0; i < _addr.length; i++){
    |            states[_addr[i]].exchange = _exchange[i]>0;
  > |            states[_addr[i]].payment = _payment[i]>0;
    |        }
    |    }
  at Updater.sol(33)

[FILE] CandyLand.sol
Processing contract: CandyLand.sol:CanReceiveApproval
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLand.sol:CandyLand
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle8078590968759440829/mustExplicit -j 8 -F /tmp/souffle-50276827-c602-43a9-bf93-dfc9f83deaa4 -D /tmp/souffle-50276827-c602-43a9-bf93-dfc9f83deaa4_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: CandyLand.sol:CandyLand
Processing contract: CandyLand.sol:ERC20
Processing contract: CandyLand.sol:LandAccessControl
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLand.sol:LandManagementInterface
Processing contract: CandyLand.sol:MegaCandyInterface
Processing contract: CandyLand.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLand.sol:UserRankInterface
[FILE] CandyLandSale.sol
Processing contract: CandyLandSale.sol:CanReceiveApproval
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLandSale.sol:CandyLandInterface
Processing contract: CandyLandSale.sol:CandyLandSale
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLandSale.sol:DividendManagerInterface
Processing contract: CandyLandSale.sol:ERC20
Processing contract: CandyLandSale.sol:LandAccessControl
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLandSale.sol:LandManagementInterface
Processing contract: CandyLandSale.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CandyLandSale.sol:UserRankInterface
[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |        for (uint i = userRankIndex; i <= ranksCount && weiAmount >= landPriceWei; i++) {
    |
  > |            uint userLandLimit = userRank.getRankLandLimit(i).sub(candyLand.balanceOf(msg.sender)).sub(_landAmount);
    |            landCount = weiAmount.div(landPriceWei);
    |
  at CandyLandSale.sol(275)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |                weiAmount = weiAmount.sub(userLandLimit.mul(landPriceWei));
    |
  > |                uint nextPrice = (i == 0 && landManagement.firstRankForFree()) ? 0 : userRank.getRankPriceEth(i + 1);
    |
    |                if (i == ranksCount || weiAmount < nextPrice) {
  at CandyLandSale.sol(292)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |                }
    |
  > |                userRank.getNextRank(msg.sender);
    |                weiAmount = weiAmount.sub(nextPrice);
    |            }
  at CandyLandSale.sol(298)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |
    |    function findRankByCount(uint _rank, uint _totalRanks, uint _balance, uint _count) internal view returns (uint, uint) {
  > |        uint landLimit = userRank.getRankLandLimit(_rank).sub(_balance);
    |        if (_count > landLimit && _rank < _totalRanks) {
    |            return findRankByCount(_rank + 1, _totalRanks, _balance, _count);
  at CandyLandSale.sol(326)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |
    |    function getBuyLandInfo(address _owner, uint _count) public view returns (uint, uint, uint){
  > |        uint rank = userRank.getUserRank(_owner);
    |        uint neededRank;
    |        uint landLimit;
  at CandyLandSale.sol(334)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |        (neededRank, landLimit) = findRankByCount(
    |            rank,
  > |            userRank.ranksCount(),
    |            candyLand.balanceOf(_owner),
    |            _count
  at CandyLandSale.sol(340)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |            rank,
    |            userRank.ranksCount(),
  > |            candyLand.balanceOf(_owner),
    |            _count
    |        );
  at CandyLandSale.sol(341)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |        );
    |
  > |        uint landPriceCandy = landManagement.landPriceCandy();
    |
    |        if (_count > landLimit) {
  at CandyLandSale.sol(345)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |
    |        if (rank < neededRank) {
  > |            totalPrice = userRank.getIndividualPrice(_owner, neededRank);
    |            if (rank == 0 && landManagement.firstRankForFree()) {
    |                totalPrice = totalPrice.sub(userRank.getRankPriceCandy(1));
  at CandyLandSale.sol(353)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |        if (rank < neededRank) {
    |            totalPrice = userRank.getIndividualPrice(_owner, neededRank);
  > |            if (rank == 0 && landManagement.firstRankForFree()) {
    |                totalPrice = totalPrice.sub(userRank.getRankPriceCandy(1));
    |            }
  at CandyLandSale.sol(354)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |            totalPrice = userRank.getIndividualPrice(_owner, neededRank);
    |            if (rank == 0 && landManagement.firstRankForFree()) {
  > |                totalPrice = totalPrice.sub(userRank.getRankPriceCandy(1));
    |            }
    |        }
  at CandyLandSale.sol(355)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |        require(candyToken.balanceOf(this) > 0);
    |        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));
  > |        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));
    |    }
    |
  at CandyLandSale.sol(389)

[31mViolation[0m for RepeatedCall in contract 'CandyLandSale':
    |        DividendManagerInterface dividendManager = DividendManagerInterface(landManagement.dividendManagerAddress());
    |        dividendManager.payDividend.value(_value)();
  > |        emit FundsTransferred(landManagement.dividendManagerAddress(), _value);
    |    }
    |
  at CandyLandSale.sol(397)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'CandyLandSale':
    |        require(address(this).balance >= _value);
    |        DividendManagerInterface dividendManager = DividendManagerInterface(landManagement.dividendManagerAddress());
  > |        dividendManager.payDividend.value(_value)();
    |        emit FundsTransferred(landManagement.dividendManagerAddress(), _value);
    |    }
  at CandyLandSale.sol(396)

[33mWarning[0m for UnrestrictedWrite in contract 'CandyLandSale':
    |
    |    function init() onlyLandManagement whenPaused external {
  > |        userRank = UserRankInterface(landManagement.userRankAddress());
    |        candyToken = ERC20(landManagement.candyToken());
    |        candyLand = CandyLandInterface(landManagement.candyLandAddress());
  at CandyLandSale.sol(252)

[33mWarning[0m for UnrestrictedWrite in contract 'CandyLandSale':
    |    function init() onlyLandManagement whenPaused external {
    |        userRank = UserRankInterface(landManagement.userRankAddress());
  > |        candyToken = ERC20(landManagement.candyToken());
    |        candyLand = CandyLandInterface(landManagement.candyLandAddress());
    |    }
  at CandyLandSale.sol(253)

[33mWarning[0m for UnrestrictedWrite in contract 'CandyLandSale':
    |        userRank = UserRankInterface(landManagement.userRankAddress());
    |        candyToken = ERC20(landManagement.candyToken());
  > |        candyLand = CandyLandInterface(landManagement.candyLandAddress());
    |    }
    |    
  at CandyLandSale.sol(254)

Processing contract: AuctusTokenSale.sol:AuctusToken
Processing contract: AuctusTokenSale.sol:AuctusTokenSale
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AuctusTokenSale.sol:AuctusWhitelist
Processing contract: AuctusTokenSale.sol:ContractReceiver
Processing contract: AuctusTokenSale.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'AuctusTokenSale':
    |
    |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
  > |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
    |		AuctusToken token = AuctusToken(auctusTokenAddress);
  at AuctusTokenSale.sol(166)

[31mViolation[0m for DAOConstantGas in contract 'AuctusTokenSale':
    |		uint256 vestedEthers = address(this).balance - freeEthers;
    |
  > |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
    |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
  at AuctusTokenSale.sol(165)

[31mViolation[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
  > |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
    |		assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales));
    |	}
  at AuctusTokenSale.sol(236)

[31mViolation[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
  > |		assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales));
    |	}
    |}
  at AuctusTokenSale.sol(237)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		bytes memory empty;
    |		assert(token.transfer(0x6bc58c572d0973cF0EfA1Fe1D7D6c9d7Eea2cd23, auctusCoreTeam, empty)); //AuctusTokenVesting SC
  > |		assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC
    |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
  at AuctusTokenSale.sol(232)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x6bc58c572d0973cF0EfA1Fe1D7D6c9d7Eea2cd23, auctusCoreTeam, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC
  > |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
  at AuctusTokenSale.sol(233)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC
    |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
  > |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
    |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
  at AuctusTokenSale.sol(234)

[33mWarning[0m for RepeatedCall in contract 'AuctusTokenSale':
    |		assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC
  > |		assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC
    |		assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree));
    |		assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales));
  at AuctusTokenSale.sol(235)

[31mViolation[0m for TODAmount in contract 'AuctusTokenSale':
    |
    |		if (weiRemaining > 0) {
  > |			msg.sender.transfer(weiRemaining);
    |		}
    |		assert(AuctusToken(auctusTokenAddress).transfer(msg.sender, tokensToReceive));
  at AuctusTokenSale.sol(139)

[31mViolation[0m for TODAmount in contract 'AuctusTokenSale':
    |		uint256 vestedEthers = address(this).balance - freeEthers;
    |
  > |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
    |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
  at AuctusTokenSale.sol(165)

[31mViolation[0m for TODAmount in contract 'AuctusTokenSale':
    |
    |		address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner
  > |		assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC
    |
    |		AuctusToken token = AuctusToken(auctusTokenAddress);
  at AuctusTokenSale.sol(166)

[33mWarning[0m for TODAmount in contract 'AuctusTokenSale':
    |
    |		invested[msg.sender] = 0;
  > |		msg.sender.transfer(investedValue);
    |
    |		emit Revoke(msg.sender, investedValue);
  at AuctusTokenSale.sol(151)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AuctusTokenSale':
    |
    |		if (weiRemaining > 0) {
  > |			msg.sender.transfer(weiRemaining);
    |		}
    |		assert(AuctusToken(auctusTokenAddress).transfer(msg.sender, tokensToReceive));
  at AuctusTokenSale.sol(139)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AuctusTokenSale':
    |
    |		invested[msg.sender] = 0;
  > |		msg.sender.transfer(investedValue);
    |
    |		emit Revoke(msg.sender, investedValue);
  at AuctusTokenSale.sol(151)

[31mViolation[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		transferTokens(auctusCoreTeam, bounty, reserveForFuture, preSale, partnershipsAdvisoryVested, partnershipsAdvisoryFree, privateSales);
    |		
  > |		remainingTokens = totalAmount - auctusCoreTeam - bounty - reserveForFuture - preSale - partnershipsAdvisoryVested - partnershipsAdvisoryFree - privateSales;
    |		saleWasSet = true;
    |	}
  at AuctusTokenSale.sol(216)

[31mViolation[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		
    |		remainingTokens = totalAmount - auctusCoreTeam - bounty - reserveForFuture - preSale - partnershipsAdvisoryVested - partnershipsAdvisoryFree - privateSales;
  > |		saleWasSet = true;
    |	}
    |	
  at AuctusTokenSale.sol(217)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |
    |		uint256 tokensToReceive = weiToInvest.mul(basicPricePerEth);
  > |		remainingTokens = remainingTokens.sub(tokensToReceive);
    |		weiRaised = weiRaised.add(weiToInvest);
    |		invested[msg.sender] = invested[msg.sender].add(weiToInvest);
  at AuctusTokenSale.sol(134)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		uint256 tokensToReceive = weiToInvest.mul(basicPricePerEth);
    |		remainingTokens = remainingTokens.sub(tokensToReceive);
  > |		weiRaised = weiRaised.add(weiToInvest);
    |		invested[msg.sender] = invested[msg.sender].add(weiToInvest);
    |
  at AuctusTokenSale.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |	function transferOwnership(address newOwner) onlyOwner public {
    |		require(newOwner != address(0));
  > |		owner = newOwner;
    |	}
    |
  at AuctusTokenSale.sol(99)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |
    |	function setTokenSaleHalt(bool halted) onlyOwner public {
  > |		tokenSaleHalted = halted;
    |	}
    |
  at AuctusTokenSale.sol(103)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |	function setSoftCap(uint256 minimumCap) onlyOwner public {
    |		require(now < startTime);
  > |		softCap = minimumCap;
    |	}
    |
  at AuctusTokenSale.sol(108)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |	function setEndSaleTime(uint256 endSaleTime) onlyOwner public {
    |		require(now < endTime);
  > |		endTime = endSaleTime;
    |	}
    |
  at AuctusTokenSale.sol(113)

[33mWarning[0m for UnrestrictedWrite in contract 'AuctusTokenSale':
    |		if (remainingTokens > 0) {
    |			token.burn(remainingTokens);
  > |			remainingTokens = 0;
    |		}
    |	}
  at AuctusTokenSale.sol(172)

[FILE] RUNEToken.sol
Processing contract: RUNEToken.sol:ContractReceiver
Processing contract: RUNEToken.sol:RUNEToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RUNEToken.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for LockedEther in contract 'RUNEToken':
    |
    |
  > |contract RUNEToken is SafeMath
    |{
    |    
  at RUNEToken.sol(50)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC20
  > |  function balanceOf( address owner ) public constant returns (uint) {
    |    return balances_[owner];
    |  }
  at RUNEToken.sol(82)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC20
  > |  function approve( address spender, uint256 value ) public
    |  returns (bool success)
    |  {
  at RUNEToken.sol(87)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    | 
    |  // recommended fix for known attack on any ERC20
  > |  function safeApprove( address _spender,
    |                        uint256 _currentValue,
    |                        uint256 _value ) public
  at RUNEToken.sol(96)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC20
  > |  function allowance( address owner, address spender ) public constant
    |  returns (uint256 remaining)
    |  {
  at RUNEToken.sol(111)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC20
  > |  function transferFrom( address from, address to, uint256 value ) public
    |  returns (bool success)
    |  {
  at RUNEToken.sol(126)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC223 Transfer and invoke specified callback
  > |  function transfer( address to,
    |                     uint value,
    |                     bytes data,
  at RUNEToken.sol(139)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // Ethereum Token
  > |  function burnFrom( address from, uint256 value ) public
    |  returns (bool success)
    |  {
  at RUNEToken.sol(225)

[33mWarning[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC20
  > |  function transfer(address to, uint256 value) public returns (bool success)
    |  {
    |    bytes memory empty; // null
  at RUNEToken.sol(118)

[33mWarning[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |  // ERC223 Transfer to a contract or externally-owned account
  > |  function transfer( address to, uint value, bytes data ) public
    |  returns (bool success)
    |  {
  at RUNEToken.sol(159)

[33mWarning[0m for TODAmount in contract 'RUNEToken':
    |
    |    ContractReceiver rx = ContractReceiver(to);
  > |    rx.tokenFallback( msg.sender, value, data );
    |
    |    return true;
  at RUNEToken.sol(177)

[33mWarning[0m for TODReceiver in contract 'RUNEToken':
    |
    |    ContractReceiver rx = ContractReceiver(to);
  > |    rx.tokenFallback( msg.sender, value, data );
    |
    |    return true;
  at RUNEToken.sol(177)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'RUNEToken':
    |
    |    ContractReceiver rx = ContractReceiver(to);
  > |    rx.tokenFallback( msg.sender, value, data );
    |
    |    return true;
  at RUNEToken.sol(177)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |    require( balances_[to] + value > balances_[to] ); // catch overflow
    |
  > |    balances_[from] -= value;
    |    balances_[to] += value;
    |
  at RUNEToken.sol(199)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |
    |    balances_[from] -= value;
  > |    balances_[to] += value;
    |
    |    //Transfer( from, to, value, data ); ERC223-compat version
  at RUNEToken.sol(200)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |    require( balances_[msg.sender] >= value );
    |    balances_[msg.sender] -= value;
  > |    totalSupply -= value;
    |
    |    emit Burn( msg.sender, value );
  at RUNEToken.sol(218)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |    require( value <= allowances_[from][msg.sender] );
    |
  > |    balances_[from] -= value;
    |    allowances_[from][msg.sender] -= value;
    |    totalSupply -= value;
  at RUNEToken.sol(231)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |    balances_[from] -= value;
    |    allowances_[from][msg.sender] -= value;
  > |    totalSupply -= value;
    |
    |    emit Burn( from, value );
  at RUNEToken.sol(233)

[33mWarning[0m for UnrestrictedWrite in contract 'RUNEToken':
    |    require( balances_[to] + value > balances_[to] ); // catch overflow
    |
  > |    balances_[from] -= value;
    |    balances_[to] += value;
    |
  at RUNEToken.sol(199)

[33mWarning[0m for UnrestrictedWrite in contract 'RUNEToken':
    |
    |    balances_[from] -= value;
  > |    balances_[to] += value;
    |
    |    //Transfer( from, to, value, data ); ERC223-compat version
  at RUNEToken.sol(200)

[FILE] GetDecimals.sol
Processing contract: GetDecimals.sol:ERC20
Processing contract: GetDecimals.sol:GetDecimals
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for MissingInputValidation in contract 'GetDecimals':
    |
    |contract GetDecimals {
  > |    function getDecimals(ERC20 token) external view returns (uint){
    |        bytes memory data = abi.encodeWithSignature("decimals()");
    |        if(!address(token).call(data)) {
  at GetDecimals.sol(8)

[FILE] EternalStorageProxy.sol
Processing contract: EternalStorageProxy.sol:EternalStorage
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EternalStorageProxy.sol:EternalStorageProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EternalStorageProxy.sol:OwnedUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EternalStorageProxy.sol:Proxy
Processing contract: EternalStorageProxy.sol:UpgradeabilityOwnerStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EternalStorageProxy.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: EternalStorageProxy.sol:UpgradeabilityStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for MissingInputValidation in contract 'EternalStorageProxy':
    |    * @param implementation representing the address of the new implementation to be set.
    |    */
  > |    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {
    |        _upgradeTo(version, implementation);
    |    }
  at EternalStorageProxy.sol(248)

[33mWarning[0m for MissingInputValidation in contract 'EternalStorageProxy':
    |    * signature of the implementation to be called with the needed payload
    |    */
  > |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
    |        require(address(this).call.value(msg.value)(data));
  at EternalStorageProxy.sol(260)

[33mWarning[0m for TODAmount in contract 'EternalStorageProxy':
    |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
  > |        require(address(this).call.value(msg.value)(data));
    |    }
    |}
  at EternalStorageProxy.sol(262)

[33mWarning[0m for TODReceiver in contract 'EternalStorageProxy':
    |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
  > |        require(address(this).call.value(msg.value)(data));
    |    }
    |}
  at EternalStorageProxy.sol(262)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EternalStorageProxy':
    |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
  > |        require(address(this).call.value(msg.value)(data));
    |    }
    |}
  at EternalStorageProxy.sol(262)

[31mViolation[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |    */
    |    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |        _upgradeabilityOwner = newUpgradeabilityOwner;
    |    }
    |}
  at EternalStorageProxy.sol(42)

[31mViolation[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |        require(_implementation != implementation);
    |        require(version > _version);
  > |        _version = version;
    |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
  at EternalStorageProxy.sol(190)

[31mViolation[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |        require(version > _version);
    |        _version = version;
  > |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
    |    }
  at EternalStorageProxy.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |        require(_implementation != implementation);
    |        require(version > _version);
  > |        _version = version;
    |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
  at EternalStorageProxy.sol(190)

[33mWarning[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |        require(version > _version);
    |        _version = version;
  > |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
    |    }
  at EternalStorageProxy.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |    */
    |    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |        _upgradeabilityOwner = newUpgradeabilityOwner;
    |    }
    |}
  at EternalStorageProxy.sol(42)

[33mWarning[0m for MissingInputValidation in contract 'OwnedUpgradeabilityProxy':
    |    * @param implementation representing the address of the new implementation to be set.
    |    */
  > |    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {
    |        _upgradeTo(version, implementation);
    |    }
  at EternalStorageProxy.sol(248)

[33mWarning[0m for MissingInputValidation in contract 'OwnedUpgradeabilityProxy':
    |    * signature of the implementation to be called with the needed payload
    |    */
  > |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
    |        require(address(this).call.value(msg.value)(data));
  at EternalStorageProxy.sol(260)

[33mWarning[0m for TODAmount in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
  > |        require(address(this).call.value(msg.value)(data));
    |    }
    |}
  at EternalStorageProxy.sol(262)

[33mWarning[0m for TODReceiver in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
  > |        require(address(this).call.value(msg.value)(data));
    |    }
    |}
  at EternalStorageProxy.sol(262)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
    |        upgradeTo(version, implementation);
  > |        require(address(this).call.value(msg.value)(data));
    |    }
    |}
  at EternalStorageProxy.sol(262)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |    */
    |    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |        _upgradeabilityOwner = newUpgradeabilityOwner;
    |    }
    |}
  at EternalStorageProxy.sol(42)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        require(_implementation != implementation);
    |        require(version > _version);
  > |        _version = version;
    |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
  at EternalStorageProxy.sol(190)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        require(version > _version);
    |        _version = version;
  > |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
    |    }
  at EternalStorageProxy.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        require(_implementation != implementation);
    |        require(version > _version);
  > |        _version = version;
    |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
  at EternalStorageProxy.sol(190)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        require(version > _version);
    |        _version = version;
  > |        _implementation = implementation;
    |        emit Upgraded(version, implementation);
    |    }
  at EternalStorageProxy.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |    */
    |    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |        _upgradeabilityOwner = newUpgradeabilityOwner;
    |    }
    |}
  at EternalStorageProxy.sol(42)

[FILE] ParsecInitialShip.sol
Processing contract: ParsecInitialShip.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:ERC20
Processing contract: ParsecInitialShip.sol:ERC20Basic
Processing contract: ParsecInitialShip.sol:ERC721
Processing contract: ParsecInitialShip.sol:ERC721Basic
Processing contract: ParsecInitialShip.sol:ERC721BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:ERC721Enumerable
Processing contract: ParsecInitialShip.sol:ERC721Metadata
Processing contract: ParsecInitialShip.sol:ERC721Receiver
Processing contract: ParsecInitialShip.sol:ERC721Token
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:HasNoContracts
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:HasNoEther
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:HasNoTokens
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:NoOwner
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:ParsecInitialShip
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle1585021692339301817/mustExplicit -j 8 -F /tmp/souffle-0f5de500-7c87-4904-b790-7405a50a4140 -D /tmp/souffle-0f5de500-7c87-4904-b790-7405a50a4140_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: ParsecInitialShip.sol:ParsecInitialShip
Processing contract: ParsecInitialShip.sol:ParsecReferralTracking
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:ParsecShipAuction
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle1585021692339301817/mustExplicit -j 8 -F /tmp/souffle-7848dc9b-eb9f-4a9e-b804-4379fb8923a8 -D /tmp/souffle-7848dc9b-eb9f-4a9e-b804-4379fb8923a8_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: ParsecInitialShip.sol:ParsecShipAuction
Processing contract: ParsecInitialShip.sol:ParsecShipInfo
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:ParsecShipPricing
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:Pausable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:SafeERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ParsecInitialShip.sol:TokenRecipient
[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[31mViolation[0m for LockedEther in contract 'ERC721Token':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Token is ERC721, ERC721BasicToken {
    |  // Token name
    |  string internal name_;
  at ParsecInitialShip.sol(848)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721Token':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Token is ERC721, ERC721BasicToken {
    |  // Token name
    |  string internal name_;
  at ParsecInitialShip.sol(848)

[33mWarning[0m for UnrestrictedWrite in contract 'HasNoContracts':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[31mViolation[0m for TODAmount in contract 'HasNoEther':
    |  function reclaimEther() external onlyOwner {
    |    // solium-disable-next-line security/no-send
  > |    assert(owner.send(address(this).balance));
    |  }
    |}
  at ParsecInitialShip.sol(1340)

[31mViolation[0m for TODReceiver in contract 'HasNoEther':
    |  function reclaimEther() external onlyOwner {
    |    // solium-disable-next-line security/no-send
  > |    assert(owner.send(address(this).balance));
    |  }
    |}
  at ParsecInitialShip.sol(1340)

[33mWarning[0m for UnrestrictedWrite in contract 'HasNoEther':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[33mWarning[0m for UnrestrictedWrite in contract 'HasNoTokens':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[31mViolation[0m for TODAmount in contract 'NoOwner':
    |  function reclaimEther() external onlyOwner {
    |    // solium-disable-next-line security/no-send
  > |    assert(owner.send(address(this).balance));
    |  }
    |}
  at ParsecInitialShip.sol(1340)

[31mViolation[0m for TODReceiver in contract 'NoOwner':
    |  function reclaimEther() external onlyOwner {
    |    // solium-disable-next-line security/no-send
  > |    assert(owner.send(address(this).balance));
    |  }
    |}
  at ParsecInitialShip.sol(1340)

[33mWarning[0m for UnrestrictedWrite in contract 'NoOwner':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[31mViolation[0m for MissingInputValidation in contract 'ParsecReferralTracking':
    |
    |contract ParsecReferralTracking {
  > |  mapping (address => address) public referrer;
    |
    |  event ReferrerUpdated(address indexed _referee, address indexed _referrer);
  at ParsecInitialShip.sol(6)

[33mWarning[0m for UnrestrictedWrite in contract 'Pausable':
    |    require(newOwner != address(0));
    |    emit OwnershipTransferred(owner, newOwner);
  > |    owner = newOwner;
    |  }
    |
  at ParsecInitialShip.sol(351)

[33mWarning[0m for UnrestrictedWrite in contract 'Pausable':
    |   */
    |  function pause() onlyOwner whenNotPaused public {
  > |    paused = true;
    |    emit Pause();
    |  }
  at ParsecInitialShip.sol(389)

[33mWarning[0m for UnrestrictedWrite in contract 'Pausable':
    |   */
    |  function unpause() onlyOwner whenPaused public {
  > |    paused = false;
    |    emit Unpause();
    |  }
  at ParsecInitialShip.sol(397)

[FILE] AWinner.sol
Processing contract: AWinner.sol:AWinner
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AWinner.sol:Child
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AWinner.sol:Roulette
[31mViolation[0m for MissingInputValidation in contract 'AWinner':
    |    }
    |    
  > |    function getPlayer(uint256 index) public view returns(address) {
    |        return roulette.players(index);
    |    }
  at AWinner.sol(49)

[31mViolation[0m for TODAmount in contract 'AWinner':
    |        
    |        require(address(this).balance > prevBalance);
  > |        address(0x083fc10cE7e97CaFBaE0fE332a9c4384c5f54E45).transfer(address(this).balance);
    |    }
    |    
  at AWinner.sol(46)

[33mWarning[0m for TODAmount in contract 'AWinner':
    |    
    |    function getPlayer(uint256 index) public view returns(address) {
  > |        return roulette.players(index);
    |    }
    |    
  at AWinner.sol(50)

[33mWarning[0m for TODAmount in contract 'AWinner':
    |    function getPlayersLength() public view returns(uint256) {
    |        for (uint i = 0; i < 10; i++) {
  > |            if (!address(roulette).call.gas(0x400)(abi.encodeWithSelector(roulette.players.selector, i))) {
    |                return i;
    |            }
  at AWinner.sol(55)

[33mWarning[0m for TODReceiver in contract 'AWinner':
    |        uint256 prevBalance = address(this).balance;
    |        for (uint i = getPlayersLength(); i < 4; i++) {
  > |            require(address(roulette).call.value(1 ether)());
    |        }
    |        
  at AWinner.sol(35)

[33mWarning[0m for TODReceiver in contract 'AWinner':
    |        for (i = 0; i < children.length; i++) {
    |            if (getRandom(children[i]) % 5 == 0) {
  > |                children[i].win.value(1 ether)(roulette);
    |                break;
    |            }
  at AWinner.sol(40)

[33mWarning[0m for TODReceiver in contract 'AWinner':
    |    
    |    function getPlayer(uint256 index) public view returns(address) {
  > |        return roulette.players(index);
    |    }
    |    
  at AWinner.sol(50)

[31mViolation[0m for UnrestrictedEtherFlow in contract 'AWinner':
    |        uint256 prevBalance = address(this).balance;
    |        for (uint i = getPlayersLength(); i < 4; i++) {
  > |            require(address(roulette).call.value(1 ether)());
    |        }
    |        
  at AWinner.sol(35)

[31mViolation[0m for UnrestrictedEtherFlow in contract 'AWinner':
    |        for (i = 0; i < children.length; i++) {
    |            if (getRandom(children[i]) % 5 == 0) {
  > |                children[i].win.value(1 ether)(roulette);
    |                break;
    |            }
  at AWinner.sol(40)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AWinner':
    |        
    |        require(address(this).balance > prevBalance);
  > |        address(0x083fc10cE7e97CaFBaE0fE332a9c4384c5f54E45).transfer(address(this).balance);
    |    }
    |    
  at AWinner.sol(46)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AWinner':
    |    
    |    function getPlayer(uint256 index) public view returns(address) {
  > |        return roulette.players(index);
    |    }
    |    
  at AWinner.sol(50)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AWinner':
    |    function getPlayersLength() public view returns(uint256) {
    |        for (uint i = 0; i < 10; i++) {
  > |            if (!address(roulette).call.gas(0x400)(abi.encodeWithSelector(roulette.players.selector, i))) {
    |                return i;
    |            }
  at AWinner.sol(55)

[31mViolation[0m for MissingInputValidation in contract 'Child':
    |    }
    |    
  > |    function win(address target) public payable {
    |        require(target.call.value(msg.value)());
    |        msg.sender.transfer(address(this).balance);
  at AWinner.sol(13)

[31mViolation[0m for TODAmount in contract 'Child':
    |    function win(address target) public payable {
    |        require(target.call.value(msg.value)());
  > |        msg.sender.transfer(address(this).balance);
    |    }
    |}
  at AWinner.sol(15)

[33mWarning[0m for TODAmount in contract 'Child':
    |    
    |    function win(address target) public payable {
  > |        require(target.call.value(msg.value)());
    |        msg.sender.transfer(address(this).balance);
    |    }
  at AWinner.sol(14)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Child':
    |    
    |    function win(address target) public payable {
  > |        require(target.call.value(msg.value)());
    |        msg.sender.transfer(address(this).balance);
    |    }
  at AWinner.sol(14)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Child':
    |    function win(address target) public payable {
    |        require(target.call.value(msg.value)());
  > |        msg.sender.transfer(address(this).balance);
    |    }
    |}
  at AWinner.sol(15)

[FILE] AddressDeployer.sol
Processing contract: AddressDeployer.sol:Address
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:AddressDeployer
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:ERC165
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:ERC721
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:ERC721Enumerable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:ERC721Full
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:ERC721Metadata
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressDeployer.sol:IAddressDeployerOwner
Processing contract: AddressDeployer.sol:IERC165
Processing contract: AddressDeployer.sol:IERC721
Processing contract: AddressDeployer.sol:IERC721Enumerable
Processing contract: AddressDeployer.sol:IERC721Metadata
Processing contract: AddressDeployer.sol:IERC721Receiver
Processing contract: AddressDeployer.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for MissingInputValidation in contract 'AddressDeployer':
    |    }
    |
  > |    function transferOwnership(address _newOwner) public onlyOwner {
    |        owner = _newOwner;
    |    }
  at AddressDeployer.sol(857)

[31mViolation[0m for MissingInputValidation in contract 'AddressDeployer':
    |    }
    |
  > |    function transferOwnershipAndNotify(IAddressDeployerOwner _newOwner) public onlyOwner {
    |        owner = _newOwner;
    |        require(_newOwner.ownershipTransferred(msg.sender));
  at AddressDeployer.sol(861)

[33mWarning[0m for UnrestrictedWrite in contract 'AddressDeployer':
    |
    |    function transferOwnership(address _newOwner) public onlyOwner {
  > |        owner = _newOwner;
    |    }
    |
  at AddressDeployer.sol(858)

[33mWarning[0m for UnrestrictedWrite in contract 'AddressDeployer':
    |
    |    function transferOwnershipAndNotify(IAddressDeployerOwner _newOwner) public onlyOwner {
  > |        owner = _newOwner;
    |        require(_newOwner.ownershipTransferred(msg.sender));
    |    }
  at AddressDeployer.sol(862)

[31mViolation[0m for MissingInputValidation in contract 'ERC165':
    |   * @dev implement supportsInterface(bytes4) using a lookup table
    |   */
  > |  function supportsInterface(bytes4 interfaceId)
    |    external
    |    view
  at AddressDeployer.sol(231)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721Enumerable':
    |// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol
    |
  > |contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {
    |  // Mapping from owner to list of owned token IDs
    |  mapping(address => uint256[]) private _ownedTokens;
  at AddressDeployer.sol(591)

[31mViolation[0m for LockedEther in contract 'ERC721Full':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {
    |  constructor(string name, string symbol) ERC721Metadata(name, symbol)
    |    public
  at AddressDeployer.sol(835)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721Full':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {
    |  constructor(string name, string symbol) ERC721Metadata(name, symbol)
    |    public
  at AddressDeployer.sol(835)

[31mViolation[0m for LockedEther in contract 'ERC721Metadata':
    |// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol
    |
  > |contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {
    |  // Token name
    |  string internal _name;
  at AddressDeployer.sol(745)

[FILE] AddressToken.sol
Processing contract: AddressToken.sol:Address
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:AddressDeployer
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:AddressToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:ERC165
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:ERC721
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:ERC721Enumerable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:ERC721Full
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:ERC721Metadata
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AddressToken.sol:IAddressDeployerOwner
Processing contract: AddressToken.sol:IERC165
Processing contract: AddressToken.sol:IERC721
Processing contract: AddressToken.sol:IERC721Enumerable
Processing contract: AddressToken.sol:IERC721Metadata
Processing contract: AddressToken.sol:IERC721Receiver
Processing contract: AddressToken.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for MissingInputValidation in contract 'AddressDeployer':
    |    }
    |
  > |    function transferOwnership(address _newOwner) public onlyOwner {
    |        owner = _newOwner;
    |    }
  at AddressToken.sol(856)

[31mViolation[0m for MissingInputValidation in contract 'AddressDeployer':
    |    }
    |
  > |    function transferOwnershipAndNotify(IAddressDeployerOwner _newOwner) public onlyOwner {
    |        owner = _newOwner;
    |        require(_newOwner.ownershipTransferred(msg.sender));
  at AddressToken.sol(860)

[33mWarning[0m for UnrestrictedWrite in contract 'AddressDeployer':
    |
    |    function transferOwnership(address _newOwner) public onlyOwner {
  > |        owner = _newOwner;
    |    }
    |
  at AddressToken.sol(857)

[33mWarning[0m for UnrestrictedWrite in contract 'AddressDeployer':
    |
    |    function transferOwnershipAndNotify(IAddressDeployerOwner _newOwner) public onlyOwner {
  > |        owner = _newOwner;
    |        require(_newOwner.ownershipTransferred(msg.sender));
    |    }
  at AddressToken.sol(861)

[31mViolation[0m for LockedEther in contract 'AddressToken':
    |// File: contracts/AddressToken.sol
    |
  > |contract AddressToken is ERC721Full("AddressToken", "ATKN"), IAddressDeployerOwner {
    |    bytes32 public deployerHash;
    |
  at AddressToken.sol(873)

[33mWarning[0m for UnrestrictedWrite in contract 'AddressToken':
    |// File: contracts/AddressToken.sol
    |
  > |contract AddressToken is ERC721Full("AddressToken", "ATKN"), IAddressDeployerOwner {
    |    bytes32 public deployerHash;
    |
  at AddressToken.sol(873)

[31mViolation[0m for MissingInputValidation in contract 'ERC165':
    |   * @dev implement supportsInterface(bytes4) using a lookup table
    |   */
  > |  function supportsInterface(bytes4 interfaceId)
    |    external
    |    view
  at AddressToken.sol(231)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721Enumerable':
    |// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol
    |
  > |contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {
    |  // Mapping from owner to list of owned token IDs
    |  mapping(address => uint256[]) private _ownedTokens;
  at AddressToken.sol(591)

[31mViolation[0m for LockedEther in contract 'ERC721Full':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {
    |  constructor(string name, string symbol) ERC721Metadata(name, symbol)
    |    public
  at AddressToken.sol(835)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721Full':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {
    |  constructor(string name, string symbol) ERC721Metadata(name, symbol)
    |    public
  at AddressToken.sol(835)

[31mViolation[0m for LockedEther in contract 'ERC721Metadata':
    |// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol
    |
  > |contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {
    |  // Token name
    |  string internal _name;
  at AddressToken.sol(745)

[FILE] AdminUpgradeabilityProxy.sol
Processing contract: AdminUpgradeabilityProxy.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AdminUpgradeabilityProxy.sol:AdminUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: AdminUpgradeabilityProxy.sol:Proxy
Processing contract: AdminUpgradeabilityProxy.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for RepeatedCall in contract 'AdminUpgradeabilityProxy':
    |      // Call the implementation.
    |      // out and outsize are 0 because we don't know the size yet.
  > |      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |      // Copy the returned data.
  at AdminUpgradeabilityProxy.sol(41)

[33mWarning[0m for TODAmount in contract 'AdminUpgradeabilityProxy':
    |  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
    |    _upgradeTo(newImplementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |
  at AdminUpgradeabilityProxy.sol(262)

Processing contract: BBFarm.sol:BBFarm
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BBFarmEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BBFarmIface
Processing contract: BBFarm.sol:BBLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BPackedUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:BytesLib
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:CommAuctionIface
Processing contract: BBFarm.sol:CommunityAuctionSimple
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:ENSIface
Processing contract: BBFarm.sol:ERC20Interface
Processing contract: BBFarm.sol:EnsOwnerProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:IxBackendIface
Processing contract: BBFarm.sol:IxIface
Processing contract: BBFarm.sol:IxLib
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:IxPaymentsIface
Processing contract: BBFarm.sol:PublicResolver
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVBallotConsts
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVIndex
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVIndexBackend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SVPayments
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:SvEnsIface
Processing contract: BBFarm.sol:controlledIface
Processing contract: BBFarm.sol:hasAdmins
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:hasVersion
Processing contract: BBFarm.sol:ixBackendEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:ixEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:ixPaymentEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:payoutAllC
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:payoutAllCSettable
Processing contract: BBFarm.sol:permissioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:safeSend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: BBFarm.sol:upgradePtr
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAO in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'BBFarm':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function logSponsorship(DB storage db, uint value) internal {
  > |        db.sponsors.push(Sponsor(msg.sender, value));
    |    }
    |
  at BBFarm.sol(181)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'BBFarm':
    |        // we need to call the init functions on our libraries
    |        getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));
  > |        nBallots += 1;
    |
    |        emit BallotCreatedWithID(ballotId);
  at BBFarm.sol(1025)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function revealSeckey(DB storage db, bytes32 sk) internal {
  > |        db.ballotEncryptionSeckey = sk;
    |        emit SeckeyRevealed(sk);
    |    }
  at BBFarm.sol(284)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLib.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.deprecated = true;
    |    }
    |
  at BBFarm.sol(1131)

[33mWarning[0m for UnrestrictedWrite in contract 'BBFarm':
    |        BBLib.DB storage db = getDb(ballotId);
    |        db.requireBallotOwner();
  > |        db.ballotOwner = newOwner;
    |    }
    |}
  at BBFarm.sol(1137)

[31mViolation[0m for LockedEther in contract 'BBLib':
    |}
    |
  > |library BBLib {
    |    using BytesLib for bytes;
    |
  at BBFarm.sol(10)

[31mViolation[0m for UnrestrictedWrite in contract 'BBLib':
    |        // any future votes.
    |        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");
  > |        db.sequenceNumber[voter] = sequence;
    |    }
    |
  at BBFarm.sol(271)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |}
    |
  > |library BBLib {
    |    using BytesLib for bytes;
    |
  at BBFarm.sol(10)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        require(db.specHash == bytes32(0), "b-exists");
    |
  > |        db.index = ix;
    |        db.ballotOwner = ballotOwner;
    |
  at BBFarm.sol(137)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        db.index = ix;
  > |        db.ballotOwner = ballotOwner;
    |
    |        uint64 startTs;
  at BBFarm.sol(138)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        }
    |        require(_specHash != bytes32(0), "null-specHash");
  > |        db.specHash = _specHash;
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  at BBFarm.sol(166)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        db.specHash = _specHash;
    |
  > |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
    |        db.creationTs = now;
    |
  at BBFarm.sol(168)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        db.packed = BPackedUtils.pack(sb, startTs, endTs);
  > |        db.creationTs = now;
    |
    |        if (extraData != bytes16(0)) {
  at BBFarm.sol(169)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        if (extraData != bytes16(0)) {
  > |            db.extraData = extraData;
    |        }
    |
  at BBFarm.sol(172)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |
    |        id = db.nVotesCast;
  > |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
    |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
  at BBFarm.sol(256)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        db.votes[id].voteData = voteData;
    |        // pack the casting ts right next to the sender
  > |        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);
    |        if (extra.length > 0) {
    |            db.votes[id].extra = extra;
  at BBFarm.sol(258)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |            db.votes[id].extra = extra;
    |        }
  > |        db.nVotesCast += 1;
    |        emit SuccessfulVote(sender, id);
    |    }
  at BBFarm.sol(262)

[33mWarning[0m for UnrestrictedWrite in contract 'BBLib':
    |        uint64 sTs;
    |        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);
  > |        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);
    |    }
    |
  at BBFarm.sol(280)

[31mViolation[0m for MissingInputValidation in contract 'CanReclaimToken':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'CommunityAuctionSimple':
    |
    |    function setPriceWei(uint newPrice) only_owner() external {
  > |        commBallotPriceWei = newPrice;
    |    }
    |}
  at BBFarm.sol(616)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function setAddr(address addr) only_admin() external {
    |        _setAddr(addr);
    |    }
  at BBFarm.sol(711)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToENS(bytes data) only_owner() external {
    |        require(address(ens).call(data), "fwding to ens failed");
    |    }
  at BBFarm.sol(723)

[31mViolation[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function fwdToResolver(bytes data) only_owner() external {
    |        require(address(resolver).call(data), "fwding to resolver failed");
    |    }
  at BBFarm.sol(727)

[33mWarning[0m for MissingInputValidation in contract 'EnsOwnerProxy':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[33mWarning[0m for TODAmount in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBFarm.sol(716)

[33mWarning[0m for TODReceiver in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBFarm.sol(716)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EnsOwnerProxy':
    |
    |    function _setAddr(address addr) internal {
  > |        resolver.setAddr(ensNode, addr);
    |    }
    |
  at BBFarm.sol(716)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'EnsOwnerProxy':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[31mViolation[0m for LockedEther in contract 'IxLib':
    |}
    |
  > |library IxLib {
    |    /**
    |     * Usage: `using IxLib for IxIface`
  at BBFarm.sol(379)

[31mViolation[0m for MissingInputValidation in contract 'IxLib':
    |    }
    |
  > |    function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {
    |        return ix.getBackend().getDArbitraryData(democHash, key);
    |    }
  at BBFarm.sol(472)

[31mViolation[0m for LockedEther in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBFarm.sol(2287)

[31mViolation[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBFarm.sol(2287)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |}
    |
  > |contract PublicResolver {
    |
    |    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;
  at BBFarm.sol(2287)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setAddr(bytes32 node, address addr) public only_owner(node) {
  > |        records[node].addr = addr;
    |        emit AddrChanged(node, addr);
    |    }
  at BBFarm.sol(2342)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {
  > |        records[node].content = hash;
    |        emit ContentChanged(node, hash);
    |    }
  at BBFarm.sol(2355)

[33mWarning[0m for UnrestrictedWrite in contract 'PublicResolver':
    |     */
    |    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
  > |        records[node].pubkey = PublicKey(x, y);
    |        emit PubkeyChanged(node, x, y);
    |    }
  at BBFarm.sol(2393)

[31mViolation[0m for DAO in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        ensOwnerPx.setAddr(nextSC);
    |        ensOwnerPx.upgradeMeAdmin(nextSC);
  > |        commAuction.upgradeMe(nextSC);
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  at BBFarm.sol(1251)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        for (uint i = 0; i < bbFarms.length; i++) {
  > |            bbFarms[i].upgradeMe(nextSC);
    |        }
    |    }
  at BBFarm.sol(1254)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        require(bbNamespace != bytes4(0), "bb-farm-namespace");
  > |        require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), "bb-namespace-used");
    |
    |        bbFarmId = _addBBFarm(bbNamespace, bbFarm);
  at BBFarm.sol(1273)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        }
    |
  > |        ballotId = _bbFarm.initBallot(
    |            specHash,
    |            packed,
  at BBFarm.sol(1451)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        doSafeSend(msg.sender, msg.value - price);
    |
  > |        bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);
    |        require(canProceed, "!cb-enabled");
    |
  at BBFarm.sol(1472)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |
    |        uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);
  > |        commAuction.noteBallotDeployed(democHash);
    |
    |        emit CommunityBallot(democHash, ballotId);
  at BBFarm.sol(1478)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |    function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {
    |        // backend handles events
  > |        backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);
    |    }
    |
  at BBFarm.sol(1494)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if the ballot is marked as official require the democracy is paid up to
    |        // some relative amount - exclude NFP accounts from this check
  > |        uint secsLeft = payments.getSecondsRemaining(democHash);
    |        // must be positive due to ending in future check
    |        uint256 secsToEndTime = endTime - now;
  at BBFarm.sol(1501)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // if we're an official ballot and the democ is basic, ensure the democ
    |        // isn't over the ballots/mo limit
  > |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
  at BBFarm.sol(1511)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        // isn't over the ballots/mo limit
    |        if (payments.getPremiumStatus(democHash) == false) {
  > |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
    |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
  at BBFarm.sol(1512)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |        if (payments.getPremiumStatus(democHash) == false) {
    |            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();
  > |            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);
    |
    |            // if the democ has less than nBallotsAllowed then it's guarenteed to be okay
  at BBFarm.sol(1513)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // nBallotsBasicCounted-X. There would thus be (X-1) ballots that are _more_
    |            // recent than the one we're looking for.
  > |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
    |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
  at BBFarm.sol(1528)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // recent than the one we're looking for.
    |            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);
  > |            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);
    |
    |            // if the earlyBallot was created more than 30 days in the past we should
  at BBFarm.sol(1529)

[31mViolation[0m for RepeatedCall in contract 'SVIndex':
    |            // where the Nth most recent ballot was created within the last 30 days.)
    |            // We should now check for payment
  > |            uint extraBallotFee = payments.getBasicExtraBallotFeeWei();
    |            require(msg.value >= extraBallotFee, "!extra-b-fee");
    |
  at BBFarm.sol(1541)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBFarm.sol(1331)

[31mViolation[0m for TODReceiver in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBFarm.sol(1331)

[33mWarning[0m for TODReceiver in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndex':
    |        require(msg.value >= payments.getMinWeiForDInit());
    |        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);
  > |        payments.payForDemocracy.value(msg.value)(democHash);
    |        return democHash;
    |    }
  at BBFarm.sol(1331)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndex':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for DAO in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for LockedEther in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at BBFarm.sol(1605)

[33mWarning[0m for TODAmount in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODReceiver in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVIndexBackend':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |}
    |
  > |contract SVIndexBackend is IxBackendIface {
    |    uint constant VERSION = 2;
    |
  at BBFarm.sol(1605)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");
    |        // set owner and editor
  > |        d.owner = newOwner;
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  at BBFarm.sol(1739)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // set owner and editor
    |        d.owner = newOwner;
  > |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
    |        d.erc20OwnerClaimDisabled = true;
  at BBFarm.sol(1740)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.editors[d.editorEpoch][newOwner] = true;
    |        // disable the ability to claim now that it's done
  > |        d.erc20OwnerClaimDisabled = true;
    |        emit DemocOwnerSet(democHash, newOwner);
    |        emit DemocClaimed(democHash);
  at BBFarm.sol(1742)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {
    |        Democ storage d = democs[democHash];
  > |        d.editors[d.editorEpoch][editor] = canEdit;
    |        emit DemocEditorSet(democHash, editor, canEdit);
    |    }
  at BBFarm.sol(1749)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDNoEditors(bytes32 democHash) only_editors() external {
  > |        democs[democHash].editorEpoch += 1;
    |        emit DemocEditorsWiped(democHash);
    |    }
  at BBFarm.sol(1754)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
  > |        democs[democHash].erc20 = newErc20;
    |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
  at BBFarm.sol(1759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {
    |        democs[democHash].erc20 = newErc20;
  > |        erc20ToDemocs[newErc20].push(democHash);
    |        emit DemocErc20Set(democHash, newErc20);
    |    }
  at BBFarm.sol(1760)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {
    |        uint catId = democCategories[democHash].nCategories;
  > |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  at BBFarm.sol(1778)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democCategories[democHash].categories[catId].name = name;
    |        if (hasParent) {
  > |            democCategories[democHash].categories[catId].hasParent = true;
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  at BBFarm.sol(1780)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (hasParent) {
    |            democCategories[democHash].categories[catId].hasParent = true;
  > |            democCategories[democHash].categories[catId].parent = parent;
    |        }
    |        democCategories[democHash].nCategories += 1;
  at BBFarm.sol(1781)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |            democCategories[democHash].categories[catId].parent = parent;
    |        }
  > |        democCategories[democHash].nCategories += 1;
    |        emit DemocCatAdded(democHash, catId);
    |    }
  at BBFarm.sol(1783)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {
  > |        democCategories[democHash].categories[catId].deprecated = true;
    |        emit DemocCatDeprecated(democHash, catId);
    |    }
  at BBFarm.sol(1788)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {
  > |        democs[democHash].communityBallotsDisabled = !enabled;
    |        emit DemocCommunityBallotsEnabled(democHash, enabled);
    |    }
  at BBFarm.sol(1793)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {
  > |        democs[democHash].erc20OwnerClaimDisabled = true;
    |        emit DemocErc20OwnerClaimDisabled(democHash);
    |    }
  at BBFarm.sol(1798)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |        uint localBallotId = democs[democHash].allBallots.length;
  > |        democs[democHash].allBallots.push(ballotId);
    |
    |        // do this for anything that doesn't qualify as a community ballot
  at BBFarm.sol(1809)

[31mViolation[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // do this for anything that doesn't qualify as a community ballot
    |        if (countTowardsLimit) {
  > |            democs[democHash].includedBasicBallots.push(ballotId);
    |        }
    |
  at BBFarm.sol(1813)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |
    |    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {
  > |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
    |        d.erc20 = erc20;
  at BBFarm.sol(1682)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        democList.push(democHash);
    |        Democ storage d = democs[democHash];
  > |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
    |            d.erc20OwnerClaimDisabled = true;
  at BBFarm.sol(1684)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        d.erc20 = erc20;
    |        if (disableErc20OwnerClaim) {
  > |            d.erc20OwnerClaimDisabled = true;
    |        }
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
  at BBFarm.sol(1686)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
  > |        democPrefixToHash[bytes13(democHash)] = democHash;
    |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
  at BBFarm.sol(1690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));
    |        democPrefixToHash[bytes13(democHash)] = democHash;
  > |        erc20ToDemocs[erc20].push(democHash);
    |        _setDOwner(democHash, initOwner);
    |        emit NewDemoc(democHash);
  at BBFarm.sol(1691)

[33mWarning[0m for UnrestrictedWrite in contract 'SVIndexBackend':
    |        Democ storage d = democs[democHash];
    |        uint epoch = d.editorEpoch;
  > |        d.owner = newOwner;
    |        // unset prev owner as editor - does little if one was not set
    |        d.editors[epoch][d.owner] = false;
  at BBFarm.sol(1722)

[33mWarning[0m for DAO in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at BBFarm.sol(758)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(766)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(773)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at BBFarm.sol(779)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    // contracts are compromised? (e.g. by a leaked privkey)
    |    address public emergencyAdmin;
  > |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
    |        owner = newOwner;
  at BBFarm.sol(1993)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function doFreeExtension(bytes32 democHash) external {
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  at BBFarm.sol(2064)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
    |        accounts[democHash].isPremium = false;
  at BBFarm.sol(2071)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeToPremium(bytes32 democHash) only_editors() external {
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  at BBFarm.sol(2088)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account status - getters */
    |
  > |    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].paidUpTill >= now;
    |    }
  at BBFarm.sol(2106)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {
    |        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);
    |    }
  at BBFarm.sol(2110)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getPremiumStatus(bytes32 democHash) external view returns (bool) {
    |        return accounts[democHash].isPremium;
    |    }
  at BBFarm.sol(2114)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getFreeExtension(bytes32 democHash) external view returns (bool) {
    |        return freeExtension[democHash];
    |    }
  at BBFarm.sol(2118)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {
    |        isPremium = accounts[democHash].isPremium;
    |        lastPaymentTs = accounts[democHash].lastPaymentTs;
  at BBFarm.sol(2122)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function getDenyPremium(bytes32 democHash) external view returns (bool) {
    |        return denyPremium[democHash];
    |    }
  at BBFarm.sol(2129)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin utils for accounts */
    |
  > |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
    |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
  at BBFarm.sol(2135)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    /* admin setters global */
    |
  > |    function setPayTo(address newPayTo) only_owner() external {
    |        _setPayTo(newPayTo);
    |        emit SetPayTo(newPayTo);
  at BBFarm.sol(2143)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinorEditsAddr(address a) only_owner() external {
    |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
  at BBFarm.sol(2148)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
    |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
  at BBFarm.sol(2153)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
    |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
  at BBFarm.sol(2158)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setPremiumMultiplier(uint8 m) only_owner() external {
    |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
  at BBFarm.sol(2163)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
    |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
  at BBFarm.sol(2168)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
    |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
  at BBFarm.sol(2173)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
    |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
  at BBFarm.sol(2178)

[31mViolation[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
    |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
  at BBFarm.sol(2183)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[33mWarning[0m for MissingInputValidation in contract 'SVPayments':
    |    /* account management */
    |
  > |    function payForDemocracy(bytes32 democHash) external payable {
    |        require(msg.value > 0, "need to send some ether to make payment");
    |
  at BBFarm.sol(2046)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBFarm.sol(2061)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODReceiver in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBFarm.sol(2061)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SVPayments':
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  > |        _getPayTo().transfer(msg.value);
    |    }
    |
  at BBFarm.sol(2061)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at BBFarm.sol(526)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        }
    |
  > |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
    |        accounts[democHash].lastPaymentTs = now;
    |    }
  at BBFarm.sol(2021)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;
  > |        accounts[democHash].lastPaymentTs = now;
    |    }
    |
  at BBFarm.sol(2022)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            _modAccountBalance(democHash, additionalSeconds);
    |        }
  > |        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));
    |        emit AccountPayment(democHash, additionalSeconds);
    |
  at BBFarm.sol(2058)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(freeExtension[democHash], "!free");
    |        uint newPaidUpTill = now + 60 days;
  > |        accounts[democHash].paidUpTill = newPaidUpTill;
    |        emit FreeExtension(democHash);
    |    }
  at BBFarm.sol(2067)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function downgradeToBasic(bytes32 democHash) only_editors() external {
    |        require(accounts[democHash].isPremium, "!premium");
  > |        accounts[democHash].isPremium = false;
    |        // convert premium minutes to basic
    |        uint paidTill = accounts[democHash].paidUpTill;
  at BBFarm.sol(2073)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");
    |            timeRemaining *= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        emit DowngradeToBasic(democHash);
  at BBFarm.sol(2083)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        require(denyPremium[democHash] == false, "upgrade-denied");
    |        require(!accounts[democHash].isPremium, "!basic");
  > |        accounts[democHash].isPremium = true;
    |        // convert basic minutes to premium minutes
    |        uint paidTill = accounts[democHash].paidUpTill;
  at BBFarm.sol(2091)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (timeRemaining > 0) {
    |            timeRemaining /= premiumMultiplier;
  > |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
    |        accounts[democHash].lastUpgradeTs = now;
  at BBFarm.sol(2098)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |            accounts[democHash].paidUpTill = now + timeRemaining;
    |        }
  > |        accounts[democHash].lastUpgradeTs = now;
    |        emit UpgradedToPremium(democHash);
    |    }
  at BBFarm.sol(2100)

[31mViolation[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {
    |        _modAccountBalance(democHash, additionalSeconds);
  > |        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));
    |        emit GrantedAccountTime(democHash, additionalSeconds, ref);
    |    }
  at BBFarm.sol(2137)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setPayTo(address newPayTo) internal {
  > |        _payTo = newPayTo;
    |    }
    |
  at BBFarm.sol(526)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |    function emergencySetOwner(address newOwner) external {
    |        require(msg.sender == emergencyAdmin, "!emergency-owner");
  > |        owner = newOwner;
    |    }
    |    /* END BREAK GLASS */
  at BBFarm.sol(1995)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinorEditsAddr(address a) only_owner() external {
  > |        minorEditsAddr = a;
    |        emit SetMinorEditsAddr(a);
    |    }
  at BBFarm.sol(2149)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicCentsPricePer30Days(uint amount) only_owner() external {
  > |        basicCentsPricePer30Days = amount;
    |        emit SetBasicCentsPricePer30Days(amount);
    |    }
  at BBFarm.sol(2154)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setBasicBallotsPer30Days(uint amount) only_owner() external {
  > |        basicBallotsPer30Days = amount;
    |        emit SetBallotsPer30Days(amount);
    |    }
  at BBFarm.sol(2159)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setPremiumMultiplier(uint8 m) only_owner() external {
  > |        premiumMultiplier = m;
    |        emit SetPremiumMultiplier(m);
    |    }
  at BBFarm.sol(2164)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {
  > |        weiPerCent = wpc;
    |        emit SetExchangeRate(wpc);
    |    }
  at BBFarm.sol(2169)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {
  > |        freeExtension[democHash] = hasFreeExt;
    |        emit SetFreeExtension(democHash, hasFreeExt);
    |    }
  at BBFarm.sol(2174)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {
  > |        denyPremium[democHash] = isPremiumDenied;
    |        emit SetDenyPremium(democHash, isPremiumDenied);
    |    }
  at BBFarm.sol(2179)

[33mWarning[0m for UnrestrictedWrite in contract 'SVPayments':
    |
    |    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {
  > |        minWeiForDInit = amount;
    |        emit SetMinWeiForDInit(amount);
    |    }
  at BBFarm.sol(2184)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[33mWarning[0m for MissingInputValidation in contract 'hasAdmins':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'hasAdmins':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[31mViolation[0m for MissingInputValidation in contract 'owned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[33mWarning[0m for UnrestrictedWrite in contract 'owned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[31mViolation[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for DAO in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODAmount in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for TODReceiver in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'payoutAllC':
    |        // to be able to send to other contracts, even with no data,
    |        // which might use more than 2300 gas in their fallback function.
  > |        require(toAddr.call.value(amount)(data), "ss-failed");
    |        txMutex3847834 = false;
    |    }
  at BBFarm.sol(505)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
    |        require(txMutex3847834 == false, "ss-guard");
  > |        txMutex3847834 = true;
    |        // we need to use address.call.value(v)() because we want
    |        // to be able to send to other contracts, even with no data,
  at BBFarm.sol(501)

[31mViolation[0m for UnrestrictedWrite in contract 'payoutAllC':
    |        // which might use more than 2300 gas in their fallback function.
    |        require(toAddr.call.value(amount)(data), "ss-failed");
  > |        txMutex3847834 = false;
    |    }
    |}
  at BBFarm.sol(506)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setOwner(address newOwner) only_owner() external {
    |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
  at BBFarm.sol(566)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function isAdmin(address a) view public returns (bool) {
    |        return admins[currAdminEpoch][a];
    |    }
  at BBFarm.sol(645)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function setAdmin(address a, bool _givePerms) only_admin() external {
    |        require(a != msg.sender && a != owner, "cannot change your own (or owner's) permissions");
    |        _setAdmin(a, _givePerms);
  at BBFarm.sol(664)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |
  > |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
    |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
  at BBFarm.sol(758)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(766)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |
    |    // always allow SCs to upgrade themselves, even after lockdown
  > |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
    |        editAllowed[newSC] = true;
  at BBFarm.sol(773)

[31mViolation[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function hasPermissions(address a) public view returns (bool) {
    |        return editAllowed[a];
    |    }
  at BBFarm.sol(779)

[33mWarning[0m for MissingInputValidation in contract 'permissioned':
    |    }
    |
  > |    function upgradeMeAdmin(address newAdmin) only_admin() external {
    |        // note: already checked msg.sender has admin with `only_admin` modifier
    |        require(msg.sender != owner, "owner cannot upgrade self");
  at BBFarm.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {
  > |        editAllowed[e] = _editPerms;
    |        if (_editPerms)
    |            emit PermissionGranted(e);
  at BBFarm.sol(759)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
  > |        editAllowed[oldSC] = false;
    |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
  at BBFarm.sol(767)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {
    |        editAllowed[oldSC] = false;
  > |        editAllowed[newSC] = true;
    |        emit PermissionsUpgraded(oldSC, newSC);
    |    }
  at BBFarm.sol(768)

[31mViolation[0m for UnrestrictedWrite in contract 'permissioned':
    |    function upgradeMe(address newSC) only_editors() external {
    |        editAllowed[msg.sender] = false;
  > |        editAllowed[newSC] = true;
    |        emit SelfUpgrade(msg.sender, newSC);
    |    }
  at BBFarm.sol(775)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |pragma solidity 0.4.24;
    |
  > |contract BBFarmEvents {
    |    event BallotCreatedWithID(uint ballotId);
    |    event BBFarmInit(bytes4 namespace);
  at BBFarm.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function setOwner(address newOwner) only_owner() external {
  > |        owner = newOwner;
    |        emit OwnerChanged(newOwner);
    |    }
  at BBFarm.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |
    |    function _setAdmin(address a, bool _givePerms) internal {
  > |        admins[currAdminEpoch][a] = _givePerms;
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  at BBFarm.sol(670)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |        if (_givePerms) {
    |            emit AdminAdded(a);
  > |            adminLog.push(a);
    |        } else {
    |            emit AdminRemoved(a);
  at BBFarm.sol(673)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // safety feature if admins go bad or something
    |    function incAdminEpoch() only_owner() external {
  > |        currAdminEpoch++;
    |        admins[currAdminEpoch][msg.sender] = true;
    |        emit AdminEpochInc();
  at BBFarm.sol(681)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    // contract.
    |    function disableAdminForever() internal {
  > |        currAdminEpoch++;
    |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
  at BBFarm.sol(689)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function disableAdminForever() internal {
    |        currAdminEpoch++;
  > |        adminsDisabledForever = true;
    |        emit AdminDisabledForever();
    |    }
  at BBFarm.sol(690)

[33mWarning[0m for UnrestrictedWrite in contract 'permissioned':
    |    function doLockdown() external only_owner() no_lockdown() {
    |        disableAdminForever();
  > |        adminLockdown = true;
    |        emit AdminLockdown();
    |    }
  at BBFarm.sol(785)

[FILE] CountTransferManagerFactory.sol
Processing contract: CountTransferManagerFactory.sol:BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CountTransferManagerFactory.sol:CountTransferManager
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CountTransferManagerFactory.sol:CountTransferManagerFactory
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CountTransferManagerFactory.sol:DetailedERC20
Processing contract: CountTransferManagerFactory.sol:ERC20
Processing contract: CountTransferManagerFactory.sol:ERC20Basic
Processing contract: CountTransferManagerFactory.sol:IModule
Processing contract: CountTransferManagerFactory.sol:IModuleFactory
Processing contract: CountTransferManagerFactory.sol:IST20
Processing contract: CountTransferManagerFactory.sol:ISecurityToken
Processing contract: CountTransferManagerFactory.sol:ITransferManager
Processing contract: CountTransferManagerFactory.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CountTransferManagerFactory.sol:Pausable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CountTransferManagerFactory.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CountTransferManagerFactory.sol:StandardToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'BasicToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at CountTransferManagerFactory.sol(139)

[31mViolation[0m for LockedEther in contract 'CountTransferManager':
    | * @title Transfer Manager for limiting maximum number of token holders
    | */
  > |contract CountTransferManager is ITransferManager {
    |
    |    // The maximum number of concurrent token holders
  at CountTransferManagerFactory.sol(663)

[31mViolation[0m for RepeatedCall in contract 'CountTransferManager':
    |     */
    |    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {
  > |        require(polyToken.transferFrom(address(this), IModuleFactory(factory).owner(), _amount), "Unable to take fee");
    |        return true;
    |    }
  at CountTransferManagerFactory.sol(625)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManager':
    |    function _pause() internal {
    |        require(!paused);
  > |        paused = true;
    |        emit Pause(now);
    |    }
  at CountTransferManagerFactory.sol(34)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManager':
    |    function _unpause() internal {
    |        require(paused);
  > |        paused = false;
    |        emit Unpause(now);
    |    }
  at CountTransferManagerFactory.sol(43)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManager':
    |     */
    |    function configure(uint256 _maxHolderCount) public onlyFactory {
  > |        maxHolderCount = _maxHolderCount;
    |    }
    |
  at CountTransferManagerFactory.sol(703)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManager':
    |    function changeHolderCount(uint256 _maxHolderCount) public withPerm(ADMIN) {
    |        emit LogModifyHolderCount(maxHolderCount, _maxHolderCount);
  > |        maxHolderCount = _maxHolderCount;
    |    }
    |
  at CountTransferManagerFactory.sol(719)

[31mViolation[0m for LockedEther in contract 'CountTransferManagerFactory':
    | * @title Factory for deploying CountTransferManager module
    | */
  > |contract CountTransferManagerFactory is IModuleFactory {
    |
    |    /**
  at CountTransferManagerFactory.sol(736)

[31mViolation[0m for MissingInputValidation in contract 'CountTransferManagerFactory':
    |     * @param _newSetupCost new setup cost
    |     */
  > |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
    |        setupCost = _newSetupCost;
  at CountTransferManagerFactory.sol(538)

[31mViolation[0m for MissingInputValidation in contract 'CountTransferManagerFactory':
    |     * @param _newUsageCost new usage cost
    |     */
  > |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
    |        usageCost = _newUsageCost;
  at CountTransferManagerFactory.sol(547)

[31mViolation[0m for MissingInputValidation in contract 'CountTransferManagerFactory':
    |     * @param _newSubscriptionCost new subscription cost
    |     */
  > |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
    |        monthlySubscriptionCost = _newSubscriptionCost;
  at CountTransferManagerFactory.sol(556)

[31mViolation[0m for MissingInputValidation in contract 'CountTransferManagerFactory':
    |     * @return address Contract address of the Module
    |     */
  > |    function deploy(bytes _data) external returns(address) {
    |        if(setupCost > 0)
    |            require(polyToken.transferFrom(msg.sender, owner, setupCost), "Failed transferFrom because of sufficent Allowance is not provided");
  at CountTransferManagerFactory.sol(752)

[31mViolation[0m for UnrestrictedWrite in contract 'CountTransferManagerFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CountTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManagerFactory':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at CountTransferManagerFactory.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManagerFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CountTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManagerFactory':
    |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
  > |        setupCost = _newSetupCost;
    |    }
    |
  at CountTransferManagerFactory.sol(540)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManagerFactory':
    |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
  > |        usageCost = _newUsageCost;
    |    }
    |
  at CountTransferManagerFactory.sol(549)

[33mWarning[0m for UnrestrictedWrite in contract 'CountTransferManagerFactory':
    |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
  > |        monthlySubscriptionCost = _newSubscriptionCost;
    |        
    |    }
  at CountTransferManagerFactory.sol(558)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CountTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at CountTransferManagerFactory.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CountTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at CountTransferManagerFactory.sol(139)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(_value <= allowed[_from][msg.sender]);
    |
  > |    balances[_from] = balances[_from].sub(_value);
    |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  at CountTransferManagerFactory.sol(204)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[_from] = balances[_from].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    |    emit Transfer(_from, _to, _value);
  at CountTransferManagerFactory.sol(205)

[FILE] CvcMigrator.sol
Processing contract: CvcMigrator.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CvcMigrator.sol:CvcMigrator
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CvcMigrator.sol:CvcProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CvcMigrator.sol:ImplementationStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CvcMigrator.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'CvcMigrator':
    |* It allows the ability to add 'upgrade transactions' for multiple proxy contracts and execute all of them in single transaction.
    |*/
  > |contract CvcMigrator is Ownable {
    |
    |    /**
  at CvcMigrator.sol(302)

[31mViolation[0m for RepeatedCall in contract 'CvcMigrator':
    |            Migration storage migration = migrations[i];
    |            if (migration.data.length > 0) {
  > |                CvcProxy(migration.proxy).upgradeToAndCall(migration.implementation, migration.data);
    |            } else {
    |                CvcProxy(migration.proxy).upgradeTo(migration.implementation);
  at CvcMigrator.sol(338)

[31mViolation[0m for RepeatedCall in contract 'CvcMigrator':
    |                CvcProxy(migration.proxy).upgradeToAndCall(migration.implementation, migration.data);
    |            } else {
  > |                CvcProxy(migration.proxy).upgradeTo(migration.implementation);
    |            }
    |        }
  at CvcMigrator.sol(340)

[31mViolation[0m for UnrestrictedWrite in contract 'CvcMigrator':
    |* It allows the ability to add 'upgrade transactions' for multiple proxy contracts and execute all of them in single transaction.
    |*/
  > |contract CvcMigrator is Ownable {
    |
    |    /**
  at CvcMigrator.sol(302)

[33mWarning[0m for UnrestrictedWrite in contract 'CvcMigrator':
    |pragma solidity ^0.4.24;
    |
  > |// File: contracts/upgradeability/ImplementationStorage.sol
    |
    |/**
  at CvcMigrator.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'CvcMigrator':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at CvcMigrator.sol(273)

[33mWarning[0m for UnrestrictedWrite in contract 'CvcMigrator':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CvcMigrator.sol(291)

[33mWarning[0m for UnrestrictedWrite in contract 'CvcMigrator':
    |* It allows the ability to add 'upgrade transactions' for multiple proxy contracts and execute all of them in single transaction.
    |*/
  > |contract CvcMigrator is Ownable {
    |
    |    /**
  at CvcMigrator.sol(302)

[33mWarning[0m for UnrestrictedWrite in contract 'CvcMigrator':
    |        require(AddressUtils.isContract(_implementation), "Migrator error: no contract code at new implementation address");
    |        require(CvcProxy(_proxy).implementation() != _implementation, "Migrator error: proxy contract already uses specified implementation");
  > |        migrations.push(Migration(_proxy, _implementation, _data));
    |    }
    |
  at CvcMigrator.sol(328)

[31mViolation[0m for RepeatedCall in contract 'CvcProxy':
    |
    |            // Call current implementation passing proxy calldata.
  > |            let result := delegatecall(gas, _implementation, 0, calldatasize, 0, 0)
    |
    |            // Copy the returned data.
  at CvcMigrator.sol(184)

[33mWarning[0m for TODAmount in contract 'CvcProxy':
    |        upgradeImplementation(_implementation);
    |        //solium-disable-next-line security/no-call-value
  > |        require(address(this).call.value(msg.value)(_data), "Upgrade error: initialization method call failed");
    |    }
    |
  at CvcMigrator.sol(150)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CvcMigrator.sol(291)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at CvcMigrator.sol(273)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at CvcMigrator.sol(291)

[FILE] CvcProxy.sol
Processing contract: CvcProxy.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CvcProxy.sol:CvcProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: CvcProxy.sol:ImplementationStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for RepeatedCall in contract 'CvcProxy':
    |
    |            // Call current implementation passing proxy calldata.
  > |            let result := delegatecall(gas, _implementation, 0, calldatasize, 0, 0)
    |
    |            // Copy the returned data.
  at CvcProxy.sol(184)

[33mWarning[0m for TODAmount in contract 'CvcProxy':
    |        upgradeImplementation(_implementation);
    |        //solium-disable-next-line security/no-call-value
  > |        require(address(this).call.value(msg.value)(_data), "Upgrade error: initialization method call failed");
    |    }
    |
  at CvcProxy.sol(150)

[FILE] F3DClick.sol
Processing contract: F3DClick.sol:F3DClick
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DClick.sol:F3DClick
Processing contract: F3DClick.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DClick.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DClick.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DClick.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DClick.sol:PlayerBookInterface
Processing contract: F3DClick.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DClick.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DGo.sol
Processing contract: F3DGo.sol:F3DGo
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DGo.sol:F3DGo
Processing contract: F3DGo.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DGo.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DGo.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DGo.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DGo.sol:PlayerBookInterface
Processing contract: F3DGo.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DGo.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DKeysCalcShort.sol
Processing contract: F3DKeysCalcShort.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DKeysCalcShort.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DKeysCalcShort.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DKeysCalcShort.sol:Fomo60Min
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DKeysCalcShort.sol:Fomo60Min
Processing contract: F3DKeysCalcShort.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DKeysCalcShort.sol:PlayerBookInterface
Processing contract: F3DKeysCalcShort.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DKeysCalcShort.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DLink.sol
Processing contract: F3DLink.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DLink.sol:F3DLink
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DLink.sol:F3DLink
Processing contract: F3DLink.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DLink.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DLink.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DLink.sol:PlayerBookInterface
Processing contract: F3DLink.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DLink.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DNEW.sol
Processing contract: F3DNEW.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DNEW.sol:F3DNEW
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DNEW.sol:F3DNEW
Processing contract: F3DNEW.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DNEW.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DNEW.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DNEW.sol:PlayerBookInterface
Processing contract: F3DNEW.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DNEW.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DPLUS.sol
Processing contract: F3DPLUS.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DPLUS.sol:F3DPLUS
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DPLUS.sol:F3DPLUS
Processing contract: F3DPLUS.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DPLUS.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DPLUS.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DPLUS.sol:PlayerBookInterface
Processing contract: F3DPLUS.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DPLUS.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DSHORT.sol
Processing contract: F3DSHORT.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSHORT.sol:F3DSHORT
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DSHORT.sol:F3DSHORT
Processing contract: F3DSHORT.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSHORT.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSHORT.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSHORT.sol:PlayerBookInterface
Processing contract: F3DSHORT.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSHORT.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DSOON.sol
Processing contract: F3DSOON.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSOON.sol:F3DSOON
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DSOON.sol:F3DSOON
Processing contract: F3DSOON.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSOON.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSOON.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSOON.sol:PlayerBookInterface
Processing contract: F3DSOON.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DSOON.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3DShop.sol
Processing contract: F3DShop.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DShop.sol:F3DShop
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3DShop.sol:F3DShop
Processing contract: F3DShop.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DShop.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DShop.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DShop.sol:PlayerBookInterface
Processing contract: F3DShop.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3DShop.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] F3Dultra.sol
Processing contract: F3Dultra.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3Dultra.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3Dultra.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3Dultra.sol:F3Dultra
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: F3Dultra.sol:F3Dultra
Processing contract: F3Dultra.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3Dultra.sol:PlayerBookInterface
Processing contract: F3Dultra.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: F3Dultra.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] FOMO3.sol
Processing contract: FOMO3.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3.sol:FOMO3
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: FOMO3.sol:FOMO3
Processing contract: FOMO3.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3.sol:PlayerBookInterface
Processing contract: FOMO3.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] FOMO3TEST.sol
Processing contract: FOMO3TEST.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST.sol:FOMO3TEST
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: FOMO3TEST.sol:FOMO3TEST
Processing contract: FOMO3TEST.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST.sol:PlayerBookInterface
Processing contract: FOMO3TEST.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] FOMO3TEST1.sol
Processing contract: FOMO3TEST1.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST1.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST1.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST1.sol:FOMO3TEST1
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: FOMO3TEST1.sol:FOMO3TEST1
Processing contract: FOMO3TEST1.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST1.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMO3TEST1.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] FOMOO.sol
Processing contract: FOMOO.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMOO.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMOO.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMOO.sol:FOMOO
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: FOMOO.sol:FOMOO
Processing contract: FOMOO.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMOO.sol:PlayerBookInterface
Processing contract: FOMOO.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FOMOO.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] FoMo100.sol
Processing contract: FoMo100.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FoMo100.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FoMo100.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FoMo100.sol:FoMo100
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: FoMo100.sol:FoMo100
Processing contract: FoMo100.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FoMo100.sol:PlayerBookInterface
Processing contract: FoMo100.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: FoMo100.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] Fomo3DQuick.sol
Processing contract: Fomo3DQuick.sol:DiviesInterface
Processing contract: Fomo3DQuick.sol:F3DKeysCalcQuick
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo3DQuick.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo3DQuick.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo3DQuick.sol:FoMo3Dquick
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: Fomo3DQuick.sol:FoMo3Dquick
Processing contract: Fomo3DQuick.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo3DQuick.sol:PlayerBookInterface
Processing contract: Fomo3DQuick.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo3DQuick.sol:modularQuick
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] Fomo60Min.sol
Processing contract: Fomo60Min.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo60Min.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo60Min.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo60Min.sol:Fomo60Min
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: Fomo60Min.sol:Fomo60Min
Processing contract: Fomo60Min.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo60Min.sol:PlayerBookInterface
Processing contract: Fomo60Min.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Fomo60Min.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] GameOfSwords.sol
Processing contract: GameOfSwords.sol:F3DKeysCalcLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: GameOfSwords.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: GameOfSwords.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: GameOfSwords.sol:GameOfSwords
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: GameOfSwords.sol:GameOfSwords
Processing contract: GameOfSwords.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: GameOfSwords.sol:PlayerBookInterface
Processing contract: GameOfSwords.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: GameOfSwords.sol:modularLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] IcoTokenUpgradeability.sol
Processing contract: IcoTokenUpgradeability.sol:DetailedToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:EternalStorage
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:EternalStorageProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:IcoTokenUpgradeability
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:OwnedUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:Proxy
Processing contract: IcoTokenUpgradeability.sol:UpgradeabilityOwnerStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: IcoTokenUpgradeability.sol:UpgradeabilityStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'DetailedToken':
    |// File: contracts/DetailedToken.sol
    |
  > |contract DetailedToken{
    |	string public name;
    |	string public symbol;
  at IcoTokenUpgradeability.sol(221)

[33mWarning[0m for TODAmount in contract 'EternalStorageProxy':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[33mWarning[0m for TODReceiver in contract 'EternalStorageProxy':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EternalStorageProxy':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[31mViolation[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |    require(_implementation != implementation);
    |    _version = version;
  > |    _implementation = implementation;
    |    emit Upgraded(version, implementation);
    |  }
  at IcoTokenUpgradeability.sol(108)

[31mViolation[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    | * authorization control functionalities
    | */
  > |contract EternalStorageProxy is EternalStorage, OwnedUpgradeabilityProxy {}
    |
    |// File: contracts/DetailedToken.sol
  at IcoTokenUpgradeability.sol(217)

[33mWarning[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    |   */
    |  function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |    _upgradeabilityOwner = newUpgradeabilityOwner;
    |  }
    |}
  at IcoTokenUpgradeability.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'EternalStorageProxy':
    | * authorization control functionalities
    | */
  > |contract EternalStorageProxy is EternalStorage, OwnedUpgradeabilityProxy {}
    |
    |// File: contracts/DetailedToken.sol
  at IcoTokenUpgradeability.sol(217)

[33mWarning[0m for TODAmount in contract 'IcoTokenUpgradeability':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[33mWarning[0m for TODReceiver in contract 'IcoTokenUpgradeability':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'IcoTokenUpgradeability':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[31mViolation[0m for UnrestrictedWrite in contract 'IcoTokenUpgradeability':
    |    require(_implementation != implementation);
    |    _version = version;
  > |    _implementation = implementation;
    |    emit Upgraded(version, implementation);
    |  }
  at IcoTokenUpgradeability.sol(108)

[31mViolation[0m for UnrestrictedWrite in contract 'IcoTokenUpgradeability':
    |
    |
  > |contract IcoTokenUpgradeability is EternalStorageProxy,DetailedToken{
    |	    /*define SafeMath library for uint256*/
    |
  at IcoTokenUpgradeability.sol(297)

[33mWarning[0m for UnrestrictedWrite in contract 'IcoTokenUpgradeability':
    |   */
    |  function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |    _upgradeabilityOwner = newUpgradeabilityOwner;
    |  }
    |}
  at IcoTokenUpgradeability.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'IcoTokenUpgradeability':
    |
    |
  > |contract IcoTokenUpgradeability is EternalStorageProxy,DetailedToken{
    |	    /*define SafeMath library for uint256*/
    |
  at IcoTokenUpgradeability.sol(297)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at IcoTokenUpgradeability.sol(287)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at IcoTokenUpgradeability.sol(269)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at IcoTokenUpgradeability.sol(287)

[33mWarning[0m for TODAmount in contract 'OwnedUpgradeabilityProxy':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[33mWarning[0m for TODReceiver in contract 'OwnedUpgradeabilityProxy':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'OwnedUpgradeabilityProxy':
    |  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
    |    upgradeTo(version, implementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |}
  at IcoTokenUpgradeability.sol(205)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |    require(_implementation != implementation);
    |    _version = version;
  > |    _implementation = implementation;
    |    emit Upgraded(version, implementation);
    |  }
  at IcoTokenUpgradeability.sol(108)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    | * @dev This contract combines an upgradeability proxy with basic authorization control functionalities
    | */
  > |contract OwnedUpgradeabilityProxy is UpgradeabilityOwnerStorage, UpgradeabilityProxy {
    |  /**
    |  * @dev Event to show ownership has been transferred
  at IcoTokenUpgradeability.sol(145)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |   */
    |  function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
  > |    _upgradeabilityOwner = newUpgradeabilityOwner;
    |  }
    |}
  at IcoTokenUpgradeability.sol(135)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    | * @dev This contract combines an upgradeability proxy with basic authorization control functionalities
    | */
  > |contract OwnedUpgradeabilityProxy is UpgradeabilityOwnerStorage, UpgradeabilityProxy {
    |  /**
    |  * @dev Event to show ownership has been transferred
  at IcoTokenUpgradeability.sol(145)

[31mViolation[0m for LockedEther in contract 'UpgradeabilityStorage':
    | * @dev This contract holds all the necessary state variables to support the upgrade functionality
    | */
  > |contract UpgradeabilityStorage {
    |  // Version name of the current implementation
    |  string internal _version;
  at IcoTokenUpgradeability.sol(62)

[FILE] ModuleRegistryProxy.sol
Processing contract: ModuleRegistryProxy.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ModuleRegistryProxy.sol:EternalStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ModuleRegistryProxy.sol:ModuleRegistryProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ModuleRegistryProxy.sol:OwnedUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ModuleRegistryProxy.sol:Proxy
Processing contract: ModuleRegistryProxy.sol:UpgradeabilityProxy
[31mViolation[0m for LockedEther in contract 'EternalStorage':
    |pragma solidity ^0.4.24;
    |
  > |contract EternalStorage {
    |
    |    /// @notice Internal mappings used to store all kinds on data into the contract
  at ModuleRegistryProxy.sol(3)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |        /////////////////////////////
    |
  > |    function getUintValues(bytes32 _variable) public view returns(uint256) {
    |        return uintStorage[_variable];
    |    }
  at ModuleRegistryProxy.sol(239)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getBoolValues(bytes32 _variable) public view returns(bool) {
    |        return boolStorage[_variable];
    |    }
  at ModuleRegistryProxy.sol(243)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getStringValues(bytes32 _variable) public view returns(string) {
    |        return stringStorage[_variable];
    |    }
  at ModuleRegistryProxy.sol(247)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getAddressValues(bytes32 _variable) public view returns(address) {
    |        return addressStorage[_variable];
    |    }
  at ModuleRegistryProxy.sol(251)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getBytes32Values(bytes32 _variable) public view returns(bytes32) {
    |        return bytes32Storage[_variable];
    |    }
  at ModuleRegistryProxy.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getBytesValues(bytes32 _variable) public view returns(bytes) {
    |        return bytesStorage[_variable];
    |    }
  at ModuleRegistryProxy.sol(259)

[31mViolation[0m for RepeatedCall in contract 'ModuleRegistryProxy':
    |            // Call the implementation.
    |            // out and outsize are 0 because we don't know the size yet.
  > |            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |            // Copy the returned data.
  at ModuleRegistryProxy.sol(299)

[33mWarning[0m for TODAmount in contract 'ModuleRegistryProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at ModuleRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'ModuleRegistryProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at ModuleRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedWrite in contract 'ModuleRegistryProxy':
    |        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), "New version equals to current");
    |        __version = _newVersion;
  > |        __implementation = _newImplementation;
    |        emit Upgraded(_newVersion, _newImplementation);
    |    }
  at ModuleRegistryProxy.sol(376)

[33mWarning[0m for UnrestrictedWrite in contract 'ModuleRegistryProxy':
    | */
    |/*solium-disable-next-line no-empty-blocks*/
  > |contract ModuleRegistryProxy is EternalStorage, OwnedUpgradeabilityProxy {
    |
    |}
  at ModuleRegistryProxy.sol(505)

[31mViolation[0m for RepeatedCall in contract 'OwnedUpgradeabilityProxy':
    |            // Call the implementation.
    |            // out and outsize are 0 because we don't know the size yet.
  > |            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |            // Copy the returned data.
  at ModuleRegistryProxy.sol(299)

[33mWarning[0m for TODAmount in contract 'OwnedUpgradeabilityProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at ModuleRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'OwnedUpgradeabilityProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at ModuleRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), "New version equals to current");
    |        __version = _newVersion;
  > |        __implementation = _newImplementation;
    |        emit Upgraded(_newVersion, _newImplementation);
    |    }
  at ModuleRegistryProxy.sol(376)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    | * @dev This contract combines an upgradeability proxy with basic authorization control functionalities
    | */
  > |contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {
    |
    |    // Owner of the contract
  at ModuleRegistryProxy.sol(386)

[FILE] MultiBuyer.sol
Processing contract: MultiBuyer.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiBuyer.sol:ERC20
Processing contract: MultiBuyer.sol:ERC20Basic
Processing contract: MultiBuyer.sol:IBasicMultiToken
Processing contract: MultiBuyer.sol:IMultiToken
Processing contract: MultiBuyer.sol:MultiBuyer
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiBuyer.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiBuyer.sol:SafeERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiBuyer.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at MultiBuyer.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiBuyer.sol(209)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |                data[j - _datasIndexes[i]] = _datas[j];
    |            }
  > |            require(_exchanges[i].call.value(_values[i])(data), "buy: exchange arbitrary call failed");
    |        }
    |
  at MultiBuyer.sol(259)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |        }
    |
  > |        j = _mtkn.totalSupply(); // optimization totalSupply
    |        uint256 bestAmount = uint256(-1);
    |        for (i = _mtkn.tokensCount(); i > 0; i--) {
  at MultiBuyer.sol(262)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |        j = _mtkn.totalSupply(); // optimization totalSupply
    |        uint256 bestAmount = uint256(-1);
  > |        for (i = _mtkn.tokensCount(); i > 0; i--) {
    |            ERC20 token = _mtkn.tokens(i - 1);
    |            token.approve(_mtkn, token.balanceOf(this));
  at MultiBuyer.sol(264)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |        uint256 bestAmount = uint256(-1);
    |        for (i = _mtkn.tokensCount(); i > 0; i--) {
  > |            ERC20 token = _mtkn.tokens(i - 1);
    |            token.approve(_mtkn, token.balanceOf(this));
    |
  at MultiBuyer.sol(265)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |        for (i = _mtkn.tokensCount(); i > 0; i--) {
    |            ERC20 token = _mtkn.tokens(i - 1);
  > |            token.approve(_mtkn, token.balanceOf(this));
    |
    |            uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn));
  at MultiBuyer.sol(266)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |            token.approve(_mtkn, token.balanceOf(this));
    |
  > |            uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn));
    |            if (amount < bestAmount) {
    |                bestAmount = amount;
  at MultiBuyer.sol(268)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |
    |        require(bestAmount >= _minimumReturn, "buy: return value is too low");
  > |        _mtkn.bundle(msg.sender, bestAmount);
    |        if (address(this).balance > 0) {
    |            msg.sender.transfer(address(this).balance);
  at MultiBuyer.sol(275)

[31mViolation[0m for RepeatedCall in contract 'MultiBuyer':
    |        _mtkn.bundle(msg.sender, bestAmount);
    |        if (address(this).balance > 0) {
  > |            msg.sender.transfer(address(this).balance);
    |        }
    |    }
  at MultiBuyer.sol(277)

[31mViolation[0m for TODAmount in contract 'MultiBuyer':
    |        _mtkn.bundle(msg.sender, bestAmount);
    |        if (address(this).balance > 0) {
  > |            msg.sender.transfer(address(this).balance);
    |        }
    |    }
  at MultiBuyer.sol(277)

[33mWarning[0m for TODAmount in contract 'MultiBuyer':
    |                data[j - _datasIndexes[i]] = _datas[j];
    |            }
  > |            require(_exchanges[i].call.value(_values[i])(data), "buy: exchange arbitrary call failed");
    |        }
    |
  at MultiBuyer.sol(259)

[33mWarning[0m for TODReceiver in contract 'MultiBuyer':
    |                data[j - _datasIndexes[i]] = _datas[j];
    |            }
  > |            require(_exchanges[i].call.value(_values[i])(data), "buy: exchange arbitrary call failed");
    |        }
    |
  at MultiBuyer.sol(259)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MultiBuyer':
    |                data[j - _datasIndexes[i]] = _datas[j];
    |            }
  > |            require(_exchanges[i].call.value(_values[i])(data), "buy: exchange arbitrary call failed");
    |        }
    |
  at MultiBuyer.sol(259)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MultiBuyer':
    |        _mtkn.bundle(msg.sender, bestAmount);
    |        if (address(this).balance > 0) {
  > |            msg.sender.transfer(address(this).balance);
    |        }
    |    }
  at MultiBuyer.sol(277)

[33mWarning[0m for UnrestrictedWrite in contract 'MultiBuyer':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at MultiBuyer.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'MultiBuyer':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiBuyer.sol(209)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiBuyer.sol(209)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at MultiBuyer.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiBuyer.sol(209)

[FILE] MultiSeller.sol
Processing contract: MultiSeller.sol:CanReclaimToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiSeller.sol:CheckedERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiSeller.sol:ERC20
Processing contract: MultiSeller.sol:ERC20Basic
Processing contract: MultiSeller.sol:IBasicMultiToken
Processing contract: MultiSeller.sol:IMultiToken
Processing contract: MultiSeller.sol:MultiSeller
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiSeller.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiSeller.sol:SafeERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: MultiSeller.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at MultiSeller.sol(215)

[33mWarning[0m for UnrestrictedWrite in contract 'CanReclaimToken':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiSeller.sol(233)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |        require(_datasIndexes.length == _exchanges.length + 1, "sell: _datasIndexes should start with 0 and end with LENGTH");
    |
  > |        _mtkn.transferFrom(msg.sender, this, _amount);
    |        _mtkn.unbundle(this, _amount);
    |
  at MultiSeller.sol(283)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |
    |        _mtkn.transferFrom(msg.sender, this, _amount);
  > |        _mtkn.unbundle(this, _amount);
    |
    |        for (uint i = 0; i < _exchanges.length; i++) {
  at MultiSeller.sol(284)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |
    |        for (uint i = 0; i < _exchanges.length; i++) {
  > |            ERC20 token = _mtkn.tokens(i);
    |            if (_exchanges[i] == 0) {
    |                token.transfer(msg.sender, token.balanceOf(this));
  at MultiSeller.sol(287)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |            ERC20 token = _mtkn.tokens(i);
    |            if (_exchanges[i] == 0) {
  > |                token.transfer(msg.sender, token.balanceOf(this));
    |                continue;
    |            }
  at MultiSeller.sol(289)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |            }
    |
  > |            token.approve(_exchanges[i], token.balanceOf(this));
    |            require(_exchanges[i].call(data), "sell: exchange arbitrary call failed");
    |        }
  at MultiSeller.sol(298)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |
    |            token.approve(_exchanges[i], token.balanceOf(this));
  > |            require(_exchanges[i].call(data), "sell: exchange arbitrary call failed");
    |        }
    |
  at MultiSeller.sol(299)

[31mViolation[0m for RepeatedCall in contract 'MultiSeller':
    |        }
    |
  > |        msg.sender.transfer(address(this).balance);
    |    }
    |}
  at MultiSeller.sol(302)

[31mViolation[0m for TODAmount in contract 'MultiSeller':
    |        }
    |
  > |        msg.sender.transfer(address(this).balance);
    |    }
    |}
  at MultiSeller.sol(302)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'MultiSeller':
    |        }
    |
  > |        msg.sender.transfer(address(this).balance);
    |    }
    |}
  at MultiSeller.sol(302)

[33mWarning[0m for UnrestrictedWrite in contract 'MultiSeller':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at MultiSeller.sol(215)

[33mWarning[0m for UnrestrictedWrite in contract 'MultiSeller':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiSeller.sol(233)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiSeller.sol(233)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at MultiSeller.sol(215)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at MultiSeller.sol(233)

[FILE] OK3D.sol
Processing contract: OK3D.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OK3D.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OK3D.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OK3D.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OK3D.sol:OK3D
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Decompilation failed.
Error in Securify
java.util.EmptyStackException
	at java.base/java.util.Stack.peek(Stack.java:102)
	at java.base/java.util.Stack.pop(Stack.java:84)
	at ch.securify.decompiler.Variable.takeFromStack(Variable.java:83)
	at ch.securify.decompiler.InstructionFactory.createAndApply(InstructionFactory.java:92)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:165)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:206)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:221)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:243)
	at ch.securify.decompiler.DestackerFallback.decompile(DestackerFallback.java:136)
	at ch.securify.decompiler.DecompilerFallback.decompile(DecompilerFallback.java:73)
	at ch.securify.Main.decompileContract(Main.java:310)
	at ch.securify.Main.processHexFile(Main.java:163)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: OK3D.sol:OK3D
Processing contract: OK3D.sol:PlayerBookInterface
Processing contract: OK3D.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OK3D.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:DataSet
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:Events
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:NumberCompressor
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:OwnedUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:Proxy
Processing contract: OwnedUpgradeabilityProxy.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: OwnedUpgradeabilityProxy.sol:Winner
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for MissingInputValidation in contract 'OwnedUpgradeabilityProxy':
    |    * @param implementation representing the address of the new implementation to be set.
    |    */
  > |    function upgradeTo(address implementation) public onlyProxyOwner {
    |        _upgradeTo(implementation);
    |    }
  at OwnedUpgradeabilityProxy.sol(716)

[33mWarning[0m for MissingInputValidation in contract 'OwnedUpgradeabilityProxy':
    |    * signature of the implementation to be called with the needed payload
    |    */
  > |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
    |        require(address(this).call.value(msg.value)(data), "data is invalid");
  at OwnedUpgradeabilityProxy.sol(727)

[33mWarning[0m for TODAmount in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
  > |        require(address(this).call.value(msg.value)(data), "data is invalid");
    |    }
    |}
  at OwnedUpgradeabilityProxy.sol(729)

[33mWarning[0m for TODReceiver in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
  > |        require(address(this).call.value(msg.value)(data), "data is invalid");
    |    }
    |}
  at OwnedUpgradeabilityProxy.sol(729)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'OwnedUpgradeabilityProxy':
    |    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {
    |        upgradeTo(implementation);
  > |        require(address(this).call.value(msg.value)(data), "data is invalid");
    |    }
    |}
  at OwnedUpgradeabilityProxy.sol(729)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = implementationPosition;
    |        assembly {
  > |            sstore(position, newImplementation)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(635)

[31mViolation[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = proxyOwnerPosition;
    |        assembly {
  > |            sstore(position, newProxyOwner)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(698)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = implementationPosition;
    |        assembly {
  > |            sstore(position, newImplementation)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(635)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        bytes32 position = implementationPosition;
    |        assembly {
  > |            sstore(position, newImplementation)
    |        }
    |    }
  at OwnedUpgradeabilityProxy.sol(635)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |                // assgin bonus to player, and the rest of the pond to platform
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
  > |                _player.transfer(bonus);
    |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
  at OwnedUpgradeabilityProxy.sol(450)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
    |                _player.transfer(bonus);
  > |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
    |                rounds[_roundID].winner = _player;
  at OwnedUpgradeabilityProxy.sol(451)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |        uint256 amount = count.mul(PRICE).mul(REFUND_RATE).div(100);
    |        rounds[curRoundID].pond = rounds[curRoundID].pond.sub(amount);
  > |        _player.transfer(amount);
    |
    |        emit onRefund(msg.sender, block.timestamp, _player, count, amount);
  at OwnedUpgradeabilityProxy.sol(492)

[31mViolation[0m for DAOConstantGas in contract 'Winner':
    |        {
    |            uint256 last = rounds[curRoundID].pond;
  > |            platform.transfer(last);
    |            rounds[curRoundID].pond = 0;
    |
  at OwnedUpgradeabilityProxy.sol(501)

[31mViolation[0m for TODAmount in contract 'Winner':
    |                // assgin bonus to player, and the rest of the pond to platform
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
  > |                _player.transfer(bonus);
    |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
  at OwnedUpgradeabilityProxy.sol(450)

[33mWarning[0m for TODAmount in contract 'Winner':
    |        {
    |            uint256 last = rounds[curRoundID].pond;
  > |            platform.transfer(last);
    |            rounds[curRoundID].pond = 0;
    |
  at OwnedUpgradeabilityProxy.sol(501)

[33mWarning[0m for TODAmount in contract 'Winner':
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
    |                _player.transfer(bonus);
  > |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
    |                rounds[_roundID].winner = _player;
  at OwnedUpgradeabilityProxy.sol(451)

[33mWarning[0m for TODReceiver in contract 'Winner':
    |                // assgin bonus to player, and the rest of the pond to platform
    |                uint256 fund = rounds[_roundID].pond.sub(bonus);
  > |                _player.transfer(bonus);
    |                platform.transfer(fund);
    |                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;
  at OwnedUpgradeabilityProxy.sol(450)

[33mWarning[0m for TODReceiver in contract 'Winner':
    |        uint256 amount = count.mul(PRICE).mul(REFUND_RATE).div(100);
    |        rounds[curRoundID].pond = rounds[curRoundID].pond.sub(amount);
  > |        _player.transfer(amount);
    |
    |        emit onRefund(msg.sender, block.timestamp, _player, count, amount);
  at OwnedUpgradeabilityProxy.sol(492)

[33mWarning[0m for UnrestrictedWrite in contract 'Winner':
    |            drawnRoundID += 1;
    |
  > |            rounds[drawnRoundID].winningNumber = drawNumber();
    |            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;
    |            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;
  at OwnedUpgradeabilityProxy.sol(371)

[33mWarning[0m for UnrestrictedWrite in contract 'Winner':
    |
    |            rounds[drawnRoundID].winningNumber = drawNumber();
  > |            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;
    |            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;
    |
  at OwnedUpgradeabilityProxy.sol(372)

[33mWarning[0m for UnrestrictedWrite in contract 'Winner':
    |            rounds[drawnRoundID].winningNumber = drawNumber();
    |            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;
  > |            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;
    |
    |            emit onDraw(block.timestamp, drawnBlockNumber, drawnRoundID, rounds[drawnRoundID].winningNumber);
  at OwnedUpgradeabilityProxy.sol(373)

[FILE] POHMO.sol
Processing contract: POHMO.sol:KeysCalc
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POHMO.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POHMO.sol:POHMO
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle8306388002089905628/mustExplicit -j 8 -F /tmp/souffle-2a12fe53-4a9d-404f-b96b-afebb0199a8a -D /tmp/souffle-2a12fe53-4a9d-404f-b96b-afebb0199a8a_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: POHMO.sol:POHMO
Processing contract: POHMO.sol:POHMODATASETS
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POHMO.sol:PlayerBookInterface
Processing contract: POHMO.sol:PoHEVENTS
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POHMO.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] POOHMO.sol
Processing contract: POOHMO.sol:KeysCalc
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMO.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMO.sol:POOHMO
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle753428501540199403/mustExplicit -j 8 -F /tmp/souffle-426e35a9-60e7-4149-bda4-54f07bde92a7 -D /tmp/souffle-426e35a9-60e7-4149-bda4-54f07bde92a7_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: POOHMO.sol:POOHMO
Processing contract: POOHMO.sol:POOHMODatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMO.sol:POOHMOevents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMO.sol:PlayerBookInterface
Processing contract: POOHMO.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] POOHMOX.sol
Processing contract: POOHMOX.sol:KeysCalc
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMOX.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMOX.sol:POOHMOX
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle6362599041919060/mustExplicit -j 8 -F /tmp/souffle-7a0f8ff5-c1a9-436c-adb3-8643491f7e8b -D /tmp/souffle-7a0f8ff5-c1a9-436c-adb3-8643491f7e8b_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: POOHMOX.sol:POOHMOX
Processing contract: POOHMOX.sol:POOHMOXDatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMOX.sol:POOHMOXevents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: POOHMOX.sol:PlayerBookInterface
Processing contract: POOHMOX.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] PackagedApp.sol
Processing contract: PackagedApp.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PackagedApp.sol:AdminUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PackagedApp.sol:BaseApp
Processing contract: PackagedApp.sol:ImplementationProvider
Processing contract: PackagedApp.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PackagedApp.sol:Package
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PackagedApp.sol:PackagedApp
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PackagedApp.sol:Proxy
Processing contract: PackagedApp.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PackagedApp.sol:UpgradeabilityProxyFactory
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for RepeatedCall in contract 'AdminUpgradeabilityProxy':
    |      // Call the implementation.
    |      // out and outsize are 0 because we don't know the size yet.
  > |      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |      // Copy the returned data.
  at PackagedApp.sol(56)

[33mWarning[0m for TODAmount in contract 'AdminUpgradeabilityProxy':
    |  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
    |    _upgradeTo(newImplementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |
  at PackagedApp.sol(277)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PackagedApp.sol(426)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PackagedApp.sol(408)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PackagedApp.sol(426)

[33mWarning[0m for MissingInputValidation in contract 'Package':
    |   * @param provider ImplementationProvider associated with the version.
    |   */
  > |  function addVersion(string version, ImplementationProvider provider) public onlyOwner {
    |    require(!hasVersion(version), "Given version is already registered in package");
    |    versions[version] = provider;
  at PackagedApp.sol(579)

[33mWarning[0m for MissingInputValidation in contract 'Package':
    |   * @return Address where the contract is implemented.
    |   */
  > |  function getImplementation(string version, string contractName) public view returns (address) {
    |    ImplementationProvider provider = getVersion(version);
    |    return provider.getImplementation(contractName);
  at PackagedApp.sol(600)

[31mViolation[0m for UnrestrictedWrite in contract 'Package':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PackagedApp.sol(426)

[31mViolation[0m for UnrestrictedWrite in contract 'Package':
    |  function addVersion(string version, ImplementationProvider provider) public onlyOwner {
    |    require(!hasVersion(version), "Given version is already registered in package");
  > |    versions[version] = provider;
    |    emit VersionAdded(version, provider);
    |  }
  at PackagedApp.sol(581)

[33mWarning[0m for UnrestrictedWrite in contract 'Package':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PackagedApp.sol(408)

[33mWarning[0m for UnrestrictedWrite in contract 'Package':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PackagedApp.sol(426)

[33mWarning[0m for LockedEther in contract 'PackagedApp':
    | * This is the standard entry point for an upgradeable app.
    | */
  > |contract PackagedApp is BaseApp {
    |  /// @dev Package that stores the contract implementation addresses.
    |  Package public package;
  at PackagedApp.sol(613)

[31mViolation[0m for RepeatedCall in contract 'PackagedApp':
    |  function create(string contractName) public returns (AdminUpgradeabilityProxy) {
    |    address implementation = getImplementation(contractName);
  > |    return factory.createProxy(this, implementation);
    |  }
    |
  at PackagedApp.sol(472)

[31mViolation[0m for RepeatedCall in contract 'PackagedApp':
    |  function upgrade(AdminUpgradeabilityProxy proxy, string contractName) public onlyOwner {
    |    address implementation = getImplementation(contractName);
  > |    proxy.upgradeTo(implementation);
    |  }
    |
  at PackagedApp.sol(497)

[33mWarning[0m for RepeatedCall in contract 'PackagedApp':
    |   */
    |  function getImplementation(string contractName) public view returns (address) {
  > |    return getProvider().getImplementation(contractName);
    |  }
    |
  at PackagedApp.sol(462)

[33mWarning[0m for RepeatedCall in contract 'PackagedApp':
    |   function createAndCall(string contractName, bytes data) payable public returns (AdminUpgradeabilityProxy) {
    |    address implementation = getImplementation(contractName);
  > |    return factory.createProxyAndCall.value(msg.value)(this, implementation, data);
    |  }
    |
  at PackagedApp.sol(487)

[33mWarning[0m for RepeatedCall in contract 'PackagedApp':
    |  function upgradeAndCall(AdminUpgradeabilityProxy proxy, string contractName, bytes data) payable public onlyOwner {
    |    address implementation = getImplementation(contractName);
  > |    proxy.upgradeToAndCall.value(msg.value)(implementation, data);
    |  }
    |
  at PackagedApp.sol(512)

[33mWarning[0m for TODAmount in contract 'PackagedApp':
    |   function createAndCall(string contractName, bytes data) payable public returns (AdminUpgradeabilityProxy) {
    |    address implementation = getImplementation(contractName);
  > |    return factory.createProxyAndCall.value(msg.value)(this, implementation, data);
    |  }
    |
  at PackagedApp.sol(487)

[33mWarning[0m for TODAmount in contract 'PackagedApp':
    |  function upgradeAndCall(AdminUpgradeabilityProxy proxy, string contractName, bytes data) payable public onlyOwner {
    |    address implementation = getImplementation(contractName);
  > |    proxy.upgradeToAndCall.value(msg.value)(implementation, data);
    |  }
    |
  at PackagedApp.sol(512)

[33mWarning[0m for TODReceiver in contract 'PackagedApp':
    |   function createAndCall(string contractName, bytes data) payable public returns (AdminUpgradeabilityProxy) {
    |    address implementation = getImplementation(contractName);
  > |    return factory.createProxyAndCall.value(msg.value)(this, implementation, data);
    |  }
    |
  at PackagedApp.sol(487)

[33mWarning[0m for TODReceiver in contract 'PackagedApp':
    |  function upgradeAndCall(AdminUpgradeabilityProxy proxy, string contractName, bytes data) payable public onlyOwner {
    |    address implementation = getImplementation(contractName);
  > |    proxy.upgradeToAndCall.value(msg.value)(implementation, data);
    |  }
    |
  at PackagedApp.sol(512)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PackagedApp':
    |   function createAndCall(string contractName, bytes data) payable public returns (AdminUpgradeabilityProxy) {
    |    address implementation = getImplementation(contractName);
  > |    return factory.createProxyAndCall.value(msg.value)(this, implementation, data);
    |  }
    |
  at PackagedApp.sol(487)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PackagedApp':
    |  function upgradeAndCall(AdminUpgradeabilityProxy proxy, string contractName, bytes data) payable public onlyOwner {
    |    address implementation = getImplementation(contractName);
  > |    proxy.upgradeToAndCall.value(msg.value)(implementation, data);
    |  }
    |
  at PackagedApp.sol(512)

[31mViolation[0m for UnrestrictedWrite in contract 'PackagedApp':
    | * This is the standard entry point for an upgradeable app.
    | */
  > |contract PackagedApp is BaseApp {
    |  /// @dev Package that stores the contract implementation addresses.
    |  Package public package;
  at PackagedApp.sol(613)

[33mWarning[0m for UnrestrictedWrite in contract 'PackagedApp':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PackagedApp.sol(408)

[33mWarning[0m for UnrestrictedWrite in contract 'PackagedApp':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PackagedApp.sol(426)

[33mWarning[0m for LockedEther in contract 'UpgradeabilityProxyFactory':
    | * @dev Factory to create upgradeability proxies.
    | */
  > |contract UpgradeabilityProxyFactory {
    |  /**
    |   * @dev Emitted when a new proxy is created.
  at PackagedApp.sol(317)

[31mViolation[0m for MissingInputValidation in contract 'UpgradeabilityProxyFactory':
    |   * @return Address of the new proxy.
    |   */
  > |  function createProxy(address admin, address implementation) public returns (AdminUpgradeabilityProxy) {
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  at PackagedApp.sol(330)

[31mViolation[0m for MissingInputValidation in contract 'UpgradeabilityProxyFactory':
    |   * @return Address of the new proxy.
    |   */
  > |  function createProxyAndCall(address admin, address implementation, bytes data) public payable returns (AdminUpgradeabilityProxy) {
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  at PackagedApp.sol(347)

[33mWarning[0m for TODAmount in contract 'UpgradeabilityProxyFactory':
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  > |    require(address(proxy).call.value(msg.value)(data));
    |    return proxy;
    |  }
  at PackagedApp.sol(350)

[33mWarning[0m for TODReceiver in contract 'UpgradeabilityProxyFactory':
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  > |    require(address(proxy).call.value(msg.value)(data));
    |    return proxy;
    |  }
  at PackagedApp.sol(350)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'UpgradeabilityProxyFactory':
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  > |    require(address(proxy).call.value(msg.value)(data));
    |    return proxy;
    |  }
  at PackagedApp.sol(350)

[FILE] PercentageTransferManagerFactory.sol
Processing contract: PercentageTransferManagerFactory.sol:BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PercentageTransferManagerFactory.sol:DetailedERC20
Processing contract: PercentageTransferManagerFactory.sol:ERC20
Processing contract: PercentageTransferManagerFactory.sol:ERC20Basic
Processing contract: PercentageTransferManagerFactory.sol:IModule
Processing contract: PercentageTransferManagerFactory.sol:IModuleFactory
Processing contract: PercentageTransferManagerFactory.sol:IST20
Processing contract: PercentageTransferManagerFactory.sol:ISecurityToken
Processing contract: PercentageTransferManagerFactory.sol:ITransferManager
Processing contract: PercentageTransferManagerFactory.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PercentageTransferManagerFactory.sol:Pausable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PercentageTransferManagerFactory.sol:PercentageTransferManager
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PercentageTransferManagerFactory.sol:PercentageTransferManagerFactory
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PercentageTransferManagerFactory.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PercentageTransferManagerFactory.sol:StandardToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'BasicToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at PercentageTransferManagerFactory.sol(139)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PercentageTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PercentageTransferManagerFactory.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PercentageTransferManagerFactory.sol(397)

[31mViolation[0m for LockedEther in contract 'PercentageTransferManager':
    | * @title Transfer Manager module for limiting percentage of token supply a single address can hold
    | */
  > |contract PercentageTransferManager is ITransferManager {
    |    using SafeMath for uint256;
    |
  at PercentageTransferManagerFactory.sol(663)

[31mViolation[0m for RepeatedCall in contract 'PercentageTransferManager':
    |    //Allows owner, factory or permissioned delegate
    |    modifier withPerm(bytes32 _perm) {
  > |        bool isOwner = msg.sender == ISecurityToken(securityToken).owner();
    |        bool isFactory = msg.sender == factory;
    |        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), "Permission check failed");
  at PercentageTransferManagerFactory.sol(595)

[31mViolation[0m for RepeatedCall in contract 'PercentageTransferManager':
    |        bool isOwner = msg.sender == ISecurityToken(securityToken).owner();
    |        bool isFactory = msg.sender == factory;
  > |        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), "Permission check failed");
    |        _;
    |    }
  at PercentageTransferManagerFactory.sol(597)

[31mViolation[0m for RepeatedCall in contract 'PercentageTransferManager':
    |     */
    |    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {
  > |        require(polyToken.transferFrom(address(this), IModuleFactory(factory).owner(), _amount), "Unable to take fee");
    |        return true;
    |    }
  at PercentageTransferManagerFactory.sol(625)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManager':
    |    function _pause() internal {
    |        require(!paused);
  > |        paused = true;
    |        emit Pause(now);
    |    }
  at PercentageTransferManagerFactory.sol(34)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManager':
    |    function _unpause() internal {
    |        require(paused);
  > |        paused = false;
    |        emit Unpause(now);
    |    }
  at PercentageTransferManagerFactory.sol(43)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManager':
    |     */
    |    function configure(uint256 _maxHolderPercentage) public onlyFactory {
  > |        maxHolderPercentage = _maxHolderPercentage;
    |    }
    |
  at PercentageTransferManagerFactory.sol(715)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManager':
    |    function changeHolderPercentage(uint256 _maxHolderPercentage) public onlyOwner {
    |        emit LogModifyHolderPercentage(maxHolderPercentage, _maxHolderPercentage);
  > |        maxHolderPercentage = _maxHolderPercentage;
    |    }
    |
  at PercentageTransferManagerFactory.sol(731)

[31mViolation[0m for LockedEther in contract 'PercentageTransferManagerFactory':
    | * @title Factory for deploying PercentageTransferManager module
    | */
  > |contract PercentageTransferManagerFactory is IModuleFactory {
    |
    |    /**
  at PercentageTransferManagerFactory.sol(770)

[31mViolation[0m for MissingInputValidation in contract 'PercentageTransferManagerFactory':
    |     * @param _newSetupCost new setup cost
    |     */
  > |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
    |        setupCost = _newSetupCost;
  at PercentageTransferManagerFactory.sol(538)

[31mViolation[0m for MissingInputValidation in contract 'PercentageTransferManagerFactory':
    |     * @param _newUsageCost new usage cost
    |     */
  > |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
    |        usageCost = _newUsageCost;
  at PercentageTransferManagerFactory.sol(547)

[31mViolation[0m for MissingInputValidation in contract 'PercentageTransferManagerFactory':
    |     * @param _newSubscriptionCost new subscription cost
    |     */
  > |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
    |        monthlySubscriptionCost = _newSubscriptionCost;
  at PercentageTransferManagerFactory.sol(556)

[31mViolation[0m for MissingInputValidation in contract 'PercentageTransferManagerFactory':
    |     * @return address Contract address of the Module
    |     */
  > |    function deploy(bytes _data) external returns(address) {
    |        if(setupCost > 0)
    |            require(polyToken.transferFrom(msg.sender, owner, setupCost), "Failed transferFrom because of sufficent Allowance is not provided");
  at PercentageTransferManagerFactory.sol(787)

[31mViolation[0m for UnrestrictedWrite in contract 'PercentageTransferManagerFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PercentageTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManagerFactory':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PercentageTransferManagerFactory.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManagerFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PercentageTransferManagerFactory.sol(397)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManagerFactory':
    |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
  > |        setupCost = _newSetupCost;
    |    }
    |
  at PercentageTransferManagerFactory.sol(540)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManagerFactory':
    |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
  > |        usageCost = _newUsageCost;
    |    }
    |
  at PercentageTransferManagerFactory.sol(549)

[33mWarning[0m for UnrestrictedWrite in contract 'PercentageTransferManagerFactory':
    |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
  > |        monthlySubscriptionCost = _newSubscriptionCost;
    |        
    |    }
  at PercentageTransferManagerFactory.sol(558)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at PercentageTransferManagerFactory.sol(139)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(_value <= allowed[_from][msg.sender]);
    |
  > |    balances[_from] = balances[_from].sub(_value);
    |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  at PercentageTransferManagerFactory.sol(204)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[_from] = balances[_from].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    |    emit Transfer(_from, _to, _value);
  at PercentageTransferManagerFactory.sol(205)

[FILE] PlayCoinKey.sol
Processing contract: PlayCoinKey.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PlayCoinKey.sol:PCKExtSettingInterface
Processing contract: PlayCoinKey.sol:PCKKeysCalcLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PlayCoinKey.sol:PCKdatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PlayCoinKey.sol:PCKevents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PlayCoinKey.sol:PlayCoinGodInterface
Processing contract: PlayCoinKey.sol:PlayCoinKey
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle1013719272197281103/mustExplicit -j 8 -F /tmp/souffle-02dc87b1-ced5-4224-b2ab-7dfee24fccdb -D /tmp/souffle-02dc87b1-ced5-4224-b2ab-7dfee24fccdb_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: PlayCoinKey.sol:PlayCoinKey
Processing contract: PlayCoinKey.sol:PlayerBookInterface
Processing contract: PlayCoinKey.sol:ProForwarderInterface
Processing contract: PlayCoinKey.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PlayCoinKey.sol:modularKey
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PlayCoinKey.sol:otherPCK
[FILE] PoHMO4D.sol
Processing contract: PoHMO4D.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoHMO4D.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoHMO4D.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoHMO4D.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoHMO4D.sol:PlayerBookInterface
Processing contract: PoHMO4D.sol:PoHMO4D
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle11527195504896237237/mustExplicit -j 8 -F /tmp/souffle-f7f04710-43e3-4920-8328-92e3c0e9e3c8 -D /tmp/souffle-f7f04710-43e3-4920-8328-92e3c0e9e3c8_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: PoHMO4D.sol:PoHMO4D
Processing contract: PoHMO4D.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoHMO4D.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] PoaCrowdsale.sol
Processing contract: PoaCrowdsale.sol:PoaCommon
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaCrowdsale.sol:PoaCrowdsale
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle2357821987771785161/mustExplicit -j 8 -F /tmp/souffle-317354da-66fe-4a24-aee2-53ebbad38a5f -D /tmp/souffle-317354da-66fe-4a24-aee2-53ebbad38a5f_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: PoaCrowdsale.sol:PoaCrowdsale
Processing contract: PoaCrowdsale.sol:PoaProxyCommon
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaCrowdsale.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaCrowdsale.sol:SafeMathPower
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'PoaCommon':
    |  upon storage slots for getting & setting PoaProxy related storage.
    |*/
  > |contract PoaCommon is PoaProxyCommon {
    |  using SafeMath for uint256;
    |  using SafeMathPower for uint256;
  at PoaCrowdsale.sol(204)

[FILE] PoaManager.sol
Processing contract: PoaManager.sol:IPoaCrowdsale
Processing contract: PoaManager.sol:IPoaToken
Processing contract: PoaManager.sol:IRegistry
Processing contract: PoaManager.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaManager.sol:PoaManager
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaManager.sol:PoaProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaManager.sol:PoaProxyCommon
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaManager.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PoaManager.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PoaManager.sol(45)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PoaManager.sol(63)

[31mViolation[0m for LockedEther in contract 'PoaManager':
    |// File: contracts/PoaManager.sol
    |
  > |contract PoaManager is Ownable {
    |  using SafeMath for uint256;
    |
  at PoaManager.sol(446)

[31mViolation[0m for RepeatedCall in contract 'PoaManager':
    |    returns (address _proxyContract)
    |  {
  > |    address _poaTokenMaster = registry.getContractAddress("PoaTokenMaster");
    |    address _poaCrowdsaleMaster = registry.getContractAddress("PoaCrowdsaleMaster");
    |    _proxyContract = new PoaProxy(_poaTokenMaster, _poaCrowdsaleMaster, address(registry));
  at PoaManager.sol(658)

[31mViolation[0m for RepeatedCall in contract 'PoaManager':
    |  {
    |    address _poaTokenMaster = registry.getContractAddress("PoaTokenMaster");
  > |    address _poaCrowdsaleMaster = registry.getContractAddress("PoaCrowdsaleMaster");
    |    _proxyContract = new PoaProxy(_poaTokenMaster, _poaCrowdsaleMaster, address(registry));
    |  }
  at PoaManager.sol(659)

[31mViolation[0m for RepeatedCall in contract 'PoaManager':
    |    address _tokenAddress = createPoaTokenProxy();
    |
  > |    IPoaToken(_tokenAddress).initializeToken(
    |      _name32,
    |      _symbol32,
  at PoaManager.sol(691)

[31mViolation[0m for RepeatedCall in contract 'PoaManager':
    |    );
    |
  > |    IPoaCrowdsale(_tokenAddress).initializeCrowdsale(
    |      _fiatCurrency32,
    |      _startTimeForFundingPeriod,
  at PoaManager.sol(700)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |// File: contracts/PoaManager.sol
    |
  > |contract PoaManager is Ownable {
    |  using SafeMath for uint256;
    |
  at PoaManager.sol(446)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |pragma solidity 0.4.24;
    |
  > |// File: openzeppelin-solidity/contracts/ownership/Ownable.sol
    |
    |/**
  at PoaManager.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PoaManager.sol(45)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PoaManager.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |    returns (EntityState)
    |  {
  > |    entityList.push(_entityAddress);
    |    // we do not offset by `-1` so that we never have `entity.index = 0` as this is what is
    |    // used to check for existence in modifier [doesEntityExist]
  at PoaManager.sol(515)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |    isNewBroker(_brokerAddress)
    |  {
  > |    brokerMap[_brokerAddress] = addEntity(
    |      _brokerAddress,
    |      brokerAddressList,
  at PoaManager.sol(576)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaManager':
    |    );
    |
  > |    tokenMap[_tokenAddress] = addEntity(
    |      _tokenAddress,
    |      tokenAddressList,
  at PoaManager.sol(709)

[33mWarning[0m for MissingInputValidation in contract 'PoaProxy':
    |
    |  /// @notice Update the stored "poaTokenMaster" address to upgrade the PoaToken master contract
  > |  function proxyChangeTokenMaster(address _newMaster)
    |    public
    |    returns (bool)
  at PoaManager.sol(346)

[33mWarning[0m for MissingInputValidation in contract 'PoaProxy':
    |
    |  /// @notice Update the stored `poaCrowdsaleMaster` address to upgrade the PoaCrowdsale master contract
  > |  function proxyChangeCrowdsaleMaster(address _newMaster)
    |    public
    |    returns (bool)
  at PoaManager.sol(367)

[33mWarning[0m for TODAmount in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(358)

[33mWarning[0m for TODAmount in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(379)

[33mWarning[0m for TODReceiver in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(358)

[33mWarning[0m for TODReceiver in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(379)

[31mViolation[0m for UnhandledException in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(358)

[31mViolation[0m for UnhandledException in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(379)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(358)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PoaProxy':
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  > |    getContractAddress("PoaLogger").call(
    |      bytes4(keccak256("logProxyUpgraded(address,address)")),
    |      _oldMaster, _newMaster
  at PoaManager.sol(379)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaProxy':
    |    require(isContract(_newMaster));
    |    address _oldMaster = poaTokenMaster;
  > |    poaTokenMaster = _newMaster;
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  at PoaManager.sol(355)

[33mWarning[0m for UnrestrictedWrite in contract 'PoaProxy':
    |    require(isContract(_newMaster));
    |    address _oldMaster = poaCrowdsaleMaster;
  > |    poaCrowdsaleMaster = _newMaster;
    |
    |    emit ProxyUpgraded(_oldMaster, _newMaster);
  at PoaManager.sol(376)

[FILE] PoaToken.sol
Processing contract: PoaToken.sol:BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaToken.sol:ERC20
Processing contract: PoaToken.sol:ERC20Basic
Processing contract: PoaToken.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaToken.sol:PoaCommon
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaToken.sol:PoaProxyCommon
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaToken.sol:PoaToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle15160663824532191307/mustExplicit -j 8 -F /tmp/souffle-f335768b-b3d3-4b00-84f0-2ffa6df39bab -D /tmp/souffle-f335768b-b3d3-4b00-84f0-2ffa6df39bab_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: PoaToken.sol:PoaToken
Processing contract: PoaToken.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaToken.sol:SafeMathPower
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PoaToken.sol:StandardToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for UnrestrictedWrite in contract 'BasicToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at PoaToken.sol(99)

[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PoaToken.sol(317)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at PoaToken.sol(299)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at PoaToken.sol(317)

[31mViolation[0m for LockedEther in contract 'PoaCommon':
    |  upon storage slots for getting & setting PoaProxy related storage.
    |*/
  > |contract PoaCommon is PoaProxyCommon {
    |  using SafeMath for uint256;
    |  using SafeMathPower for uint256;
  at PoaToken.sol(470)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[msg.sender] = balances[msg.sender].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at PoaToken.sol(99)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(_value <= allowed[_from][msg.sender]);
    |
  > |    balances[_from] = balances[_from].sub(_value);
    |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  at PoaToken.sol(168)

[33mWarning[0m for UnrestrictedWrite in contract 'StandardToken':
    |
    |    balances[_from] = balances[_from].sub(_value);
  > |    balances[_to] = balances[_to].add(_value);
    |    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    |    emit Transfer(_from, _to, _value);
  at PoaToken.sol(169)

[FILE] PonziPwn.sol
Processing contract: PonziPwn.sol:AirDropWinner
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PonziPwn.sol:BlankContract
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PonziPwn.sol:GameOfSwordsInterface
Processing contract: PonziPwn.sol:PonziPwn
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for TODAmount in contract 'PonziPwn':
    |    //allows withdrawal of funds after selfdestructing of a child contract which return funds to this contract
    |    function withdraw() public onlyAdmin() {
  > |        admin.transfer(address(this).balance);
    |    }
    |}
  at PonziPwn.sol(128)

[33mWarning[0m for TODAmount in contract 'PonziPwn':
    |        uint256 _pwnCost = 0;
    |        uint256 _seed = 0;
  > |        uint256 _tracker = fomo3d.airDropTracker_();
    |        bool _canWin = false;
    |        while(!_canWin) {
  at PonziPwn.sol(68)

[33mWarning[0m for TODAmount in contract 'PonziPwn':
    |        for(uint256 _i; _i < _nContracts; _i++) {
    |            if(_i++ == _nContracts) {
  > |               address(_newSender).call.value(0.1 ether)();
    |               new AirDropWinner();
    |            }
  at PonziPwn.sol(106)

[33mWarning[0m for TODReceiver in contract 'PonziPwn':
    |        uint256 _pwnCost = 0;
    |        uint256 _seed = 0;
  > |        uint256 _tracker = fomo3d.airDropTracker_();
    |        bool _canWin = false;
    |        while(!_canWin) {
  at PonziPwn.sol(68)

[33mWarning[0m for TODReceiver in contract 'PonziPwn':
    |        for(uint256 _i; _i < _nContracts; _i++) {
    |            if(_i++ == _nContracts) {
  > |               address(_newSender).call.value(0.1 ether)();
    |               new AirDropWinner();
    |            }
  at PonziPwn.sol(106)

[31mViolation[0m for UnhandledException in contract 'PonziPwn':
    |        for(uint256 _i; _i < _nContracts; _i++) {
    |            if(_i++ == _nContracts) {
  > |               address(_newSender).call.value(0.1 ether)();
    |               new AirDropWinner();
    |            }
  at PonziPwn.sol(106)

[31mViolation[0m for UnrestrictedEtherFlow in contract 'PonziPwn':
    |        for(uint256 _i; _i < _nContracts; _i++) {
    |            if(_i++ == _nContracts) {
  > |               address(_newSender).call.value(0.1 ether)();
    |               new AirDropWinner();
    |            }
  at PonziPwn.sol(106)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PonziPwn':
    |        uint256 _pwnCost = 0;
    |        uint256 _seed = 0;
  > |        uint256 _tracker = fomo3d.airDropTracker_();
    |        bool _canWin = false;
    |        while(!_canWin) {
  at PonziPwn.sol(68)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PonziPwn':
    |        for(uint256 _i; _i < _nContracts; _i++) {
    |            if(_i++ == _nContracts) {
  > |               address(_newSender).call.value(0.1 ether)();
    |               new AirDropWinner();
    |            }
  at PonziPwn.sol(106)

[FILE] PwnFoMo3D.sol
Processing contract: PwnFoMo3D.sol:FoMo3DlongInterface
Processing contract: PwnFoMo3D.sol:Owned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: PwnFoMo3D.sol:PwnFoMo3D
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for MissingInputValidation in contract 'Owned':
    |    }
    |
  > |    function transferOwnership(address _newOwner) public onlyOwner {
    |        newOwner = _newOwner;
    |    }
  at PwnFoMo3D.sol(32)

[33mWarning[0m for UnrestrictedWrite in contract 'Owned':
    |
    |    function transferOwnership(address _newOwner) public onlyOwner {
  > |        newOwner = _newOwner;
    |    }
    |    
  at PwnFoMo3D.sol(33)

[33mWarning[0m for UnrestrictedWrite in contract 'Owned':
    |        require(msg.sender == newOwner);
    |        emit OwnershipTransferred(owner, newOwner);
  > |        owner = newOwner;
    |        newOwner = address(0);
    |    }
  at PwnFoMo3D.sol(39)

[33mWarning[0m for UnrestrictedWrite in contract 'Owned':
    |        emit OwnershipTransferred(owner, newOwner);
    |        owner = newOwner;
  > |        newOwner = address(0);
    |    }
    |}
  at PwnFoMo3D.sol(40)

[31mViolation[0m for MissingInputValidation in contract 'PwnFoMo3D':
    |    }
    |
  > |    function transferOwnership(address _newOwner) public onlyOwner {
    |        newOwner = _newOwner;
    |    }
  at PwnFoMo3D.sol(32)

[31mViolation[0m for MissingInputValidation in contract 'PwnFoMo3D':
    |  }
    |  
  > |    function withdrawOwner(uint256 a)  public onlyOwner {
    |        msg.sender.transfer(a);    
    |    }
  at PwnFoMo3D.sol(62)

[31mViolation[0m for UnhandledException in contract 'PwnFoMo3D':
    |    }
    |
  > |    address(fomo3d).call.value( fomo3d.getBuyPrice() *2 )();
    |    
    |    fomo3d.withdraw();
  at PwnFoMo3D.sol(57)

[31mViolation[0m for UnrestrictedEtherFlow in contract 'PwnFoMo3D':
    |    }
    |
  > |    address(fomo3d).call.value( fomo3d.getBuyPrice() *2 )();
    |    
    |    fomo3d.withdraw();
  at PwnFoMo3D.sol(57)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'PwnFoMo3D':
    |  
    |    function withdrawOwner(uint256 a)  public onlyOwner {
  > |        msg.sender.transfer(a);    
    |    }
    |}
  at PwnFoMo3D.sol(63)

[33mWarning[0m for UnrestrictedWrite in contract 'PwnFoMo3D':
    |
    |    function transferOwnership(address _newOwner) public onlyOwner {
  > |        newOwner = _newOwner;
    |    }
    |    
  at PwnFoMo3D.sol(33)

[33mWarning[0m for UnrestrictedWrite in contract 'PwnFoMo3D':
    |        require(msg.sender == newOwner);
    |        emit OwnershipTransferred(owner, newOwner);
  > |        owner = newOwner;
    |        newOwner = address(0);
    |    }
  at PwnFoMo3D.sol(39)

[33mWarning[0m for UnrestrictedWrite in contract 'PwnFoMo3D':
    |        emit OwnershipTransferred(owner, newOwner);
    |        owner = newOwner;
  > |        newOwner = address(0);
    |    }
    |}
  at PwnFoMo3D.sol(40)

[FILE] RatScam.sol
Processing contract: RatScam.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RatScam.sol:RSEvents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RatScam.sol:RSKeysCalc
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RatScam.sol:RSdatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RatScam.sol:RatBookInterface
Processing contract: RatScam.sol:RatInterfaceForForwarder
Processing contract: RatScam.sol:RatScam
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle6676428525964639620/mustExplicit -j 8 -F /tmp/souffle-63f2fe6e-fdc9-4e29-ae00-0c4a1513739e -D /tmp/souffle-63f2fe6e-fdc9-4e29-ae00-0c4a1513739e_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: RatScam.sol:RatScam
Processing contract: RatScam.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: RatScam.sol:modularRatScam
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] Sale1.sol
Processing contract: Sale1.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:ContractReceiver
Processing contract: Sale1.sol:ERC165
Processing contract: Sale1.sol:ERC721
Processing contract: Sale1.sol:ERC721Basic
Processing contract: Sale1.sol:ERC721BasicToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:ERC721Enumerable
Processing contract: Sale1.sol:ERC721Metadata
Processing contract: Sale1.sol:ERC721Token
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:RUNEToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:SafeMath2
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:Sale1
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:SupportsInterfaceWithLookup
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:THORChain721
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:THORChain721Receiver
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: Sale1.sol:Whitelist
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'ERC721Token':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {
    |
    |  // Token name
  at Sale1.sol(885)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC721Token':
    | * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
    | */
  > |contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {
    |
    |  // Token name
  at Sale1.sol(885)

[33mWarning[0m for LockedEther in contract 'RUNEToken':
    |
    |
  > |contract RUNEToken is SafeMath2
    |{
    |    
  at Sale1.sol(49)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC20
  > |    function balanceOf( address owner ) public constant returns (uint) {
    |        return balances_[owner];
    |    }
  at Sale1.sol(81)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC20
  > |    function approve( address spender, uint256 value ) public
    |    returns (bool success)
    |    {
  at Sale1.sol(86)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |    
    |    // recommended fix for known attack on any ERC20
  > |    function safeApprove( address _spender,
    |                            uint256 _currentValue,
    |                            uint256 _value ) public
  at Sale1.sol(95)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC20
  > |    function allowance( address owner, address spender ) public constant
    |    returns (uint256 remaining)
    |    {
  at Sale1.sol(110)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC20
  > |    function transferFrom( address from, address to, uint256 value ) public
    |    returns (bool success)
    |    {
  at Sale1.sol(125)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC223 Transfer and invoke specified callback
  > |    function transfer( address to,
    |                        uint value,
    |                        bytes data,
  at Sale1.sol(138)

[31mViolation[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // Ethereum Token
  > |    function burnFrom( address from, uint256 value ) public
    |    returns (bool success)
    |    {
  at Sale1.sol(224)

[33mWarning[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC20
  > |    function transfer(address to, uint256 value) public returns (bool success)
    |    {
    |        bytes memory empty; // null
  at Sale1.sol(117)

[33mWarning[0m for MissingInputValidation in contract 'RUNEToken':
    |
    |    // ERC223 Transfer to a contract or externally-owned account
  > |    function transfer( address to, uint value, bytes data ) public
    |    returns (bool success)
    |    {
  at Sale1.sol(158)

[33mWarning[0m for TODAmount in contract 'RUNEToken':
    |
    |        ContractReceiver rx = ContractReceiver(to);
  > |        rx.tokenFallback( msg.sender, value, data );
    |
    |        return true;
  at Sale1.sol(176)

[33mWarning[0m for TODReceiver in contract 'RUNEToken':
    |
    |        ContractReceiver rx = ContractReceiver(to);
  > |        rx.tokenFallback( msg.sender, value, data );
    |
    |        return true;
  at Sale1.sol(176)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'RUNEToken':
    |
    |        ContractReceiver rx = ContractReceiver(to);
  > |        rx.tokenFallback( msg.sender, value, data );
    |
    |        return true;
  at Sale1.sol(176)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |        require( balances_[to] + value > balances_[to] ); // catch overflow
    |
  > |        balances_[from] -= value;
    |        balances_[to] += value;
    |
  at Sale1.sol(198)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |
    |        balances_[from] -= value;
  > |        balances_[to] += value;
    |
    |        //Transfer( from, to, value, data ); ERC223-compat version
  at Sale1.sol(199)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |        require( balances_[msg.sender] >= value );
    |        balances_[msg.sender] -= value;
  > |        totalSupply -= value;
    |
    |        emit Burn( msg.sender, value );
  at Sale1.sol(217)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |        require( value <= allowances_[from][msg.sender] );
    |
  > |        balances_[from] -= value;
    |        allowances_[from][msg.sender] -= value;
    |        totalSupply -= value;
  at Sale1.sol(230)

[31mViolation[0m for UnrestrictedWrite in contract 'RUNEToken':
    |        balances_[from] -= value;
    |        allowances_[from][msg.sender] -= value;
  > |        totalSupply -= value;
    |
    |        emit Burn( from, value );
  at Sale1.sol(232)

[33mWarning[0m for UnrestrictedWrite in contract 'RUNEToken':
    |        require( balances_[to] + value > balances_[to] ); // catch overflow
    |
  > |        balances_[from] -= value;
    |        balances_[to] += value;
    |
  at Sale1.sol(198)

[33mWarning[0m for UnrestrictedWrite in contract 'RUNEToken':
    |
    |        balances_[from] -= value;
  > |        balances_[to] += value;
    |
    |        //Transfer( from, to, value, data ); ERC223-compat version
  at Sale1.sol(199)

[33mWarning[0m for RepeatedCall in contract 'Sale1':
    |        if(collectibleAllocation[CollectibleIndex2] == _receiver) {
    |            delete collectibleAllocation[CollectibleIndex2];
  > |            ERC721Token.safeTransferFrom(owner, _receiver, CollectibleIndex2);
    |        } 
    |        if(collectibleAllocation[CollectibleIndex3] == _receiver) {
  at Sale1.sol(1309)

[33mWarning[0m for RepeatedCall in contract 'Sale1':
    |        if(collectibleAllocation[CollectibleIndex3] == _receiver) {
    |            delete collectibleAllocation[CollectibleIndex3];
  > |            ERC721Token.safeTransferFrom(owner, _receiver, CollectibleIndex3);
    |        } 
    |        if(collectibleAllocation[CollectibleIndex4] == _receiver) {
  at Sale1.sol(1313)

[33mWarning[0m for RepeatedCall in contract 'Sale1':
    |        if(collectibleAllocation[CollectibleIndex4] == _receiver) {
    |            delete collectibleAllocation[CollectibleIndex4];
  > |            ERC721Token.safeTransferFrom(owner, _receiver, CollectibleIndex4);
    |        } 
    |        if(collectibleAllocation[CollectibleIndex5] == _receiver) {
  at Sale1.sol(1317)

[33mWarning[0m for TODAmount in contract 'Sale1':
    |        totalRunePurchased = totalRunePurchased.add(purchaseAmount);
    |        // Withdraw  ETH 
  > |        proceedsAddress.transfer(toForward);
    |        if(weiToReturn > 0) {
    |            address(msg.sender).transfer(weiToReturn);
  at Sale1.sol(1254)

[33mWarning[0m for TODAmount in contract 'Sale1':
    |        proceedsAddress.transfer(toForward);
    |        if(weiToReturn > 0) {
  > |            address(msg.sender).transfer(weiToReturn);
    |        }
    |    }
  at Sale1.sol(1256)

[33mWarning[0m for TODReceiver in contract 'Sale1':
    |        totalRunePurchased = totalRunePurchased.add(purchaseAmount);
    |        // Withdraw  ETH 
  > |        proceedsAddress.transfer(toForward);
    |        if(weiToReturn > 0) {
    |            address(msg.sender).transfer(weiToReturn);
  at Sale1.sol(1254)

[31mViolation[0m for UnrestrictedWrite in contract 'Sale1':
    |
    |    function whitelistAddress(address _user) public onlyWhitelistAdmin  {
  > |        whitelist[_user] = true;
    |    }
    |
  at Sale1.sol(1144)

[31mViolation[0m for UnrestrictedWrite in contract 'Sale1':
    |
    |    function unWhitelistAddress(address _user) public onlyWhitelistAdmin  {
  > |        whitelist[_user] = false;
    |    }
    |
  at Sale1.sol(1154)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |    function whitelistAddresses(address[] _users) public onlyWhitelistAdmin {
    |        for (uint256 i = 0; i < _users.length; i++) {
  > |            whitelist[_users[i]] = true;
    |        }
    |    }
  at Sale1.sol(1149)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |    function unWhitelistAddresses(address[] _users) public onlyWhitelistAdmin {
    |        for (uint256 i = 0; i < _users.length; i++) {
  > |            whitelist[_users[i]] = false;
    |        }
    |    }
  at Sale1.sol(1159)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |
    |    function addWhitelistAdmin(address _admin) public onlyOwner {
  > |        whitelistAdmins[_admin] = true;
    |    }
    |
  at Sale1.sol(1135)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |    function removeWhitelistAdmin(address _admin) public onlyOwner {
    |        require(_admin != owner, "Cannot remove contract owner");
  > |        whitelistAdmins[_admin] = false;
    |    }
    |
  at Sale1.sol(1140)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |
    |    function setMaximumNonWhitelistAmount (uint256 _newAmount) public onlyOwner {
  > |        maximumNonWhitelistAmount = _newAmount;
    |    }
    |
  at Sale1.sol(1261)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |
    |    function ownerWithdrawRune () public onlyOwner {
  > |        tokensWithdrawn = true;
    |        RuneToken.transfer(owner, RuneToken.balanceOf(this).sub(totalRunePurchased));
    |    }
  at Sale1.sol(1282)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |
    |    function allowWithdrawals () public onlyOwner {
  > |        withdrawalsAllowed = true;
    |    }
    |
  at Sale1.sol(1287)

[33mWarning[0m for UnrestrictedWrite in contract 'Sale1':
    |        require(runeAllocation[_receiver] > 0, "Receiver has not purchased any RUNE.");
    |        uint balance = runeAllocation[_receiver];
  > |        delete runeAllocation[_receiver];
    |        RuneToken.transfer(_receiver, balance);
    |        distributeCollectiblesTo(_receiver);
  at Sale1.sol(1293)

[31mViolation[0m for MissingInputValidation in contract 'SupportsInterfaceWithLookup':
    |   * @dev implement supportsInterface(bytes4) using a lookup table
    |   */
  > |  function supportsInterface(bytes4 _interfaceId)
    |    external
    |    view
  at Sale1.sol(295)

[31mViolation[0m for LockedEther in contract 'THORChain721':
    |}
    |
  > |contract THORChain721 is ERC721Token {
    |    
    |    address public owner;
  at Sale1.sol(1074)

[33mWarning[0m for UnrestrictedWrite in contract 'THORChain721':
    |}
    |
  > |contract THORChain721 is ERC721Token {
    |    
    |    address public owner;
  at Sale1.sol(1074)

[31mViolation[0m for MissingInputValidation in contract 'THORChain721Receiver':
    |  );
    |
  > |  function onERC721Received(
    |    address _operator,
    |    address _from,
  at Sale1.sol(417)

[31mViolation[0m for MissingInputValidation in contract 'Whitelist':
    |
    |    address public owner;
  > |    mapping(address => bool) public whitelistAdmins;
    |    mapping(address => bool) public whitelist;
    |
  at Sale1.sol(1112)

[31mViolation[0m for MissingInputValidation in contract 'Whitelist':
    |    address public owner;
    |    mapping(address => bool) public whitelistAdmins;
  > |    mapping(address => bool) public whitelist;
    |
    |    constructor () public {
  at Sale1.sol(1113)

[31mViolation[0m for MissingInputValidation in contract 'Whitelist':
    |    }
    |
  > |    function isWhitelisted(address _addr) public view returns (bool) {
    |        return whitelist[_addr];
    |    }
  at Sale1.sol(1130)

[31mViolation[0m for MissingInputValidation in contract 'Whitelist':
    |    }
    |
  > |    function addWhitelistAdmin(address _admin) public onlyOwner {
    |        whitelistAdmins[_admin] = true;
    |    }
  at Sale1.sol(1134)

[31mViolation[0m for MissingInputValidation in contract 'Whitelist':
    |    }
    |
  > |    function whitelistAddress(address _user) public onlyWhitelistAdmin  {
    |        whitelist[_user] = true;
    |    }
  at Sale1.sol(1143)

[31mViolation[0m for MissingInputValidation in contract 'Whitelist':
    |    }
    |
  > |    function unWhitelistAddress(address _user) public onlyWhitelistAdmin  {
    |        whitelist[_user] = false;
    |    }
  at Sale1.sol(1153)

[31mViolation[0m for UnrestrictedWrite in contract 'Whitelist':
    |
    |    function whitelistAddress(address _user) public onlyWhitelistAdmin  {
  > |        whitelist[_user] = true;
    |    }
    |
  at Sale1.sol(1144)

[31mViolation[0m for UnrestrictedWrite in contract 'Whitelist':
    |
    |    function unWhitelistAddress(address _user) public onlyWhitelistAdmin  {
  > |        whitelist[_user] = false;
    |    }
    |
  at Sale1.sol(1154)

[33mWarning[0m for UnrestrictedWrite in contract 'Whitelist':
    |    function whitelistAddresses(address[] _users) public onlyWhitelistAdmin {
    |        for (uint256 i = 0; i < _users.length; i++) {
  > |            whitelist[_users[i]] = true;
    |        }
    |    }
  at Sale1.sol(1149)

[33mWarning[0m for UnrestrictedWrite in contract 'Whitelist':
    |    function unWhitelistAddresses(address[] _users) public onlyWhitelistAdmin {
    |        for (uint256 i = 0; i < _users.length; i++) {
  > |            whitelist[_users[i]] = false;
    |        }
    |    }
  at Sale1.sol(1159)

[33mWarning[0m for UnrestrictedWrite in contract 'Whitelist':
    |
    |    function addWhitelistAdmin(address _admin) public onlyOwner {
  > |        whitelistAdmins[_admin] = true;
    |    }
    |
  at Sale1.sol(1135)

[33mWarning[0m for UnrestrictedWrite in contract 'Whitelist':
    |    function removeWhitelistAdmin(address _admin) public onlyOwner {
    |        require(_admin != owner, "Cannot remove contract owner");
  > |        whitelistAdmins[_admin] = false;
    |    }
    |
  at Sale1.sol(1140)

[FILE] SecurityTokenRegistryProxy.sol
Processing contract: SecurityTokenRegistryProxy.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SecurityTokenRegistryProxy.sol:EternalStorage
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SecurityTokenRegistryProxy.sol:OwnedUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SecurityTokenRegistryProxy.sol:Proxy
Processing contract: SecurityTokenRegistryProxy.sol:SecurityTokenRegistryProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SecurityTokenRegistryProxy.sol:UpgradeabilityProxy
[31mViolation[0m for LockedEther in contract 'EternalStorage':
    |pragma solidity ^0.4.24;
    |
  > |contract EternalStorage {
    |
    |    /// @notice Internal mappings used to store all kinds on data into the contract
  at SecurityTokenRegistryProxy.sol(3)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |        /////////////////////////////
    |
  > |    function getUintValues(bytes32 _variable) public view returns(uint256) {
    |        return uintStorage[_variable];
    |    }
  at SecurityTokenRegistryProxy.sol(239)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getBoolValues(bytes32 _variable) public view returns(bool) {
    |        return boolStorage[_variable];
    |    }
  at SecurityTokenRegistryProxy.sol(243)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getStringValues(bytes32 _variable) public view returns(string) {
    |        return stringStorage[_variable];
    |    }
  at SecurityTokenRegistryProxy.sol(247)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getAddressValues(bytes32 _variable) public view returns(address) {
    |        return addressStorage[_variable];
    |    }
  at SecurityTokenRegistryProxy.sol(251)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getBytes32Values(bytes32 _variable) public view returns(bytes32) {
    |        return bytes32Storage[_variable];
    |    }
  at SecurityTokenRegistryProxy.sol(255)

[31mViolation[0m for MissingInputValidation in contract 'EternalStorage':
    |    }
    |
  > |    function getBytesValues(bytes32 _variable) public view returns(bytes) {
    |        return bytesStorage[_variable];
    |    }
  at SecurityTokenRegistryProxy.sol(259)

[31mViolation[0m for RepeatedCall in contract 'OwnedUpgradeabilityProxy':
    |            // Call the implementation.
    |            // out and outsize are 0 because we don't know the size yet.
  > |            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |            // Copy the returned data.
  at SecurityTokenRegistryProxy.sol(299)

[33mWarning[0m for TODAmount in contract 'OwnedUpgradeabilityProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at SecurityTokenRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'OwnedUpgradeabilityProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at SecurityTokenRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    |        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), "New version equals to current");
    |        __version = _newVersion;
  > |        __implementation = _newImplementation;
    |        emit Upgraded(_newVersion, _newImplementation);
    |    }
  at SecurityTokenRegistryProxy.sol(376)

[33mWarning[0m for UnrestrictedWrite in contract 'OwnedUpgradeabilityProxy':
    | * @dev This contract combines an upgradeability proxy with basic authorization control functionalities
    | */
  > |contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {
    |
    |    // Owner of the contract
  at SecurityTokenRegistryProxy.sol(386)

[31mViolation[0m for RepeatedCall in contract 'SecurityTokenRegistryProxy':
    |            // Call the implementation.
    |            // out and outsize are 0 because we don't know the size yet.
  > |            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |            // Copy the returned data.
  at SecurityTokenRegistryProxy.sol(299)

[33mWarning[0m for TODAmount in contract 'SecurityTokenRegistryProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at SecurityTokenRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SecurityTokenRegistryProxy':
    |        _upgradeTo(_newVersion, _newImplementation);
    |        /*solium-disable-next-line security/no-call-value*/
  > |        require(address(this).call.value(msg.value)(_data), "Fail in executing the function of implementation contract");
    |    }
    |
  at SecurityTokenRegistryProxy.sol(493)

[33mWarning[0m for UnrestrictedWrite in contract 'SecurityTokenRegistryProxy':
    |        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), "New version equals to current");
    |        __version = _newVersion;
  > |        __implementation = _newImplementation;
    |        emit Upgraded(_newVersion, _newImplementation);
    |    }
  at SecurityTokenRegistryProxy.sol(376)

[33mWarning[0m for UnrestrictedWrite in contract 'SecurityTokenRegistryProxy':
    | */
    |/*solium-disable-next-line no-empty-blocks*/
  > |contract SecurityTokenRegistryProxy is EternalStorage, OwnedUpgradeabilityProxy {
    |
    |}
  at SecurityTokenRegistryProxy.sol(505)

[FILE] SnowStorm.sol
Processing contract: SnowStorm.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SnowStorm.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SnowStorm.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SnowStorm.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SnowStorm.sol:PlayerBookInterface
Processing contract: SnowStorm.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SnowStorm.sol:Snow
Processing contract: SnowStorm.sol:SnowStorm
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle5358011106192910703/mustExplicit -j 8 -F /tmp/souffle-fa8c7c92-59e8-442b-9e42-82616815da5c -D /tmp/souffle-fa8c7c92-59e8-442b-9e42-82616815da5c_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: SnowStorm.sol:SnowStorm
Processing contract: SnowStorm.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] SpicyPot.sol
Processing contract: SpicyPot.sol:F3DKeysCalcLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SpicyPot.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SpicyPot.sol:F3DexternalSettingsInterface
Processing contract: SpicyPot.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SpicyPot.sol:ONEevents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SpicyPot.sol:OneForwarderInterface
Processing contract: SpicyPot.sol:PlayerBookInterface
Processing contract: SpicyPot.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SpicyPot.sol:SpicyPot
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle2457364812170254879/mustExplicit -j 8 -F /tmp/souffle-3c36585f-6eda-4f50-a5dd-f6d960795d81 -D /tmp/souffle-3c36585f-6eda-4f50-a5dd-f6d960795d81_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: SpicyPot.sol:SpicyPot
Processing contract: SpicyPot.sol:modularLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SpicyPot.sol:otherFoMo3D
Processing contract: SuperFoMo3D.sol:DiviesInterface
Processing contract: SuperFoMo3D.sol:F3DKeysCalcLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:F3DexternalSettingsInterface
Processing contract: SuperFoMo3D.sol:JIincForwarderInterface
Processing contract: SuperFoMo3D.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:PlayerBookInterface
Processing contract: SuperFoMo3D.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: SuperFoMo3D.sol:SuperFoMo3D
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for DAOConstantGas in contract 'SuperFoMo3D':
    |    {
    |        require(customerBalance[msg.sender] >= _value,'please ensure you have enough balance');
  > |        msg.sender.transfer(_value);
    |        customerBalance[msg.sender] = customerBalance[msg.sender].sub(_value);
    |        return customerBalance[msg.sender];
  at SuperFoMo3D.sol(462)

[33mWarning[0m for TODAmount in contract 'SuperFoMo3D':
    |        address _addr = msg.sender;
    |        uint256 _paid = msg.value;
  > |        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);
    |        
    |        uint256 _pID = pIDxAddr_[_addr];
  at SuperFoMo3D.sol(523)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'SuperFoMo3D':
    |        address _addr = msg.sender;
    |        uint256 _paid = msg.value;
  > |        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);
    |        
    |        uint256 _pID = pIDxAddr_[_addr];
  at SuperFoMo3D.sol(523)

[FILE] USDTieredSTOFactory.sol
Processing contract: USDTieredSTOFactory.sol:IERC20
Processing contract: USDTieredSTOFactory.sol:IModuleFactory
Processing contract: USDTieredSTOFactory.sol:IUSDTieredSTOProxy
Processing contract: USDTieredSTOFactory.sol:ModuleFactory
Processing contract: USDTieredSTOFactory.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: USDTieredSTOFactory.sol:USDTieredSTOFactory
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: USDTieredSTOFactory.sol:Util
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: USDTieredSTOFactory.sol:VersionUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at USDTieredSTOFactory.sol(184)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at USDTieredSTOFactory.sol(166)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at USDTieredSTOFactory.sol(184)

[31mViolation[0m for LockedEther in contract 'USDTieredSTOFactory':
    | * @title Factory for deploying CappedSTO module
    | */
  > |contract USDTieredSTOFactory is ModuleFactory {
    |
    |    address public USDTieredSTOProxyAddress;
  at USDTieredSTOFactory.sol(567)

[31mViolation[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |            require(VersionUtils.isValidVersion(_currentVersion, _newVersion), "Failed because of in-valid version");
    |        }
  > |        compatibleSTVersionRange[_boundType] = VersionUtils.pack(_newVersion[0], _newVersion[1], _newVersion[2]);
    |        emit ChangeSTVersionBound(_boundType, _newVersion[0], _newVersion[1], _newVersion[2]);
    |    }
  at USDTieredSTOFactory.sol(447)

[31mViolation[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    | * @title Factory for deploying CappedSTO module
    | */
  > |contract USDTieredSTOFactory is ModuleFactory {
    |
    |    address public USDTieredSTOProxyAddress;
  at USDTieredSTOFactory.sol(567)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at USDTieredSTOFactory.sol(166)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at USDTieredSTOFactory.sol(184)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {
    |        emit ChangeFactorySetupFee(setupCost, _newSetupCost, address(this));
  > |        setupCost = _newSetupCost;
    |    }
    |
  at USDTieredSTOFactory.sol(373)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {
    |        emit ChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));
  > |        usageCost = _newUsageCost;
    |    }
    |
  at USDTieredSTOFactory.sol(382)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {
    |        emit ChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));
  > |        monthlySubscriptionCost = _newSubscriptionCost;
    |
    |    }
  at USDTieredSTOFactory.sol(391)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    |    function changeName(bytes32 _newName) public onlyOwner {
    |        require(_newName != bytes32(0),"Invalid name");
  > |        name = _newName;
    |    }
    |
  at USDTieredSTOFactory.sol(419)

[33mWarning[0m for UnrestrictedWrite in contract 'USDTieredSTOFactory':
    | * @title Factory for deploying CappedSTO module
    | */
  > |contract USDTieredSTOFactory is ModuleFactory {
    |
    |    address public USDTieredSTOProxyAddress;
  at USDTieredSTOFactory.sol(567)

[FILE] UpgradeabilityProxyFactory.sol
Processing contract: UpgradeabilityProxyFactory.sol:AddressUtils
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: UpgradeabilityProxyFactory.sol:AdminUpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: UpgradeabilityProxyFactory.sol:Proxy
Processing contract: UpgradeabilityProxyFactory.sol:UpgradeabilityProxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: UpgradeabilityProxyFactory.sol:UpgradeabilityProxyFactory
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for RepeatedCall in contract 'AdminUpgradeabilityProxy':
    |      // Call the implementation.
    |      // out and outsize are 0 because we don't know the size yet.
  > |      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)
    |
    |      // Copy the returned data.
  at UpgradeabilityProxyFactory.sol(41)

[33mWarning[0m for TODAmount in contract 'AdminUpgradeabilityProxy':
    |  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
    |    _upgradeTo(newImplementation);
  > |    require(address(this).call.value(msg.value)(data));
    |  }
    |
  at UpgradeabilityProxyFactory.sol(262)

[33mWarning[0m for LockedEther in contract 'UpgradeabilityProxyFactory':
    | * @dev Factory to create upgradeability proxies.
    | */
  > |contract UpgradeabilityProxyFactory {
    |  /**
    |   * @dev Emitted when a new proxy is created.
  at UpgradeabilityProxyFactory.sol(302)

[31mViolation[0m for MissingInputValidation in contract 'UpgradeabilityProxyFactory':
    |   * @return Address of the new proxy.
    |   */
  > |  function createProxy(address admin, address implementation) public returns (AdminUpgradeabilityProxy) {
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  at UpgradeabilityProxyFactory.sol(315)

[31mViolation[0m for MissingInputValidation in contract 'UpgradeabilityProxyFactory':
    |   * @return Address of the new proxy.
    |   */
  > |  function createProxyAndCall(address admin, address implementation, bytes data) public payable returns (AdminUpgradeabilityProxy) {
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  at UpgradeabilityProxyFactory.sol(332)

[33mWarning[0m for TODAmount in contract 'UpgradeabilityProxyFactory':
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  > |    require(address(proxy).call.value(msg.value)(data));
    |    return proxy;
    |  }
  at UpgradeabilityProxyFactory.sol(335)

[33mWarning[0m for TODReceiver in contract 'UpgradeabilityProxyFactory':
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  > |    require(address(proxy).call.value(msg.value)(data));
    |    return proxy;
    |  }
  at UpgradeabilityProxyFactory.sol(335)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'UpgradeabilityProxyFactory':
    |    AdminUpgradeabilityProxy proxy = _createProxy(implementation);
    |    proxy.changeAdmin(admin);
  > |    require(address(proxy).call.value(msg.value)(data));
    |    return proxy;
    |  }
  at UpgradeabilityProxyFactory.sol(335)

[FILE] WorldFomo.sol
Processing contract: WorldFomo.sol:F3DKeysCalcShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WorldFomo.sol:F3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WorldFomo.sol:F3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WorldFomo.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WorldFomo.sol:PlayerBookInterface
Processing contract: WorldFomo.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: WorldFomo.sol:WorldFomo
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle1825936427920860693/mustExplicit -j 8 -F /tmp/souffle-b18feb32-4c85-4c9c-a054-3c55dd76ef9f -D /tmp/souffle-b18feb32-4c85-4c9c-a054-3c55dd76ef9f_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: WorldFomo.sol:WorldFomo
Processing contract: WorldFomo.sol:modularShort
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[FILE] X3Dlong.sol
Processing contract: X3Dlong.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: X3Dlong.sol:Ownable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: X3Dlong.sol:PlayerBookInterface
Processing contract: X3Dlong.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: X3Dlong.sol:X3DKeysCalcLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: X3Dlong.sol:X3Ddatasets
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: X3Dlong.sol:X3Devents
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: X3Dlong.sol:X3Dlong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle5045451406883290590/mustExplicit -j 8 -F /tmp/souffle-8c9499a0-ed2a-4acb-9b1a-93c16eb6e684 -D /tmp/souffle-8c9499a0-ed2a-4acb-9b1a-93c16eb6e684_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: X3Dlong.sol:X3Dlong
Processing contract: X3Dlong.sol:modularLong
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at X3Dlong.sol(173)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |  function renounceOwnership() public onlyOwner {
    |    emit OwnershipRenounced(owner);
  > |    owner = address(0);
    |  }
    |
  at X3Dlong.sol(155)

[33mWarning[0m for UnrestrictedWrite in contract 'Ownable':
    |    require(_newOwner != address(0));
    |    emit OwnershipTransferred(owner, _newOwner);
  > |    owner = _newOwner;
    |  }
    |}
  at X3Dlong.sol(173)

[FILE] ZaynixKey.sol
Processing contract: ZaynixKey.sol:KeysCalc
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ZaynixKey.sol:NameFilter
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ZaynixKey.sol:PlayerBookInterface
Processing contract: ZaynixKey.sol:SafeMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: ZaynixKey.sol:ZaynixKey
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
[FILE] fathercontract.sol
Processing contract: fathercontract.sol:ERC20
Processing contract: fathercontract.sol:father
Processing contract: fathercontract.sol:fathercontract
  Attempt to decompile the contract with methods...
[FILE] EternalStorageProxyForAirdropper.sol
